# shruggie-indexer — Pending Updates (2026-02-25, Batch 7)

- **Project:** `shruggie-indexer`
- **Repository:** [shruggietech/shruggie-indexer](https://github.com/shruggietech/shruggie-indexer)
- **Author:** William Thompson (ShruggieTech LLC)
- **Date:** 2026-02-25
- **Target Release:** Pre-v0.1.1 (continued stabilization)
- **Audience:** AI-first, Human-second
- **Predecessor:** This document follows `20260225-006-Updates.md`. It assumes all five sections from Batch 6 (sidecar exclusion, MetaMergeDelete deletion, rename completeness, in-place sidecar naming after rename, and permanent test infrastructure) have been implemented. The runtime log (`20260225-006-Updates_Runtime.log`), filesystem tree (`data_tree.json`), and cumulative output file (`data_directorymeta2.json`) from the Batch 6 validation run are the primary evidence files for the issues described here.

---

## Purpose

The Batch 6 validation run confirms that the core pipeline fixes are functioning correctly: sidecar exclusion, MetaMergeDelete, in-place sidecar rename coordination, and item count accuracy are all working as designed. However, post-run inspection of the output artifacts revealed three additional issues:

1. **In-place directory sidecar files use a bare `_directorymeta2.json` filename** instead of the expected `{dirname}_directorymeta2.json` convention. This makes the files unidentifiable by name alone when viewed in a file manager or when multiple directories' sidecars are compared side by side.
2. **The rename phase silently discards files** when two or more content files share an identical content hash (and thus the same `storage_name`). The first file renames successfully; subsequent files with the same target name are skipped without any log message.
3. **MetaMergeDelete performs deletions but produces no log output.** The Batch 6 acceptance criteria (§2.8) require `INFO`-level logging for each deleted sidecar file.

Additionally, all behavioral changes made during Batch 6 must be propagated to the Technical Specification and the documentation site.

### Implementation Ordering

1. **Section 1** (In-place directory sidecar naming) — Fix `build_sidecar_path()` and its unit test. This is a self-contained paths module change with no downstream dependencies.
2. **Section 2** (Rename collision logging) — Add `WARNING`-level logging when a rename target already exists on disk. This is a self-contained rename module change.
3. **Section 3** (MetaMergeDelete deletion logging) — Verify and correct the post-processing delete loop's logging. Self-contained.
4. **Section 4** (Technical Specification updates) — Apply accumulated spec amendments from Batch 6 and this batch. Depends on Sections 1–3 being finalized so the spec reflects the corrected behavior.
5. **Section 5** (Documentation site updates) — Update user-facing documentation to match current behavior. Depends on Section 4.

---

## 1. In-Place Directory Sidecar Naming (Priority: High)

### 1.1. Problem Statement

When in-place sidecar output is active, each directory in the traversal tree receives a `_directorymeta2.json` file written inside that directory. The file contains the correct data — the directory's full `IndexEntry` — but the filename itself is a bare `_directorymeta2.json` with no directory name prefix.

The aggregate output file written *alongside* the target directory uses the correct naming convention: `{dirname}_directorymeta2.json` (e.g., `data_directorymeta2.json`). The in-place files do not follow this convention.

### 1.2. Evidence from Filesystem Tree

The `data_tree.json` post-run snapshot shows that every in-place directory sidecar uses the bare name:

| Directory | In-place sidecar written | Expected name |
|-----------|-------------------------|---------------|
| `data/` | `data/_directorymeta2.json` | `data/data_directorymeta2.json` |
| `data/empty/` | `data/empty/_directorymeta2.json` | `data/empty/empty_directorymeta2.json` |
| `data/empty/pdf/` | `data/empty/pdf/_directorymeta2.json` | `data/empty/pdf/pdf_directorymeta2.json` |
| `data/empty/pdf/pdf/` | `data/empty/pdf/pdf/_directorymeta2.json` | `data/empty/pdf/pdf/pdf_directorymeta2.json` |
| `data/images/` | `data/images/_directorymeta2.json` | `data/images/images_directorymeta2.json` |
| `data/not-empty/` | `data/not-empty/_directorymeta2.json` | `data/not-empty/not-empty_directorymeta2.json` |
| (all subdirectories) | Same pattern | Same pattern |

Visual confirmation via Windows Explorer: the aggregate file outside the target (`data_directorymeta2.json`) displays with its directory name prefix; all files inside the target tree display as `_directorymeta2.json` with no identifying name visible.

### 1.3. Impact

1. **Human-unreadable filenames.** Every directory in the tree gets an identically named `_directorymeta2.json`. When examining the filesystem, comparing directories, or transferring sidecar files, there is no way to identify which directory a sidecar belongs to without examining its path or content.

2. **Inconsistency with aggregate output naming.** The aggregate output uses `{dirname}_directorymeta2.json` (the correct convention from the spec's output path table). In-place sidecars should follow the same naming convention.

3. **Inconsistency with file sidecar naming.** File sidecars correctly use `{filename}_meta2.json` — the item's name is always the prefix. Directory sidecars break this convention by omitting the directory name.

### 1.4. Root Cause

The `build_sidecar_path()` function in `core/paths.py` constructs directory sidecar paths as `item_path / "_directorymeta2.json"`, omitting the directory name:

```python
def build_sidecar_path(item_path: Path, item_type: str) -> Path:
    if item_type == "directory":
        return item_path / "_directorymeta2.json"    # ← BUG: bare name
    return item_path.parent / f"{item_path.name}_meta2.json"
```

The correct construction is:

```python
def build_sidecar_path(item_path: Path, item_type: str) -> Path:
    if item_type == "directory":
        return item_path / f"{item_path.name}_directorymeta2.json"
    return item_path.parent / f"{item_path.name}_meta2.json"
```

This produces `data/images/images_directorymeta2.json`, which:

- Follows the same `{name}_suffix.json` convention as file sidecars.
- Matches the aggregate output naming convention (`images_directorymeta2.json`).
- Is still correctly matched by the `metadata_exclude_patterns` regex `_(meta2?|directorymeta2?)\.json$`, because the pattern is end-anchored and `images_directorymeta2.json` ends with `_directorymeta2.json`.

### 1.5. Spec Discrepancy

The Technical Specification (§6.2) currently documents the buggy behavior:

> For directories: `<item_path>/_directorymeta2.json`

This must be corrected to:

> For directories: `<item_path>/<dirname>_directorymeta2.json`

See Section 4 for the full spec update.

### 1.6. Test Update

The existing unit test in `tests/unit/test_paths.py` codifies the incorrect behavior:

```python
def test_sidecar_path_directory(self) -> None:
    """Directory sidecar: vacation/ -> vacation/_directorymeta2.json."""
    p = Path("/photos/vacation")
    result = build_sidecar_path(p, "directory")
    assert result == Path("/photos/vacation/_directorymeta2.json")
```

This test must be updated to:

```python
def test_sidecar_path_directory(self) -> None:
    """Directory sidecar: vacation/ -> vacation/vacation_directorymeta2.json."""
    p = Path("/photos/vacation")
    result = build_sidecar_path(p, "directory")
    assert result == Path("/photos/vacation/vacation_directorymeta2.json")
```

### 1.7. Affected Files

| File | Role |
|------|------|
| `src/shruggie_indexer/core/paths.py` | `build_sidecar_path()` — primary fix location |
| `tests/unit/test_paths.py` | `TestBuildSidecarPath.test_sidecar_path_directory()` — update expected value |

### 1.8. Acceptance Criteria

- In-place directory sidecar files are named `{dirname}_directorymeta2.json` (e.g., `images_directorymeta2.json` inside the `images/` directory).
- The aggregate output file alongside the target directory retains its existing naming (`{dirname}_directorymeta2.json` outside the directory).
- The `metadata_exclude_patterns` regex still correctly matches the new filenames.
- The `test_sidecar_path_directory` unit test passes with the corrected expected path.
- No other tests regress.

---

## 2. Rename Phase: Silent Collision Skips (Priority: Medium)

### 2.1. Problem Statement

When two or more files in the same directory have identical content (and therefore identical content hashes, identical `id` values, and identical `storage_name` values), the rename phase renames the first file successfully and silently skips the remaining files. No log message is emitted explaining the skip.

### 2.2. Evidence from Batch 6 Validation

The `images/` directory contains three groups of identical files:

| Group | Files (identical content) | Shared `storage_name` |
|-------|--------------------------|----------------------|
| GIF | `slippers.gif`, `slippers_01.gif`, `slippers_02.gif` | `yB4ADC74442D00EE0953105C01D42B72B.gif` |
| PNG | `slippers.png`, `slippers_01.png`, `slippers_02.png` | `yB4ADC74442D00EE0953105C01D42B72B.png` |
| WebM | `slippers.webm`, `slippers_01.webm`, `slippers_02.webm` | `yF537F5924FA0945578F0A5EDEF39218D.webm` |

In each group, the first file (`slippers.*`) was renamed to its `storage_name`. The remaining files (`slippers_01.*`, `slippers_02.*`) remain on disk with their original names, their in-place `_meta2.json` sidecars were written, but no rename was attempted or logged.

The post-run filesystem shows both the renamed and unrenamed files coexisting:

```
images/
├── slippers_01.gif                  ← NOT renamed (collision)
├── slippers_01.gif_meta2.json
├── slippers_02.gif                  ← NOT renamed (collision)
├── slippers_02.gif_meta2.json
├── yB4ADC74442D00EE0953105C01D42B72B.gif   ← renamed from slippers.gif
├── yB4ADC74442D00EE0953105C01D42B72B.gif_meta2.json
...
```

### 2.3. Expected Behavior

When the rename target already exists on disk (because an earlier file with the same hash has already been renamed to that name), the rename phase must:

1. **Skip the rename** — do not overwrite the existing file. This is the correct behavior, already happening implicitly.
2. **Log the skip at `WARNING` level** — the message must clearly identify the collision:
   ```
   Rename SKIPPED (collision): {original_name} → {storage_name} (target already exists)
   ```
3. **Continue processing** — the collision does not abort the rename loop.

### 2.4. Scope Limitation

This section addresses **logging only**. The question of how the indexer should semantically handle duplicate-content files during rename (e.g., whether to use a collision suffix, whether to deduplicate, or whether to warn the user) is a design decision deferred to a future batch. The original MakeIndex used `Move-Item -Force`, which silently overwrites — the current Python behavior of skipping is strictly safer and preferable.

### 2.5. Affected Files

| File | Role |
|------|------|
| `src/shruggie_indexer/core/rename.py` | `rename_item()` — add collision detection logging before the rename attempt |

### 2.6. Acceptance Criteria

- When a rename target path already exists on disk, the rename is skipped and a `WARNING`-level log message is emitted: `Rename SKIPPED (collision): {original_name} → {storage_name} (target already exists)`.
- The collision does not raise an exception or abort the rename loop.
- Files that would collide retain their original names on disk.
- The in-place sidecar for a collision-skipped file retains the original filename as its base (since no rename occurred).

---

## 3. MetaMergeDelete: Missing Deletion Logging (Priority: Medium)

### 3.1. Problem Statement

The Batch 6 validation run confirms that MetaMergeDelete is deleting sidecar files as expected — all yt-dlp sidecars, `FeedsExport.7z_info.json`, and `FeedsExport_info.json` are absent from the post-run filesystem. However, the runtime log contains zero deletion messages. The Batch 6 acceptance criteria (§2.8) require:

- `INFO`: `Sidecar deleted: {path}` for each successful deletion.
- `ERROR`: `Sidecar delete FAILED: {path}: {exception}` for each failed deletion.

Neither message appears at any log level.

### 3.2. Likely Cause

The delete loop executes correctly (files are removed) but either:

1. The logging statements were never added to the loop, or
2. The logging statements exist but use a logger that is not configured to output at `INFO` level for the post-processing phase.

### 3.3. Required Fix

Verify that the post-processing delete loop contains `INFO`-level logging for each successful deletion and `ERROR`-level logging for each failure, using the exact message formats from Batch 6 §2.5:

```python
for sidecar_path in delete_queue:
    try:
        sidecar_path.unlink()
        logger.info("Sidecar deleted: %s", sidecar_path)
    except OSError as exc:
        logger.error("Sidecar delete FAILED: %s: %s", sidecar_path, exc)
```

If the logging statements exist but are not appearing, verify that the logger for the module executing the delete loop has `INFO`-level output enabled. The GUI orchestrator may be filtering log levels.

### 3.4. Affected Files

| File | Role |
|------|------|
| `src/shruggie_indexer/gui/app.py` | GUI orchestrator — likely location of the delete loop; verify logging exists |
| `src/shruggie_indexer/cli/commands.py` | CLI entry point — same verification |
| `src/shruggie_indexer/core/entry.py` | `index_path()` — check if delete loop is here instead |

### 3.5. Acceptance Criteria

- Each sidecar file deleted by MetaMergeDelete produces an `INFO`-level log message: `Sidecar deleted: {path}`.
- Each failed deletion produces an `ERROR`-level log message: `Sidecar delete FAILED: {path}: {exception}`.
- The log messages appear in both GUI and CLI runtime output when log level is set to `INFO` or lower.
- Running against the test directory with MetaMergeDelete active shows deletion log lines for all consumed sidecar files.

---

## 4. Technical Specification Updates (Priority: High)

### 4.1. Purpose

All behavioral changes implemented during Batch 6 (and the `build_sidecar_path` correction from Section 1 of this batch) must be reflected in the Technical Specification (`shruggie-indexer-spec.md`). The spec is the single source of truth for AI-assisted development — if the spec doesn't match the code, future implementing agents will produce incorrect implementations.

### 4.2. Amendment Summary

The following spec sections require updates. Each amendment is categorized as a **correction** (the spec previously documented incorrect behavior), an **addition** (the spec lacked coverage for this behavior), or a **clarification** (the spec was ambiguous and now needs to be precise).

| # | Section | Amendment type | Description |
|---|---------|---------------|-------------|
| A | §6.1 (Traversal) | Addition | Document the two-layer sidecar exclusion mechanism during `list_children()`: Layer 1 (`metadata_exclude_patterns`, always active) and Layer 2 (`metadata_identify` union, when MetaMerge is active). Reference §7.5 for the pattern definitions. Add the `DEBUG`-level log message format: `Excluded {n} file(s) by metadata_exclude_patterns in {directory}` and `Excluded {n} sidecar file(s) from entry building in {directory}`. |
| B | §6.2 (Paths) | Correction | Fix the `build_sidecar_path()` documentation. Change `For directories: <item_path>/_directorymeta2.json` to `For directories: <item_path>/<dirname>_directorymeta2.json`. Update the docstring example accordingly. |
| C | §6.9 (Serialization & Output) | Addition | Document that the `write_inplace()` function writes directory sidecars using the `{dirname}_directorymeta2.json` convention inside the directory. Add a note clarifying the distinction between the aggregate output file (written alongside the target) and in-place directory sidecars (written inside each directory). Both use the same `{dirname}_directorymeta2.json` naming — they differ only in location. |
| D | §6.9 (Serialization & Output) | Addition | Document the in-place sidecar rename coordination when rename is active (Option B from Batch 6 §4.6): the sidecar is initially written during traversal using the original filename, then renamed alongside the content file during the rename phase. Add the `DEBUG`-level log message: `Inplace sidecar renamed: {original_sidecar} → {renamed_sidecar}`. |
| E | §6.10 (File Rename) | Addition | Document rename collision behavior: when the target path already exists, the rename is skipped with a `WARNING`-level log. Add the message format: `Rename SKIPPED (collision): {original_name} → {storage_name} (target already exists)`. Note that `Move-Item -Force` in the original would silently overwrite; the Python implementation's skip-and-warn is a deliberate safety improvement (this may be cataloged as a new deviation in §2.6 if the project convention warrants it). |
| F | §6.10 (File Rename) | Addition | Document that the rename phase also renames each file's in-place `_meta2.json` sidecar from `{original_name}_meta2.json` to `{storage_name}_meta2.json`, preserving the file-sidecar association on disk. |
| G | §6 (Stage 6 — Post-Processing) | Addition | Document the MetaMergeDelete execution loop: iterate `delete_queue`, call `Path.unlink()` on each entry, log `INFO` on success, log `ERROR` on failure, continue on failure. Document that the delete phase runs after the rename phase (ordering: indexing → in-place sidecar write → rename → delete). |
| H | §7.5 (metadata_exclude_patterns) | Clarification | Add an explicit note confirming that the regex `_(meta2?|directorymeta2?)\.json$` matches both bare filenames (`_directorymeta2.json`) and prefixed filenames (`images_directorymeta2.json`, `video.mp4_meta2.json`) because the pattern is end-anchored with no start anchor. |
| I | §10.4 or §8 (GUI/CLI) | Addition | Document the `delete_queue` wiring: when `config.meta_merge_delete` is `True`, the orchestrator (GUI or CLI) creates a `list[Path]` and passes it through `index_path()` → `build_directory_entry()` → `sidecar.discover_and_parse()`. After indexing completes, the orchestrator iterates the queue and performs deletions. |
| J | §14.2 (Unit Test Coverage) | Addition | Add the test specifications from Batch 6 §5: `test_sidecar_exclusion.py`, `test_meta_merge_delete.py`, `test_integration_mmd_pipeline.py`, and the pytest markers (`sidecar`, `mmd`, `integration`, `destructive`). |

### 4.3. Spec Header Update

Update the spec header to reflect the amendment:

- **Date:** Change from `2026-02-24` to `2026-02-25`.
- **Status:** Remains `AMENDED`.

### 4.4. Implementation Notes

Each amendment above is a text edit to the existing spec file. No structural reorganization is required. The implementing agent must:

1. Locate each referenced section by its `<a id="...">` anchor.
2. Apply the amendment as a surgical edit — do not rewrite surrounding content.
3. Where an amendment adds new content, insert it at the end of the relevant subsection (before the next `---` or `###` heading).
4. Where an amendment corrects existing content, use `> **Updated 2026-02-25:**` callouts to mark the change, consistent with existing amendment conventions in the spec.

### 4.5. Acceptance Criteria

- All 10 amendments (A–J) are present in the spec.
- Each amendment uses the `> **Updated 2026-02-25:**` convention where it modifies existing text.
- No existing cross-references are broken by the edits.
- The spec's `build_sidecar_path` documentation matches the corrected implementation (Section 1 of this document).
- `mkdocs build --strict` passes after the spec changes (the spec is not directly in the docs site, but verify no downstream breakage).

---

## 5. Documentation Site Updates (Priority: Medium)

### 5.1. Purpose

The user-facing documentation must be updated to reflect all behavioral changes from Batch 6 and this batch. The documentation site is the public interface for users who are not reading the Technical Specification directly.

### 5.2. Pages Requiring Updates

| Page | File | Update required |
|------|------|-----------------|
| **Schema Reference** | `docs/schema/index.md` | No schema structure changes. Verify the `MetadataEntry` field table still reflects current behavior (sidecar `origin` entries now carry `file_system`, `size`, and `timestamps` fields from merged sidecars). |
| **Desktop Application** | `docs/user-guide/gui.md` | Update the MetaMergeDelete description to confirm that sidecar deletion is now functional. Remove or revise any caveats or "planned" language about the delete phase. Document the pipeline ordering visible to the user: index → write sidecars → rename → delete. |
| **CLI Reference** | `docs/user-guide/cli-reference.md` | Same MetaMergeDelete update as the GUI page. Ensure the `--meta-merge-delete` flag description documents the deletion behavior. |
| **Configuration** | `docs/user-guide/configuration.md` | Verify the `metadata_exclude_patterns` documentation matches the current pattern list. Add a note about the two-layer exclusion mechanism (Layer 1: exclude patterns, Layer 2: sidecar identification when MetaMerge is active). |
| **Changelog** | `docs/changelog.md` (synced from `CHANGELOG.md`) | Add a new entry for the current development cycle documenting all Batch 6 and Batch 7 changes. |

### 5.3. Changelog Entry

Add the following to `CHANGELOG.md` under the `[Unreleased]` section (or create a new version section if appropriate):

```markdown
### Fixed
- **Sidecar exclusion from traversal.** Files matching `metadata_exclude_patterns` and files matching sidecar identification patterns (when MetaMerge is active) are now correctly excluded from the item list during discovery. Previously, indexer output artifacts (`_meta.json`, `_meta2.json`) and recognized sidecar files were indexed as standalone items, causing inflated item counts, sidecar-of-sidecar output files, and incorrect renames.
- **MetaMergeDelete deletion.** The delete phase now executes after indexing and rename operations, removing consumed sidecar files from disk. Previously, the "Delete" in MetaMergeDelete was non-functional.
- **Rename phase completeness.** All content files at all directory depths are now processed by the rename phase. Previously, files in some subdirectories were silently skipped.
- **In-place sidecar naming after rename.** When rename is active, the in-place `_meta2.json` sidecar file is renamed to match the content file's new `storage_name`. Previously, the sidecar retained the original filename, creating orphaned sidecars.
- **In-place directory sidecar naming.** Directory sidecar files written inside directories now use `{dirname}_directorymeta2.json` (e.g., `images_directorymeta2.json`). Previously, all in-place directory sidecars were named `_directorymeta2.json` with no identifying prefix.
- **Rename collision logging.** When multiple files share an identical content hash and the rename target already exists on disk, the skip is now logged at `WARNING` level. Previously, collisions were silent.
- **MetaMergeDelete deletion logging.** Each sidecar deletion is now logged at `INFO` level.

### Added
- Permanent test infrastructure for sidecar handling and MetaMergeDelete (`test_sidecar_exclusion.py`, `test_meta_merge_delete.py`, `test_integration_mmd_pipeline.py`).
- Pytest markers: `sidecar`, `mmd`, `integration`, `destructive`.
```

### 5.4. Implementation Notes

- All documentation pages are in the `docs/` directory and authored in Markdown.
- The `CHANGELOG.md` at the repository root is the authoritative source; `docs/changelog.md` is synced from it (per the build-time copy mechanism established in a prior batch).
- After all documentation edits, run `mkdocs build --strict` to verify zero warnings and no broken internal links.

### 5.5. Acceptance Criteria

- All five pages listed in §5.2 have been reviewed and updated where needed.
- The `CHANGELOG.md` entry from §5.3 is present.
- `mkdocs build --strict` passes with zero warnings.
- No behavioral claims in the documentation contradict the Technical Specification.

---

## Reference: Batch 6 Validation Summary

The following table summarizes the Batch 6 acceptance criteria and their observed status from the validation run, for the implementing agent's reference:

| Batch 6 Section | Acceptance Criteria | Status | Notes |
|-----------------|-------------------|--------|-------|
| §1 (Sidecar exclusion) | No sidecar files indexed as standalone items | ✅ Pass | Item counts correct across all directories. Exclusion log messages present. |
| §1 (Sidecar exclusion) | No sidecar-of-sidecar output | ✅ Pass | No `*_meta*_meta2.json` files in post-run tree. |
| §2 (MetaMergeDelete) | Consumed sidecars deleted from disk | ✅ Pass | All yt-dlp sidecars and FeedsExport info files absent from tree. |
| §2 (MetaMergeDelete) | Deletion logged at INFO | ❌ Fail | No deletion messages in log. See this document §3. |
| §3 (Rename completeness) | All content files renamed | ⚠️ Partial | 6 files skipped due to hash collision (duplicate content). Not a traversal bug — see this document §2. |
| §4 (In-place sidecar rename) | `_meta2.json` named relative to `storage_name` | ✅ Pass | Confirmed for all renamed files. |
| §4 (In-place sidecar rename) | No orphaned sidecars | ✅ Pass | All renamed files paired with correctly-named sidecars. |

---

## Reference: Test Directory State

The test directory at `A:\Code\shruggie-indexer-testing\data` must be restored to its pre-run state before the next validation run. The `Refresh-TestData.ps1` script (visible in the parent directory per the user's screenshot) should be used for this purpose. Key artifacts to verify after restoration:

- All `_meta2.json` and `_directorymeta2.json` files from this run are removed.
- All renamed files (y-prefixed) are restored to their original names.
- Prior-run `_meta.json` artifacts may be retained for sidecar exclusion testing.
- The original 38-file, 10-directory structure is intact.
