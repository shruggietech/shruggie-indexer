# Pending Updates (2026-03-01) — Batch 001

**Date:** 2026-03-01
**Scope:** shruggie-indexer
**Status:** PENDING

---

## Overview

This batch introduces two user-facing feature enhancements: native de-duplication during rename operations, and the ability to suppress directory metadata output files. Both features address real-world usage friction identified through repeated manual post-processing of indexer output.

### Session Ordering

1. **Section 1** (Native De-Duplication) — Extends the existing rename collision path from skip-and-warn to delete-and-warn. Self-contained within `core/rename.py` and its callers.
2. **Section 2** (Suppress Directory Metadata Output) — Adds a new configuration field, CLI flag, and GUI control to suppress `_directorymeta2.json` output files. Touches config, serializer, CLI, GUI, and their callers.
3. **Section 3** (Specification, Documentation, and Changelog Updates) — Must be executed last, after Sections 1–2 are complete and verified.

---

## 1. Native De-Duplication (Priority: High)

### 1.1. Problem Statement

When the Rename feature is active and multiple files within the same directory share identical content (and therefore identical `storage_name` values), the current behavior is:

1. The first file is renamed to its `storage_name` (e.g., `slippers.gif` → `yB4ADC74442D00EE0953105C01D42B72B.gif`).
2. Subsequent files with the same hash are **skipped** — they remain on disk with their original names.
3. A `WARNING`-level log is emitted: `Rename SKIPPED (collision): {original_name} → {storage_name} (target already exists)`.

This produces a directory containing one canonical file (the renamed one) alongside its duplicate(s) (the skipped ones). In practice, users then manually delete these leftover duplicates to complete the deduplication that the rename was intended to accomplish.

### 1.2. Desired Behavior

When a rename collision is detected (target path exists, different inode), the collision-skipped file should be **deleted** instead of left on disk. This simulates native de-duplication: the first file becomes the canonical copy under the content-addressed storage name, and all subsequent duplicates are removed.

**Post-deduplication filesystem (same scenario as §1.1):**

```
images/
├── yB4ADC74442D00EE0953105C01D42B72B.gif        ← renamed from slippers.gif
├── yB4ADC74442D00EE0953105C01D42B72B.gif_meta2.json
```

The duplicate files (`slippers_01.gif`, `slippers_02.gif`) and their associated in-place sidecar files (`slippers_01.gif_meta2.json`, `slippers_02.gif_meta2.json`) are deleted.

### 1.3. Design Decisions

**A. Default behavior.** De-duplication is the DEFAULT behavior when Rename is active. No opt-in flag is required. This aligns with the fundamental purpose of content-addressed rename: if two files are byte-identical, only one copy needs to exist.

**B. Dry-run interaction.** When `--dry-run` is active, de-duplication MUST be previewed, not executed. The log message should indicate what *would* happen:

```
Dry run — would deduplicate (delete): {original_name} (duplicate of {storage_name})
```

**C. Sidecar cleanup.** When a duplicate file is deleted, its in-place `_meta2.json` sidecar (if one was written during the preceding in-place output phase) MUST also be deleted. Leaving an orphaned sidecar that references a deleted file is confusing and wastes disk space. The sidecar path is deterministic: `{original_name}_meta2.json`.

**D. No opt-out flag in this batch.** Since de-duplication is the natural consequence of content-addressed rename, an opt-out flag would re-introduce the current "leave duplicates on disk" behavior. If user feedback later indicates a need for this, an `--no-dedup` flag can be added in a future batch. For now, the skip-and-warn codepath is fully replaced by delete-and-warn.

### 1.4. Log Message Wording

The existing collision warning message must be updated to reflect the new outcome. The current message:

```
Rename SKIPPED (collision): {original_name} → {storage_name} (target already exists)
```

Must be replaced with:

```
Duplicate REMOVED: {original_name} (identical to {storage_name})
```

This wording:

- Uses `WARNING` level (unchanged).
- Clearly communicates the action taken (removal, not skip).
- Identifies the canonical file (`storage_name`) that the duplicate is identical to.

When the associated sidecar is also deleted, a `DEBUG`-level message should be emitted:

```
Orphaned sidecar deleted: {sidecar_path}
```

### 1.5. Implementation Details

**A. `rename_item()` in `core/rename.py`.**

The collision branch (line group beginning with `# Different inode = collision — skip and warn`) must be modified:

1. Delete the original file: `original_path.unlink()`.
2. Delete its in-place sidecar if it exists: check for `{original_name}_meta2.json` in the same directory and delete it.
3. Emit the updated `WARNING` log message.
4. Return a sentinel value that callers can distinguish from both "renamed successfully" and "no-op (same inode)". **Recommendation:** return `None` instead of `original_path`. This makes the de-duplication outcome explicit at the call site.

**B. Dry-run extension.**

The dry-run branch must be extended to log the de-duplication preview. When `dry_run=True` and a collision would occur, the existing dry-run code doesn't check for collisions (it returns the target path without examining the filesystem). The implementing agent should evaluate whether to add a collision check to the dry-run path for accuracy. If the performance cost is negligible (a single `target_path.exists()` check), it should be added for completeness.

**C. Callers in `cli/main.py` and `gui/app.py`.**

Both `_rename_tree()` in `cli/main.py` and `ShruggiIndexerApp._rename_tree()` in `gui/app.py` must handle the new `None` return value. Currently, they check `result_path != target_path` to decide whether to skip in-place sidecar rename. With de-duplication, the logic becomes:

- `None` return → file was deduplicated (deleted). Skip sidecar rename (the sidecar was already cleaned up by `rename_item()`).
- `original_path` return → no longer possible for collision case (this was the old skip behavior).
- `target_path` return → rename succeeded or no-op.

**D. Return value contract update.**

The updated `rename_item()` return value contract:

| Outcome | Return value |
|---------|-------------|
| Renamed successfully | New `Path` (target path) |
| Dry-run preview | Would-be `Path` (target path) |
| No-op (same inode, already renamed) | Existing `Path` (target path) |
| De-duplicated (collision, file deleted) | `None` |
| De-duplication dry-run preview | Would-be `Path` (target path), same as regular dry-run |

The return type annotation changes from `Path` to `Path | None`.

### 1.6. Affected Files

| File | Nature of change |
|------|------------------|
| `src/shruggie_indexer/core/rename.py` | `rename_item()` — replace collision skip with delete. Update return type to `Path | None`. Add sidecar cleanup logic. Update log messages. Extend dry-run for collision preview. |
| `src/shruggie_indexer/cli/main.py` | `_rename_tree()` — handle `None` return from `rename_item()`. |
| `src/shruggie_indexer/gui/app.py` | `_rename_tree()` — handle `None` return from `rename_item()`. |
| `tests/unit/test_rename.py` | Update `TestCollisionDetection` — collision now deletes instead of skipping. Add new tests for sidecar cleanup, dry-run collision preview, and `None` return value. |
| `tests/integration/` | Add or extend integration test verifying end-to-end de-duplication with duplicate files in a directory. |

### 1.7. Spec References

| Reference | Section |
|-----------|---------|
| Collision detection | `shruggie-indexer-spec.md` §6.10 (Collision detection) |
| Rename behavior | `shruggie-indexer-spec.md` §6.10 (Rename behavior) |
| Pipeline ordering | `shruggie-indexer-spec.md` §6.10 (MetaMergeDelete execution loop — pipeline ordering note) |

### 1.8. Acceptance Criteria

- When Rename is active and two or more files share an identical content hash, the first file is renamed to `storage_name` and all subsequent duplicate files are deleted from disk.
- Each deleted duplicate produces a `WARNING`-level log: `Duplicate REMOVED: {original_name} (identical to {storage_name})`.
- The in-place sidecar of each deleted duplicate is also deleted (if it exists), with a `DEBUG`-level log: `Orphaned sidecar deleted: {sidecar_path}`.
- `rename_item()` returns `None` when a file is deduplicated.
- All callers (`_rename_tree()` in CLI and GUI) handle the `None` return without errors.
- In dry-run mode, the log indicates what *would* be deduplicated without deleting anything.
- Existing tests for successful rename, no-op (same inode), and dry-run continue to pass.
- New tests validate the de-duplication path, sidecar cleanup, and `None` return contract.

---

## 2. Suppress Directory Metadata Output (Priority: Medium)

### 2.1. Problem Statement

When the indexer operates on a directory target, it produces `_directorymeta2.json` files in two forms:

1. **Aggregate output file** — Written alongside the target directory (e.g., `photos_directorymeta2.json` next to `photos/`). Contains the full entry tree. Produced by `write_output()` via `config.output_file`.
2. **In-place directory sidecars** — Written inside each child directory (e.g., `photos/vacation/vacation_directorymeta2.json`). Contains the subtree for that directory. Produced by `_write_inplace_tree()` during the in-place output phase.

Based on historic usage patterns, these directory-level output files are frequently deleted by the user after the indexer completes its operation. The per-file `_meta2.json` sidecars are the outputs users actually retain, particularly in rename workflows where they serve as reversal manifests.

This section adds an option to suppress all `_directorymeta2.json` output files while preserving per-file sidecar behavior.

### 2.2. New Configuration Field

**Field:** `write_directory_meta: bool`
**Default:** `True`
**Location:** `IndexerConfig` dataclass in `config/types.py`

When `False`:

- `write_output()` does NOT write the aggregate `_directorymeta2.json` file to disk (the `config.output_file` path is suppressed). Stdout output is also suppressed for directory targets, since the aggregate JSON payload is the directory-level output.
- `_write_inplace_tree()` skips directory entries entirely — only file entries receive in-place sidecars.

When `True` (default): current behavior is unchanged.

### 2.3. CLI Implementation

**New flag pair:** `--dir-meta / --no-dir-meta`

```python
@click.option(
    "--dir-meta/--no-dir-meta",
    default=True,
    show_default=True,
    help="Write directory-level metadata output files (_directorymeta2.json). "
         "Use --no-dir-meta to suppress these files while keeping per-file sidecars.",
)
```

The flag maps directly to `IndexerConfig.write_directory_meta`. The config loader's `scalar_keys` set must be updated to include `"write_directory_meta"`.

### 2.4. GUI Implementation

**New checkbox:** "Write directory summary files"
**Location:** Operations page → Output card, between the Mode dropdown (and its info label) and the read-only output path display.

```
Mode: [Single file ▾]
  (constraint info label)
☐ Write directory summary files          ← NEW CONTROL
[computed output path display]
  (output path note)
```

**Default state:** Checked (enabled).

**Behavior when unchecked:**

- The read-only output path display should show: *"(directory output suppressed — per-file sidecars only)"* when the target is a directory.
- For single-file targets, the checkbox is irrelevant and should be disabled with fine-print: *"Directory output is only applicable for directory targets."*

**Tooltip:** `"When unchecked, directory-level summary files (_directorymeta2.json) are not written to disk. Per-file sidecar files (_meta2.json) are unaffected."`

**Session persistence:** The checkbox state must be saved and restored via the session file. Field name: `write_directory_meta` (boolean).

### 2.5. Hint Text and Tooltip Audit

The Mode dropdown's current tooltip reads:

> Single file: one output file, no sidecars.
> Multi-file: summary file + per-file sidecar files.
> View only: display in viewer, nothing written to disk.

When `write_directory_meta` is `False`, the "one output file" and "summary file" descriptions become inaccurate. Rather than dynamically rewriting tooltip text (which adds complexity), the implementing agent should:

1. Keep the Mode dropdown tooltip as-is (it describes the mode's *intent*).
2. Ensure the read-only output path display accurately reflects what will actually happen, as documented in §2.4.
3. Add the info-label text below the checkbox when relevant (see §2.7 for constraint interactions).

### 2.6. Constraint and Dependency Analysis

The following existing behaviors interact with this feature. The implementing agent must observe these constraints during implementation.

**A. MetaMergeDelete safety (§7.1, validation rules).** The MetaMergeDelete safety check requires at least one persistent output mechanism (`output_file` or `output_inplace`) to be active. Suppressing directory output sets `output_file` to effectively `None` for directory targets. Implications by output mode:

| Output mode | `write_directory_meta=False` | Safety status |
|-------------|------------------------------|---------------|
| **Multi-file** | Per-file `_meta2.json` sidecars still written (`output_inplace=True`). No aggregate file. | ✅ Safe — `output_inplace` satisfies the safety check. Merged sidecar data is captured in each file's individual sidecar. |
| **Single file** | No aggregate file written. No per-file sidecars. | ⚠️ **Unsafe** — no persistent output captures the merged sidecar data before deletion. |
| **View only** | Already constrained for MetaMergeDelete (snap-back enforced). | N/A |

**Constraint rule:** When the operation is Meta Merge Delete AND `write_directory_meta` is `False`, the output mode MUST be forced to **Multi-file** to ensure the safety invariant holds. If the mode is currently Single file, `_reconcile_controls()` must fall back to Multi-file and display an info-label:

*"Single file mode is not available when directory output is suppressed for Meta Merge Delete. Multi-file mode ensures merged sidecar data is preserved."*

**B. Rename implies in-place output (§8.4).** When Rename is active, `config.output_inplace` is forced `True`. This means per-file sidecars are always written during rename workflows. Suppressing directory output during a rename operation is fully safe — the per-file sidecars (which include rename reversal manifests) are the critical output, and the directory summary files are the ones users discard.

**C. Stdout interaction.** When `write_directory_meta` is `False` and the target is a directory, the aggregate JSON payload (the full directory entry tree) should NOT be emitted to stdout either. The payload is the directory-level output that the user is explicitly suppressing. Emitting it to stdout while suppressing the outfile would be inconsistent. If the user wants the JSON for inspection, they can use View only mode or enable `--dir-meta`.

**D. Single-file targets.** When the target is a single file (not a directory), `write_directory_meta` has no effect — file targets produce `_meta2.json` sidecars, not `_directorymeta2.json` files. The option should be silently ignored for file targets (no validation error).

### 2.7. Implementation Details

**A. `config/types.py` — Add new field to `IndexerConfig`:**

```python
# Output routing
output_stdout: bool = True
output_file: Path | None = None
output_inplace: bool = False
write_directory_meta: bool = True  # NEW
```

**B. `config/loader.py` — Wire through the new field:**

- Add `"write_directory_meta"` to the `scalar_keys` set in `_apply_overrides()`.
- Add `write_directory_meta=config_dict.get("write_directory_meta", True)` to the `IndexerConfig` constructor call.
- No new implication chain is required.

**C. `cli/main.py` — Add the CLI flag and pass through:**

- Add the `--dir-meta/--no-dir-meta` option to the `@click.option` decorator stack.
- Pass it into the overrides dict: `overrides["write_directory_meta"] = dir_meta`.
- In the output routing section, gate the `write_output()` call:

```python
# Aggregate output (stdout + outfile)
if config.write_directory_meta or entry.type != "directory":
    write_output(entry, config)
else:
    logger.info("Directory output suppressed (--no-dir-meta).")
```

**D. `cli/main.py` and `gui/app.py` — Modify `_write_inplace_tree()`:**

When `config.write_directory_meta` is `False`, skip the directory branch entirely:

```python
elif entry.type == "directory":
    if not _is_root and config.write_directory_meta:  # MODIFIED
        dir_path = root_path.parent / entry.file_system.relative
        write_fn(entry, dir_path, "directory")
    if entry.items:
        for child in entry.items:
            _write_inplace_tree(child, root_path, write_fn, _is_root=False)
```

Note: The config must be threaded through `_write_inplace_tree()` as a new parameter. Currently the function does not receive config. The CLI version receives `write_fn` as a parameter; the GUI version calls `write_inplace` directly. Both need the `write_directory_meta` flag.

**E. `gui/app.py` — Add the checkbox and wire to config:**

- Add `_write_dir_meta_var = ctk.BooleanVar(value=True)` and the checkbox in `_build_output_group()`, positioned after the info label and before the output path display.
- Update `_build_config()` to include `overrides["write_directory_meta"] = self._write_dir_meta_var.get()`.
- Update `_reconcile_controls()` to enforce the MetaMergeDelete constraint (§2.6.A).
- Update `_update_output_path_display()` to show suppression text when unchecked.
- Add session persistence for the new variable.

### 2.8. Affected Files

| File | Nature of change |
|------|------------------|
| `src/shruggie_indexer/config/types.py` | Add `write_directory_meta: bool = True` to `IndexerConfig`. |
| `src/shruggie_indexer/config/loader.py` | Add `"write_directory_meta"` to scalar keys. Pass through to constructor. |
| `src/shruggie_indexer/cli/main.py` | Add `--dir-meta/--no-dir-meta` flag. Gate `write_output()` call. Thread config through `_write_inplace_tree()`. |
| `src/shruggie_indexer/gui/app.py` | Add checkbox, session persistence, `_reconcile_controls()` constraint, output path display update. Thread config through `_write_inplace_tree()`. |
| `tests/unit/test_serializer.py` | Add tests for `write_directory_meta=False` suppression behavior. |
| `tests/integration/test_output_modes.py` | Add tests verifying directory output suppression end-to-end. |

### 2.9. Spec References

| Reference | Section |
|-----------|---------|
| Output routing model | `shruggie-indexer-spec.md` §6.9 |
| Output scenarios | `shruggie-indexer-spec.md` §8.9 |
| CLI output flags | `shruggie-indexer-spec.md` §8.3 |
| GUI output controls | `shruggie-indexer-spec.md` §10.3 (Output controls) |
| MetaMergeDelete safety | `shruggie-indexer-spec.md` §7.1 (Validation rules) |
| Configuration architecture | `shruggie-indexer-spec.md` §7.1 |

### 2.10. Acceptance Criteria

- A new `--dir-meta/--no-dir-meta` CLI flag is available, defaulting to `--dir-meta` (enabled).
- When `--no-dir-meta` is passed with a directory target, no `_directorymeta2.json` files are written (neither aggregate nor in-place directory sidecars).
- Per-file `_meta2.json` sidecars are unaffected by this flag.
- When `--no-dir-meta` is passed with a single-file target, behavior is unchanged (the flag is silently ignored).
- The GUI exposes a "Write directory summary files" checkbox in the Output card, positioned after the Mode dropdown and before the output path display.
- When the checkbox is unchecked and the target is a directory, the output path display shows: *"(directory output suppressed — per-file sidecars only)"*.
- When the checkbox is unchecked and the target is a single file, the checkbox is disabled with fine-print: *"Directory output is only applicable for directory targets."*
- When Meta Merge Delete is the operation AND the checkbox is unchecked, the output mode is forced to Multi-file with an explanatory info-label.
- Checkbox state persists across GUI sessions.
- Stdout output for directory targets is also suppressed when the flag is active (consistent suppression).
- No regressions in existing output mode tests.

---

## 3. Specification, Documentation, and Changelog Updates (Priority: Required — Execute Last)

### 3.1. Specification Updates

The following sections of `shruggie-indexer-spec.md` must be updated to reflect the changes implemented in Sections 1–2. All updates must use the amendment callout convention: `> **Updated 2026-03-01:**`.

| Spec section | Triggering section | Nature of update |
|--------------|--------------------|------------------|
| §6.10 — Collision detection | Section 1 | Rewrite collision behavior from skip-and-warn to delete-and-warn (de-duplication). Document the new `None` return value contract. Update log message wording. Document sidecar cleanup. |
| §6.10 — Public interface | Section 1 | Update `rename_item()` return type to `Path \| None`. Update docstring to document de-duplication behavior. |
| §6.9 — Output routing | Section 2 | Document the `write_directory_meta` config field and its effect on `write_output()` and `_write_inplace_tree()`. |
| §7.1 — Configuration architecture | Section 2 | Add `write_directory_meta` to the `IndexerConfig` dataclass listing. |
| §7.1 — Validation rules | Section 2 | Add the MetaMergeDelete + `write_directory_meta=False` constraint (forces Multi-file). |
| §7.2 — Default configuration | Section 2 | Add `write_directory_meta: True` to the compiled defaults. |
| §8.3 — Output flags | Section 2 | Document the new `--dir-meta/--no-dir-meta` CLI flag pair. |
| §8.9 — Output scenarios | Section 2 | Add a note that all directory output scenarios are affected by `--no-dir-meta`. |
| §10.3 — Output controls | Section 2 | Document the new "Write directory summary files" checkbox, its position, tooltip, constraint interactions, and session persistence. Update the constraint matrix with the MetaMergeDelete + suppress interaction. |

### 3.2. Documentation Site Updates

| File | Nature of update |
|------|------------------|
| `docs/user-guide/cli.md` | Document the `--dir-meta/--no-dir-meta` flag in the CLI reference. |
| `docs/user-guide/gui.md` | Add the new checkbox to the Output Section description. Update the output mode constraints tip. |
| `docs/user-guide/python-api.md` | Document `write_directory_meta` in the `IndexerConfig` field table. |

### 3.3. Changelog Updates

Add entries under a new `### Added` and `### Changed` section for the current date:

**Added:**

- **Core: Native de-duplication during rename** — When Rename is active and multiple files share an identical content hash, the first file is renamed to its `storage_name`; all subsequent duplicates are deleted from disk along with their in-place sidecar files. `rename_item()` returns `None` for deduplicated files. Each deletion produces a `WARNING`-level log: `Duplicate REMOVED: {original_name} (identical to {storage_name})`.
- **CLI: `--dir-meta/--no-dir-meta` flag** — Controls whether directory-level metadata output files (`_directorymeta2.json`) are written. Defaults to enabled. When disabled, per-file `_meta2.json` sidecars are unaffected. When disabled with Meta Merge Delete, output mode is forced to Multi-file to preserve the safety invariant.
- **GUI: "Write directory summary files" checkbox** — New checkbox in the Output card on the Operations page. When unchecked, directory-level `_directorymeta2.json` files are suppressed. State persists across sessions.

**Changed:**

- **Core: Rename collision behavior** — Collisions during rename now delete the duplicate file instead of leaving it on disk. The log message changes from `Rename SKIPPED (collision)` to `Duplicate REMOVED`. The `rename_item()` return type is updated to `Path | None`.

### 3.4. Update Principles

1. Preserve the spec's existing style, cross-referencing notation (§X.Y), and formatting.
2. Use `> **Updated 2026-03-01:**` amendment callouts for all changes.
3. Verify no §X.Y cross-references are broken after edits.
4. Regenerate the `.html` and `.pdf` spec renderings from the updated `.md` source.

### 3.5. Spec Header Update

- **Date:** Change to `2026-03-01`.
- **Status:** Remains `AMENDED`.

### 3.6. Acceptance Criteria

- Every behavioral change from Sections 1–2 is reflected in the spec.
- No spec section describes behavior that contradicts the implemented code.
- All cross-references remain valid.
- The changelog accurately summarizes both features and the behavioral change.
- The documentation site pages are consistent with the spec and the implementation.
