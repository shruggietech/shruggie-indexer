# shruggie-indexer — Pending Updates (2026-02-27, Batch 3)

- **Project:** `shruggie-indexer`
- **Repository:** [shruggietech/shruggie-indexer](https://github.com/shruggietech/shruggie-indexer)
- **Author:** William Thompson (ShruggieTech LLC)
- **Date:** 2026-02-27
- **Target Release:** Pre-v0.1.1 (GUI stabilization, continued)
- **Audience:** AI-first, Human-second
- **Predecessor:** This document follows `20260227-001-Updates.md` (Batch 1). It assumes all items from all prior update documents (`20260223-001` through `20260227-001`, plus `20260227-002-Fix-GUI-Click-Crash.md`) have been implemented and merged.

---

## Purpose

Post-Batch 1, the GUI's structural layout (collapsible cards, Settings reorganization, Advanced Configuration improvements, region boundary separators) is stable. However, hands-on testing has surfaced several functional and visual issues that must be resolved before the v0.1.1 release:

1. **Log file writing is non-functional.** Despite multiple implementation attempts, enabling "Write log files" in Settings does not produce log files on disk. This is a critical debugging infrastructure gap that blocks all future diagnostic workflows.
2. **Output panel Save/Copy button states are stale.** The Save and Copy buttons on the viewer panel do not reflect current content state during or immediately after a job — they remain greyed out on the Log tab until the user manually toggles away and back.
3. **UX feels laggy.** Mouse scrollwheel actions across all pages render sluggishly, degrading the perceived quality of the application.
4. **Visual polish gaps.** The footer/header region boundaries still lack sufficient visual distinction despite prior separator work, and certain Settings page text elements have incorrect styling.

This document defines two sprints. The first resolves the functional issues (log file writing, button state management). The second addresses visual and UX refinements (scroll performance, border clarity, Settings text styling).

### Implementation Ordering

Items in this document are ordered by priority and dependency:

1. **Section 1** (Log file writing fix) — Critical infrastructure. Must be resolved first because all subsequent testing and debugging depends on having working log files. This is a diagnostic/tracing task: the implementing agent must follow the code path step by step and identify the exact failure point with evidence, not guesswork.
2. **Section 2** (Save/Copy button state polling) — Functional fix to the output panel. Independent of Section 1 but should follow it so that log output can be used to verify the fix.
3. **Section 3** (Scroll performance investigation) — Research task. The implementing agent investigates options for improving scroll responsiveness across the GUI and presents findings. **No implementation** — findings are presented for human decision.
4. **Section 4** (Visual polish: borders, text styling, text box heights) — Cosmetic fixes to Settings page and header/footer region borders. Independent of Sections 1–3. Can be parallelized if desired.

**Sprint grouping:**

| Sprint | Sections | Focus |
|--------|----------|-------|
| Sprint 1 | Sections 1, 2 | Functional fixes (log file writing, button states) |
| Sprint 2 | Sections 3, 4 | UX research and visual polish |

---

## 1. Log File Writing Is Non-Functional (Priority: Critical)

### 1.1. Problem Statement

When "Write log files" is enabled on the Settings page and the Log Level is set to any value other than "None", local log files are still not being written to the platform-appropriate log directory. This has been observed across multiple sessions and after prior implementation attempts to fix the issue.

The expected behavior is: when "Write log files" is checked and a log level is selected, every GUI session and every operation should produce a timestamped `.log` file in the platform log directory (e.g., `%LOCALAPPDATA%\ShruggieTech\shruggie-indexer\logs\` on Windows).

This is a **must-fix** blocker. Without working log files, there is no way to diagnose runtime issues in the compiled binary, and no way to verify that other fixes are functioning correctly.

### 1.2. Required Approach

**This is a tracing task, not a guessing task.** The implementing agent MUST:

**A. Trace the initialization path.** Starting from `ShruggieTechIndexer.__init__()`:

1. `_setup_file_logging()` is called during `__init__`, *before* the Settings tab (`_settings_tab`) is constructed.
2. At that point, `hasattr(self, "_settings_tab")` is `False`, so the early-return guard that checks `settings.log_to_file_var.get()` is skipped.
3. The handler should be created unconditionally on first launch. **Verify this is actually happening.** Add temporary `print()` statements (not `logger` calls, since the logger might not be set up yet) at each branch in `_setup_file_logging()` to confirm which code path executes.

**B. Trace the Settings-driven path.** After the Settings tab is built:

1. `_restore_session()` loads persisted settings, which may call `_on_log_to_file_changed()` or `_on_log_level_changed()`.
2. These methods call `_sync_file_logging()` on the `SettingsTab` instance.
3. `_sync_file_logging()` checks `self._app._persistent_file_handler` and may detach or re-attach the handler.
4. **Trace the exact sequence of calls during session restore.** Determine whether the handler that was successfully created in step A is being inadvertently removed by the session restore process.

**C. Verify the handler is attached to the correct logger.** The file handler must be added to `logging.getLogger("shruggie_indexer")`, not the root logger. Verify that:

1. The handler is present in `logging.getLogger("shruggie_indexer").handlers` after setup completes.
2. The logger's effective level is `DEBUG` (so messages actually flow to the handler).
3. No other code path removes the handler after initial setup.

**D. Verify the file is actually created on disk.** After confirming the handler is attached:

1. Check whether the log directory exists: `get_default_log_dir()`.
2. Check whether `make_file_handler()` is called and whether `handler.baseFilename` points to a real path.
3. Check whether `handler.stream` is open and writable.
4. Manually call `logger.info("TEST MESSAGE")` after setup and check disk.

**E. Check for exception swallowing.** The `_setup_file_logging()` method wraps the handler creation in a `try` block. If `make_file_handler()` raises an exception (e.g., permission error, path issue), it may be silently caught. **Log or print any exceptions** in the `except` clause.

### 1.3. Likely Failure Modes (Investigate in Order)

| # | Hypothesis | How to confirm |
|---|-----------|----------------|
| 1 | Session restore calls `_sync_file_logging()` which detaches the handler created at startup because the persisted `log_to_file_var` value is `False`. | Print the value of `log_to_file_var` immediately after session restore. If `False`, the handler is being removed. Fix: ensure the default persisted value is `True`, or re-create the handler after session restore if the checkbox is checked. |
| 2 | `_setup_file_logging()` is called but the `try` block catches an exception silently. | Add `print(f"File logging error: {e}")` to the `except` clause. |
| 3 | The handler is created and attached, but the logger's level is not set to `DEBUG`, so no messages flow. | Print `logging.getLogger("shruggie_indexer").getEffectiveLevel()` after setup. |
| 4 | `_sync_file_logging()` has a race condition: it checks `self._app._persistent_file_handler is None` but the handler was created on a different attribute path. | Verify that `self._app` correctly references the `ShruggieTechIndexer` instance and that the attribute name is consistent. |

### 1.4. Affected Files

| File | Nature of change |
|------|------------------|
| `src/shruggie_indexer/gui/app.py` | Fix to `_setup_file_logging()`, `_sync_file_logging()`, and/or session restore logic. |
| `src/shruggie_indexer/log_file.py` | Possibly — only if the issue is in `make_file_handler()` or `get_default_log_dir()`. |

### 1.5. Acceptance Criteria

- With "Write log files" checked and Log Level set to "Debug", launching the GUI and running any operation produces a `.log` file in the platform log directory.
- The log file contains timestamped entries including the startup banner (`Shruggie Indexer GUI vX.Y.Z started`) and all debug-level messages from the operation.
- Toggling "Write log files" off mid-session stops writing to the log file. Toggling it back on starts a new log file.
- The fix is based on evidence gathered from the tracing steps above — not on speculative code changes. The commit message must describe the root cause that was identified.

---

## 2. Output Panel Save/Copy Button State Staleness (Priority: High)

### 2.1. Problem Statement

The Save and Copy buttons on the output panel viewer toolbar do not reliably reflect the current content state. The observed failure sequence is:

1. Launch the application from a fresh state.
2. Switch to the "Log" tab on the output panel.
3. Start a job. The job runs and log content streams into the Log view.
4. The job finishes. The Save and Copy buttons remain greyed out (disabled).
5. Switch to the "Output" tab (regardless of whether it has content).
6. Switch back to the "Log" tab.
7. Save and Copy are now correctly enabled and functional.

The root cause is that button state is only updated in response to discrete events (`set_json()`, `_show_json()`, `_show_log()`, `clear()`), but not during active log streaming. The `append_logs()` method does call `_update_button_state()`, but the buttons may have been set to disabled by an earlier event (e.g., the auto-clear at job start) and the `_update_button_state()` call during streaming may not be reaching the buttons due to the high-frequency polling pattern.

### 2.2. Required Changes

**A. Add a periodic button state refresh.** Introduce a polling mechanism that calls `_update_button_state()` at a regular interval (~1 second) whenever the output panel is visible. This ensures that button states converge to the correct value regardless of what event sequence led to the current state.

Implementation approach:

1. Add a method `_poll_button_state(self)` to `OutputPanel` that calls `_update_button_state()` and then schedules itself again via `self.after(1000, self._poll_button_state)`.
2. Start the polling loop in `_build_widgets()` (or when the panel first becomes visible).
3. The polling should run continuously (not just during jobs) because the user may clear or switch tabs at any time.

**B. Verify that `_update_button_state()` correctly evaluates content for both views.** The current implementation is:

```python
def _update_button_state(self) -> None:
    has_content = bool(self._json_text) if self._showing_json else bool(self._log_lines)
    state = "normal" if has_content else "disabled"
    self.copy_btn.configure(state=state)
    self.save_btn.configure(state=state)
```

This logic is correct in isolation, but it may be overridden by `set_json()`, which unconditionally sets button state based on JSON content even when the user is viewing the Log tab. Review the interaction between `set_json()` and `_update_button_state()` and ensure that the button state always reflects the *active view's* content, not the most recently set JSON content.

**C. Ensure `set_json()` respects the active view.** Currently, `set_json()` sets button state based on whether `text` (the JSON content) is truthy:

```python
state = "normal" if text else "disabled"
self.copy_btn.configure(state=state)
self.save_btn.configure(state=state)
```

This is incorrect when the user is viewing the Log tab: the buttons should reflect log content, not JSON content. Fix `set_json()` to call `_update_button_state()` instead of setting button state directly, so the active-view logic is always respected.

### 2.3. Affected Files

| File | Nature of change |
|------|------------------|
| `src/shruggie_indexer/gui/app.py` | `OutputPanel`: add `_poll_button_state()`, fix `set_json()` to delegate to `_update_button_state()`. |

### 2.4. Acceptance Criteria

- Starting a job with the Log tab active → buttons enable as soon as log content appears (within ~1 second), without requiring a tab switch.
- Clearing the panel → buttons disable within ~1 second.
- Switching between Output and Log tabs → buttons immediately reflect the content state of the newly active tab.
- Mid-job: Save and Copy are available on the Log tab while the job is still running, allowing users to grab partial log content.
- The periodic polling does not cause visible performance degradation (1-second interval is sufficient).

---

## 3. Scroll Performance Investigation (Priority: Medium — Research Only)

### 3.1. Problem Statement

The overall UX "feel" of the GUI application is noticeably laggy, particularly during mouse scrollwheel interactions. Scrolling through the Operations page configuration area, Settings page content, and the output panel textbox all exhibit sluggish response to scrollwheel input. This degrades the perceived quality of the application.

### 3.2. Required Investigation

This is a **research task only**. The implementing agent must investigate the available options and present findings for human decision. **Do not implement any changes.**

**A. Identify the scroll mechanism.** Determine how CustomTkinter (`customtkinter`) handles scrollwheel events on scrollable frames and textboxes. Specifically:

1. What is the default scroll increment (pixels or lines per scroll tick)?
2. Is the scroll speed configurable via widget options or tkinter configuration?
3. Does the underlying tkinter `Canvas` (used by `CTkScrollableFrame`) have a `yscrollincrement` or similar property that can be tuned?

**B. Research known solutions.** Search for:

1. CustomTkinter GitHub issues related to scroll speed or lag.
2. Standard tkinter techniques for improving scroll performance (e.g., `yscrollincrement`, binding `<MouseWheel>` with custom delta multipliers).
3. Whether `CTkTextbox` and `CTkScrollableFrame` require different approaches.

**C. Evaluate options.** For each viable approach, document:

1. What it changes (scroll speed, smoothness, or both).
2. The implementation complexity (lines of code, number of files affected).
3. Whether it requires additional dependencies (and if so, which ones).
4. Any platform-specific considerations (Windows vs. macOS vs. Linux scroll event differences).

**D. Present a decision matrix.** Produce a concise table of options with trade-offs. The human will select the approach.

### 3.3. Affected Files

No files are modified in this section. Output is a findings report delivered in the coding session's commit message or as a comment in the session.

### 3.4. Acceptance Criteria

- A clear explanation of *why* the scrolling feels laggy (root cause in CustomTkinter or tkinter).
- At least two concrete options for improving scroll responsiveness.
- Each option includes: description, implementation effort estimate, dependency impact, and platform considerations.
- **No code changes are made.** This is research only.

---

## 4. Visual Polish: Region Borders, Text Styling, and Text Box Heights (Priority: Medium)

### 4.1. Purpose

Several visual details remain unfinished from the Batch 1 layout work. These are cosmetic refinements that improve the professional appearance of the application.

### 4.2. Required Changes

**A. Header region bottom borders.** All header regions across the entire GUI application (page titles on Operations, Settings, and About pages) need a 1–2px bottom border to visually separate them from the scrollable content below. The border style should match the existing sub-section card border color (the same `gray50` or equivalent used for the `_LabeledGroup` card outlines) but without rounded corners — a simple straight line.

This addresses the same visual issue shown in Screenshot 3 (the red arrow annotation), but applied to *all* header regions, not just the footer. The footer separator was partially addressed in Batch 1, but the same treatment must be applied consistently to all anchored header regions as well.

Specifically, verify and apply to:

| Region | Location | Border position |
|--------|----------|----------------|
| Operations page title | Top of main content area | Bottom edge |
| Settings page title | Top of main content area | Bottom edge |
| About page title | Top of main content area | Bottom edge |
| Output panel top edge | Footer/viewer boundary on Operations page | Top edge (verify Batch 1 separator is present and visible) |

The border must be a thin (1–2px) solid line using the same color as the card borders, rendered as a `CTkFrame` with a fixed height of 1–2px or via the `border_width` property on the container frame. **Do not use rounded corners** on these separator lines.

**B. Settings page: "Shared Settings" text styling.** In the Advanced Configuration section, the description text *"Shared Settings (not yet available)"* is currently rendered in italics. Change it to:

1. Remove the italic font style.
2. Change the font color to red (`#cc0000` or a contextually appropriate red that is readable on the dark theme background).

The purpose is to make this "not yet available" status more visually prominent as a warning/notice rather than a subtle italic note.

**C. Settings page: Expand pre-formatted text boxes.** Within the Advanced Configuration card sub-sections, some of the pre-formatted text boxes (e.g., "Excluded names", "Excluded globs") require scrolling to see their full content when only one or two additional lines are out of view. This is a poor UX — the user should be able to see all content without scrolling when the content is close to fitting.

For each text box in the Advanced Configuration sub-sections:

1. Calculate the number of lines in the default content.
2. Set the text box height to accommodate all lines plus a small padding buffer (e.g., 1 extra line height).
3. If a text box has more than ~15 lines of default content, cap its height and keep the scrollbar — this rule is only for text boxes that are *nearly* fitting but not quite.

### 4.3. Affected Files

| File | Nature of change |
|------|------------------|
| `src/shruggie_indexer/gui/app.py` | Header separator frames, "Shared Settings" text style, text box height adjustments. |

### 4.4. Acceptance Criteria

- All three page titles (Operations, Settings, About) have a visible 1–2px bottom border separating them from the scrollable content below.
- The Operations page footer/viewer boundary has a visible top-edge separator (verify Batch 1 implementation is correct; fix if not).
- The border color matches the existing card outline color, with no rounded corners.
- "Shared Settings (not yet available)" text is rendered in non-italic, red font.
- All Advanced Configuration text boxes that were previously just barely requiring a scroll now display their full content without scrolling.
- No text box exceeds a reasonable maximum height (~15 lines). Text boxes with genuinely large content retain their scroll capability.

---

## 5. Specification and Documentation Update Directive (Priority: Required — Execute Last)

### 5.1. Purpose

After all work items in Sections 1–4 have been completed, the project technical specification (`shruggie-indexer-spec.md`) and the documentation site must be updated to reflect the changes that were implemented. This is the final step in the batch.

### 5.2. Required Spec Updates

| Section affected | Update trigger | Nature of update |
|-----------------|---------------|------------------|
| §10.6 — Output Display and Export | Section 2 (button state polling) | Document the periodic button state refresh mechanism and the corrected `set_json()` behavior. Note that Save/Copy buttons reflect the active view's content state at all times. |
| §10.9 — Design Standards | Section 4A (header borders) | Document the header-region bottom border convention as a companion to the existing footer/anchored-region separator standard. |
| §10.4 — Configuration Panel | Section 4B (Shared Settings text) | Update the Advanced Configuration description to note the red non-italic styling for "not yet available" status text. |
| §10.4 — Configuration Panel | Section 4C (text box heights) | Document the auto-sizing behavior for Advanced Configuration text boxes. |
| §11.1 — Logging Architecture | Section 1 (log file fix) | If the fix changes any documented logging behavior or architecture, update accordingly. At minimum, add a note confirming that file logging is verified functional as of this batch. |

If Section 3 (scroll performance) results in a decision that leads to implementation in a future batch, no spec update is needed in this batch — the research findings will inform the next update document.

### 5.3. Update Principles

When updating the spec:

1. **Preserve the document's existing style and conventions.** Use the same cross-referencing notation (§X.Y), deviation codes (DEV-XX), amendment callout format (`> **Updated 2026-02-27:**`), and formatting patterns already established in the spec.
2. **Do not remove historical context.** Deviation notes and comparison-to-original sections should be preserved.
3. **Use amendment callouts** for all changes: `> **Updated 2026-02-27:**` followed by the change description.
4. **Verify cross-references** after all edits. Ensure no `§X.Y` references are broken.

### 5.4. Documentation Site Updates

After updating the spec, audit `docs/user-guide/gui.md` for any content that contradicts the changes made in this batch. Apply targeted corrections. Run `mkdocs build --strict` to confirm zero warnings.

### 5.5. Affected Files

| File | Nature of change |
|------|------------------|
| `shruggie-indexer-spec.md` | Amendments per §5.2 table. |
| `docs/user-guide/gui.md` | Corrections per §5.4 audit. |
| `CHANGELOG.md` | Add entries for Batch 3 changes. |
| `docs/changelog.md` | Sync from `CHANGELOG.md`. |

### 5.6. Acceptance Criteria

- All spec sections listed in §5.2 have been updated with `> **Updated 2026-02-27:**` callouts.
- No cross-references (§X.Y) are broken.
- No spec section describes behavior that contradicts the implemented code.
- `docs/user-guide/gui.md` accurately reflects the current application state.
- `mkdocs build --strict` passes with zero warnings.
- `CHANGELOG.md` includes entries for all Batch 3 changes.
- `docs/changelog.md` is synced from `CHANGELOG.md`.
