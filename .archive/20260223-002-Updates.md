# shruggie-indexer -- Pending Updates (2026-02-23, Batch 2)

- **Project:** `shruggie-indexer`
- **Repository:** [shruggietech/shruggie-indexer](https://github.com/shruggietech/shruggie-indexer)
- **Author:** William Thompson (ShruggieTech LLC)
- **Date:** 2026-02-23
- **Audience:** AI-first, Human-second
- **Predecessor:** This document follows `20260223-001-Updates.md`. It assumes all items in that document have been implemented and merged.

---

## Purpose

This document defines the next batch of pending work items for the `shruggie-indexer` project, organized by subsystem. Each item is written as a self-contained prompt suitable for consumption by an AI coding agent operating within a single context window. Items include spec references, affected file paths, root cause analysis where applicable, and explicit acceptance criteria.

All file paths are relative to the repository root unless otherwise noted.

### Implementation Ordering

Items in this document have interdependencies. The following execution order must be respected to avoid rework:

1. **Section 1** (GUI design standards) -- foundational; establishes UI principles that all subsequent GUI work items must comply with. Execute first.
2. **Section 2** (Logging infrastructure) -- standalone from a code dependency perspective, but the logging fixes must land before the GUI progress/log integration work in Section 3 can be verified.
3. **Section 3** (GUI application fixes) -- items are numbered in dependency order within the section. Layout stability (item 3.1) must precede control logic (item 3.2) and output/sidecar handling (item 3.3).
4. **Section 4** (ExifTool error handling and key customization) -- standalone; no dependencies on other sections.
5. **Section 5** (Documentation site updates) -- depends on Section 3 completing GUI fixes so that the documentation page accurately describes the final UI state.
6. **Section 6** (Technical specification overhaul) -- must be executed last, after all other sections are complete. This is a multi-session effort that requires careful planning.
7. **Section 7** (Specification update directive) -- the final step. Updates the spec to reflect all changes implemented in Sections 1--6.

---

## 1. GUI Design Standards (Priority: High -- Execute First)

### 1.1. Purpose

Repeated GUI implementation cycles have demonstrated that AI coding agents consistently fail to maintain UI coherence when making changes to the `shruggie-indexer` desktop application. The root cause is the absence of a codified set of design principles and project-specific UI standards that agents can reference during implementation. Without these, each coding session treats the GUI as an isolated widget arrangement problem rather than a cohesive interface governed by consistent rules.

This section establishes two layers of GUI design governance:

1. **General usability heuristics** adopted by reference from an industry-standard source.
2. **Project-specific UI standards** tailored to `shruggie-indexer`'s CustomTkinter desktop application.

Both layers must be added to the technical specification and referenced in every future GUI-related work item.

### 1.2. General Usability Heuristics (Adopted by Reference)

The project adopts **Jakob Nielsen's 10 Usability Heuristics for User Interface Design** (Nielsen Norman Group, 1994; revised 2020) as the baseline design evaluation framework. All GUI implementation work must comply with these heuristics. The canonical reference is:

> Nielsen, J. (1994). *10 Usability Heuristics for User Interface Design.* Nielsen Norman Group.
> URL: [https://www.nngroup.com/articles/ten-usability-heuristics/](https://www.nngroup.com/articles/ten-usability-heuristics/)

The 10 heuristics, summarized for quick reference by AI agents:

| # | Heuristic | Application to shruggie-indexer |
|---|-----------|--------------------------------|
| 1 | **Visibility of system status** | Progress bars, elapsed timers, log streams, and status labels must keep the user informed at all times during indexing operations. |
| 2 | **Match between system and real world** | Use terminology familiar to the target audience (file indexing, metadata, sidecars). Avoid exposing internal implementation details (queue polling, dataclass names). |
| 3 | **User control and freedom** | Provide cancel/stop for long operations. Allow undo where feasible (dry-run mode). Never trap the user in an irreversible flow without confirmation. |
| 4 | **Consistency and standards** | Widget behavior, label terminology, color semantics, and layout patterns must be uniform across all pages (Operations, Settings, About). |
| 5 | **Error prevention** | Validate inputs before execution. Disable destructive controls when preconditions are not met. Use confirmation dialogs for destructive operations. |
| 6 | **Recognition rather than recall** | Tooltips, inline descriptions, and labeled groups must eliminate the need to consult external documentation for basic operation. Persist session state so users do not need to re-enter settings. |
| 7 | **Flexibility and efficiency of use** | Keyboard shortcuts for power users. Sensible defaults that minimize configuration for common workflows. |
| 8 | **Aesthetic and minimalist design** | Show only controls relevant to the current operation type. Hide or disable irrelevant options. Do not clutter the interface with rarely used settings. |
| 9 | **Help users recognize, diagnose, and recover from errors** | Error messages must be human-readable, identify the problem, and suggest corrective action. No raw tracebacks in the GUI. |
| 10 | **Help and documentation** | In-app help via tooltips and a link to the documentation site's GUI guide. |

### 1.3. Project-Specific UI Standards

The following standards are specific to `shruggie-indexer`'s CustomTkinter desktop application. They supplement the Nielsen heuristics with concrete, enforceable rules.

#### 1.3.1. Layout Stability

**Standard:** The interface must not visually shift, resize, or "glitch" when transitioning between states (idle, running, complete, error). All layout regions must be pre-allocated at their maximum required size during initial window construction. Transitions between states (e.g., showing a progress bar where a START button was) must occur within pre-allocated regions.

**Enforcement:** Use fixed-height frames or `grid` geometry with explicit row/column weights. Never use `pack()` with dynamically created widgets that alter the geometry of sibling widgets. If a widget is hidden during certain states, reserve its space with a placeholder or use `grid_remove()` / `grid()` (which preserves geometry) rather than `pack_forget()` / `pack()` (which does not).

#### 1.3.2. State-Driven Control Visibility

**Standard:** Controls that are irrelevant to the currently selected operation type or target type must be either visually disabled (grayed out with a brief tooltip explaining why) or hidden. The decision between disabling and hiding follows this rule:

| Situation | Behavior |
|-----------|----------|
| Control exists for this operation type but a precondition is unmet | **Disable** with explanatory tooltip |
| Control does not exist for this operation type at all | **Hide** (remove from layout, but reserve space if hiding causes layout shift) |

**Rationale:** Disabled controls communicate the existence of a feature and guide the user toward satisfying its preconditions. Hidden controls reduce clutter when a feature is categorically inapplicable.

#### 1.3.3. Control Interdependency Transparency

**Standard:** When one control's state depends on another control's value, the dependency must be immediately visible and understandable. Specifically:

1. Changing a parent control must instantly update all dependent child controls (enable, disable, show, hide, change default value).
2. The UI must never enter a state where an enabled control has no effect due to an invisible dependency.
3. If a control is auto-set by a parent (e.g., "Recursive" toggling ON when "Type" changes to "Directory"), the user must be able to see the change happen and must be able to override it unless the override is logically invalid.

**Enforcement:** Implement a centralized state reconciliation function (e.g., `_reconcile_controls()`) that is called whenever any control value changes. This function evaluates the full state of all inputs and sets the enabled/disabled/visible state of all dependent controls in one pass. Do not scatter dependency logic across individual widget callbacks.

#### 1.3.4. Output Handling Clarity

**Standard:** The user must always understand where output will go before pressing START. Output destination must be communicated through explicit labeling, not implied by control combinations. The following rules apply:

1. **Default output behavior** must be displayed in the UI as descriptive text (e.g., "Output: `<filename>_meta2.json` alongside input file").
2. **Optional output override** (the Output path selector) must be clearly labeled as optional, with placeholder text explaining the default.
3. **No-output mode** (view in output panel only, decide later) must be an explicit, selectable option.

#### 1.3.5. Destructive Operation Safeguards

**Standard:** Any operation that modifies or deletes files on disk must:

1. Display the persistent destructive/non-destructive indicator (per item 2.2 in `20260223-001-Updates.md`).
2. List the specific destructive actions that will occur (e.g., "Will delete 3 sidecar files after merging").
3. Require a confirmation dialog before execution unless dry-run is active.

#### 1.3.6. Progress and Feedback Area Allocation

**Standard:** The area occupied by the START button, progress bar, STOP button, and associated status information must be a single, fixed-height region in the layout. The region's height must accommodate the tallest state (progress bar + status text + current-file label) at all times, even when displaying only the START button in idle state. This prevents layout shifts during state transitions.

#### 1.3.7. Log and Output Panel Behavior

**Standard:** The log/output panel is the user's primary feedback channel. It must:

1. Auto-scroll to the bottom when new content arrives, unless the user has manually scrolled up.
2. Resume auto-scrolling when the user scrolls back to the bottom.
3. Display timestamped entries in the format `HH:MM:SS  LEVEL  message`.
4. Accept content from both the logging system and the progress event system (status messages about currently processing files).
5. Have Save and Copy buttons enabled at all times when the panel contains content.

### 1.4. Spec Integration

**Required action:** Add a new subsection to `shruggie-indexer-spec.md` within SS10 (GUI Application) titled **SS10.9 -- GUI Design Standards**. This subsection must contain:

1. The Nielsen heuristics reference (Section 1.2 of this document).
2. The project-specific UI standards (Section 1.3 of this document), adapted to the spec's existing style and cross-referencing conventions.
3. A directive statement: "All GUI implementation work must comply with the standards defined in this subsection. AI coding agents should review SS10.9 before beginning any GUI-related task."

**Affected files:**

| File | Role |
|------|------|
| `shruggie-indexer-spec.md` SS10 | New subsection SS10.9 |

**Acceptance criteria:** SS10.9 exists in the spec, contains both the adopted heuristics reference and all project-specific standards, and uses the spec's established formatting conventions.

---

## 2. Logging Infrastructure (Priority: High)

### 2.0. General Context

The current logging system routes diagnostic messages to `sys.stderr` (CLI) or to a GUI log handler that enqueues records for display in the log stream textbox. Per the spec's Principle 3 (SS11.1), the tool does not write log files by default. This section introduces optional persistent log file support and fixes issues with the GUI's log capture pipeline.

### 2.1. Persistent Log File Support

**Problem:** There is no mechanism for users to save runtime logs to disk for later analysis. For headless CLI operations on remote systems, this makes post-mortem debugging impossible without manually redirecting stderr. For GUI users, the only log output is the in-app textbox, which is lost when the application closes.

**Required behavior:**

**A. Log file destination.**

All persistent logs are written to the platform-appropriate user application data directory:

| Platform | Directory |
|----------|-----------|
| Windows | `%LOCALAPPDATA%\ShruggieTech\shruggie-indexer\logs\` |
| macOS | `~/Library/Application Support/ShruggieTech/shruggie-indexer/logs/` |
| Linux | `~/.local/share/shruggie-indexer/logs/` |

Use `platformdirs` (already a transitive dependency via `customtkinter` or add explicitly if not) to resolve the path. The directory is created on first use.

Log files are named by date and session: `YYYY-MM-DD_HHMMSS.log`.

**B. CLI enablement.**

Add a `--log-file` flag to the CLI:

| Flag | Behavior |
|------|----------|
| `--log-file` (no argument) | Enable log file output to the default app data location |
| `--log-file <path>` | Enable log file output to the specified path |

The log file flag is also expressible in the TOML configuration file:

```toml
[logging]
file_enabled = true
# file_path = ""  # empty = use default app data location
```

**C. GUI enablement.**

Add a "Write log files" toggle in the Settings page. When enabled, every operation writes a log file to the app data location. The toggle state is persisted in the session file.

**D. Log file format.**

The log file uses the CLI's full format including session ID:

```
2026-02-23 14:30:02  abc123  INFO      shruggie_indexer.core.hasher  Hashing file: photo.jpg
```

The log level written to the file matches the currently configured verbosity.

**Affected files:**

| File | Role |
|------|------|
| `src/shruggie_indexer/cli/main.py` | New `--log-file` argument, logging configuration |
| `src/shruggie_indexer/config/types.py` | New `logging.file_enabled` and `logging.file_path` config fields |
| `src/shruggie_indexer/config/defaults.py` | Default values for logging config |
| `src/shruggie_indexer/gui/app.py` | Settings toggle for log file, log handler setup |
| `docs/user-guide/configuration.md` | Document the new logging configuration |
| `docs/user-guide/cli-reference.md` | Document the `--log-file` flag |

**Spec reference:** `shruggie-indexer-spec.md` SS11.1 -- Logging Architecture (Principle 3 must be updated to note the new optional file logging).

**Acceptance criteria:**

- CLI `--log-file` writes a log file to the app data directory.
- CLI `--log-file /custom/path.log` writes to the specified path.
- TOML `logging.file_enabled = true` enables file logging.
- GUI Settings toggle enables/disables log file writing.
- Log files are created in the correct platform-specific directory.
- Log file format matches the CLI stderr format including session ID.

### 2.2. GUI Log Capture Pipeline -- Missing Messages

**Problem:** The GUI log display shows at most one or two log messages per operation, even with Debug verbosity enabled in Settings. The majority of diagnostic output is not reaching the log textbox.

**Suspected root cause:** The "processing this file..." status messages displayed below the progress bar (the `current_label` widget in `_ProgressPanel`) are generated by the `ProgressEvent` callback system. These events carry a `message` field and are consumed by `_ProgressPanel.update_progress()`, which updates the `current_label` text. However, these messages appear to be consumed by the progress panel's current-file display without also being forwarded to the log stream textbox. The messages are "dying" in the progress panel -- overwriting each other in the `current_label` and never reaching the `OutputPanel.append_log()` pathway.

Additionally, the GUI logging handler (the custom `logging.Handler` subclass that enqueues records into the shared queue) may not be attached at the correct scope or level, causing standard library `logging` messages from the core engine to be silently dropped.

**Diagnosis required:** Before implementing fixes, the implementing agent must determine:

1. Whether the core library emits adequate `logging.debug()` / `logging.info()` messages during file processing (check `core/hasher.py`, `core/exif.py`, `core/sidecar.py`, `core/directory.py` for log calls).
2. Whether the GUI's custom log handler is correctly attached to the root logger (or the `shruggie_indexer` logger) and is receiving records.
3. Whether `ProgressEvent.message` values are being forwarded to `OutputPanel.append_log()` in addition to being displayed in `_ProgressPanel.current_label`.
4. Whether the queue-based polling mechanism (`_POLL_INTERVAL_MS = 50`) is draining both log records and progress events, or only one type.

**Required behavior:**

1. **All progress event messages** (the per-file "processing..." messages) must be written to the log stream textbox in addition to updating the progress panel's `current_label`. The log textbox entries must include timestamps in `HH:MM:SS` format.
2. **All standard `logging` messages** from the core engine must appear in the log stream textbox at the configured verbosity level.
3. **The log stream textbox must auto-scroll** to the bottom when new content arrives, unless the user has manually scrolled upward. When the user scrolls back to the bottom, auto-scroll resumes. (Verify this behavior exists; implement if missing.)
4. **Log entries in the textbox** must use the format: `HH:MM:SS  LEVEL  message` with level-based color coding per SS11.5 (GUI destinations): ERROR/CRITICAL in red, WARNING in yellow/amber, INFO in default text color, DEBUG in muted gray.

**Affected files:**

| File | Role |
|------|------|
| `src/shruggie_indexer/gui/app.py` | Log handler attachment, progress-to-log forwarding, auto-scroll behavior |
| `src/shruggie_indexer/core/` (multiple) | Verify log message density at DEBUG level |

**Spec reference:** `shruggie-indexer-spec.md` SS10.5 -- Indexing Execution and Progress (log stream), SS10.6 -- Output Display and Export (log view), SS11.5 -- Log Destinations (GUI destinations).

**Acceptance criteria:**

- Running a multi-file directory index at Debug verbosity produces a detailed, per-item processing log in the GUI log display, including per-file processing messages, hash computation events, exiftool invocations, and sidecar discovery.
- The log stream textbox auto-scrolls during operation and pauses auto-scroll when the user scrolls up.
- Progress event messages appear in the log stream with timestamps.
- Log entries are color-coded by severity level.

### 2.3. Log Panel -- Save and Copy Buttons Disabled

**Problem:** The Save and Copy buttons in the log view of the output/log panel are disabled (grayed out) and cannot be clicked, even when the log panel contains content.

**Required behavior:** Save and Copy buttons must be enabled whenever the active view (Output or Log) contains content. The buttons should be disabled only when the active view is empty.

**Affected files:**

| File | Role |
|------|------|
| `src/shruggie_indexer/gui/app.py` | `OutputPanel` button state management |

**Spec reference:** `shruggie-indexer-spec.md` SS10.6 -- Output Display and Export.

**Acceptance criteria:** After running an operation that produces log output, the Save and Copy buttons are clickable in the log view. Clicking Copy copies the full log content to the clipboard. Clicking Save opens a save-as dialog.

---

## 3. GUI Application Fixes (Priority: High)

### 3.0. General Context

The GUI is implemented in `src/shruggie_indexer/gui/app.py` as a single-file CustomTkinter application. Spec guidance is in `shruggie-indexer-spec.md` SS10.1--SS10.8. The GUI uses a three-tab sidebar (Operations, Settings, About) with a consolidated Operations page containing an inline operation type selector.

**Critical instruction:** Before implementing any item in this section, read and internalize the GUI Design Standards defined in Section 1 of this document. Every change must comply with those standards. Specifically:

- **Layout stability** (Standard 1.3.1): No layout shifts during state transitions.
- **State-driven control visibility** (Standard 1.3.2): Disable or hide controls based on context.
- **Control interdependency transparency** (Standard 1.3.3): Centralized state reconciliation.
- **Output handling clarity** (Standard 1.3.4): User always knows where output goes.

### 3.1. Layout Glitch on START -- Progress Bar Sizing

**Problem:** After pressing START, the entire UI visually glitches: the progress bar display area resizes (expands), causing surrounding widgets to shift. When the operation completes, the layout reverts to its original dimensions. This violates Standard 1.3.1 (Layout Stability) and Heuristic 1 (Visibility of System Status -- the layout shift is jarring and distracts from the progress feedback).

**Root cause analysis:** The progress panel (`_ProgressPanel`) is likely constructed with a compact initial size (or is hidden/collapsed in the idle state), and its child widgets (progress bar, status label, elapsed timer, current-file label, log textbox) expand the frame beyond its initial geometry when the operation starts. When the operation completes and the progress panel is reset, the frame shrinks back.

**Required behavior:** Per Standard 1.3.6 (Progress and Feedback Area Allocation):

1. The region occupied by the START button, progress bar, STOP button, and all associated status information must be a single, fixed-height frame.
2. This frame must be allocated at its **maximum required height** during initial window construction -- that is, the height needed to display the full progress state (progress bar + status text + current-file label).
3. In idle state, the START button is centered within this pre-allocated region. The unused space is empty but reserved.
4. Transitioning to running state replaces the START button content with the progress display **within the same fixed-height region**, with no geometry change.
5. If the current allocation is insufficient to contain the progress display without clipping, the initial allocation must be increased -- but this increase happens at construction time, not at runtime.

**Implementation guidance:** Use a `CTkFrame` with a fixed `height` parameter and `pack_propagate(False)` (or equivalent `grid` row weight configuration) so that child widgets do not alter the frame's dimensions. Place the START button and the progress widgets inside this frame, toggling visibility between idle and running states.

**Affected files:**

| File | Role |
|------|------|
| `src/shruggie_indexer/gui/app.py` | `_ProgressPanel` construction, idle/running state transitions |

**Spec reference:** `shruggie-indexer-spec.md` SS10.5 -- Indexing Execution and Progress.

**Acceptance criteria:** Pressing START and completing an operation causes zero visible layout shifts anywhere in the window. The progress area occupies the same screen space in idle, running, and completed states.

### 3.2. Control Interdependencies -- Operation Type, Output, Recursive, and Sidecar Logic

**Problem:** The relationships between operation type, target type, output destination, recursive toggle, and in-place sidecar writes are not correctly enforced in the UI. Users encounter states where controls are inappropriately enabled, disabled, or unclear in their effect. AI coding agents implementing prior fixes have repeatedly introduced regressions because the control dependency logic is scattered across multiple widget callbacks rather than centralized.

This item defines the complete, canonical control dependency matrix. The implementing agent must replace all existing scattered dependency logic with a single centralized reconciliation function that enforces these rules.

#### 3.2.1. Recursive Toggle Behavior

| Target Type | Recursive default | Recursive enabled | Notes |
|-------------|-------------------|-------------------|-------|
| `"directory"` | ON | Yes (user can toggle) | Directories are typically processed recursively |
| `"auto"` (target resolves to directory) | OFF | Yes (user can toggle) | Do not auto-enable; let user decide |
| `"auto"` (target resolves to file) | OFF | No (grayed out) | Tooltip: "Recursive is not applicable to single-file targets" |
| `"auto"` (target not yet selected) | OFF | Yes (user can toggle) | Allow pre-configuration before target selection |
| `"file"` | OFF | No (grayed out) | Tooltip: "Recursive is not applicable to single-file targets" |

When the target type changes, the recursive toggle state must update immediately per the table above.

#### 3.2.2. Output Destination Logic

The Output section in the Operations page allows the user to optionally specify where output is written. This section is **purely optional** -- it exists to override the default output behavior, not to define it.

**Default output behavior (no Output override specified):**

| Target type | Operation | Default output |
|-------------|-----------|----------------|
| Single file | Any | `<inputfile>.<ext>_meta2.json` alongside the input file |
| Directory (non-recursive) | Index | `<inputdirectory>_directorymeta2.json` alongside the input directory |
| Directory (recursive) | Index | `<inputdirectory>_directorymeta2.json` + individual per-file `_meta2.json` sidecars within the directory tree |
| Directory | Meta Merge / Meta Merge Delete | Same as Index, with merged sidecar data |

**The UI must communicate the default behavior.** When no output path is specified, display descriptive placeholder text in the Output path field that explains the default. For example:

- Single file: `Default: <filename>_meta2.json alongside input`
- Directory: `Default: <dirname>_directorymeta2.json + per-file sidecars`

**User output choices must include:**

| Choice | Behavior | UI presentation |
|--------|----------|-----------------|
| **Use defaults** | Write output using built-in sidecar naming conventions | Output path field is empty; placeholder text describes the default |
| **Custom output path** | Write output to a user-specified file or directory | User enters or browses to a path |
| **View only (no write)** | Display output in the output panel; do not write to disk | Explicit toggle or radio option (e.g., "Output mode: View only / Save to file / Both") |

**Critical clarification:** The Output section is NOT a prerequisite for running an operation. If the user leaves it blank, the default sidecar behavior applies. This must be clearly communicated via placeholder text and/or a brief inline description.

#### 3.2.3. In-Place Sidecar Writes

"In-Place Sidecar Outputs" means writing `_meta2.json` files alongside the input files within the input directory tree. This is the default behavior for recursive directory operations and is distinct from writing a single aggregate output file to a custom location.

| Operation type | In-Place Sidecar available | Notes |
|----------------|---------------------------|-------|
| Index | Yes (default for directories) | Per-file sidecars written within the directory tree |
| Meta Merge | Yes | Merged metadata written back to per-file sidecars |
| Meta Merge Delete | Yes (required) | In-place sidecar writes are mandatory because the original sidecar files are deleted after merging |
| Rename | Follows Index behavior | Rename is a post-processing modifier, not a standalone operation |

When "Meta Merge Delete" is selected, in-place sidecar output must be forced ON and the control must be disabled with a tooltip: "In-place output is required for Meta Merge Delete because original sidecar files are deleted after merging."

#### 3.2.4. Centralized State Reconciliation

**Required implementation:** Create a method `_reconcile_controls(self)` on the Operations page class that:

1. Reads the current values of all controls (operation type, target type, target path, recursive, output mode, dry-run).
2. Evaluates the dependency matrix defined in Sections 3.2.1--3.2.3.
3. Sets the enabled/disabled/visible state and default value of every dependent control.
4. Updates the destructive operation indicator.
5. Updates the output destination placeholder text.

This method must be called:
- On initial page construction.
- Whenever any input control value changes (via `trace` callbacks on control variables).
- After loading session state.

All existing per-widget dependency logic must be removed and replaced with calls to `_reconcile_controls()`.

**Affected files:**

| File | Role |
|------|------|
| `src/shruggie_indexer/gui/app.py` | Operations page control logic, `_reconcile_controls()` |

**Spec reference:** `shruggie-indexer-spec.md` SS10.3 -- Target Selection and Input, SS10.5 -- Indexing Execution and Progress.

**Acceptance criteria:**

- Changing the operation type immediately and correctly updates all dependent controls per the dependency matrix.
- Changing the target type immediately and correctly updates the recursive toggle and output placeholder text.
- "Meta Merge Delete" forces in-place sidecar output ON and disables the toggle.
- The output section clearly communicates default behavior when no custom path is specified.
- Users can select "View only" mode to run an operation without writing any output to disk.
- No UI state exists where an enabled control has no effect due to a hidden dependency.
- The `_reconcile_controls()` method is the single source of truth for all control state logic.

### 3.3. ExifTool Error Handling -- Valid Metadata Discarded on Non-Zero Exit

**Problem:** Processing a `.7z` archive file via the GUI produces the following warning and yields an empty metadata array:

```
WARNING shruggie_indexer.core.exif: pyexiftool error for
A:\Code\shruggie-indexer-testing\data\not-empty\FeedsExport.7z:
execute returned a non-zero exit status: 1 -- resetting
```

The shruggie-indexer output for this file contains `"metadata": []` -- no exiftool data whatsoever. However, **exiftool does produce valid, useful output for this file.** The original PowerShell `MakeIndex` function successfully captured the following metadata from exiftool for the same `.7z` file:

```json
{
    "SourceFile": "FeedsExport.7z",
    "ExifTool:Now": "2026:02:23 19:35:11-05:00",
    "ExifTool:Error": "Unknown file type",
    "ExifTool:ProcessingTime": "0.366 s",
    "System:FileSize": "728 MB",
    "System:FileModifyDate": "2026:02:09 16:14:22-05:00",
    "System:FileAccessDate": "2026:02:23 19:35:11-05:00",
    "System:FileCreateDate": "2026:02:23 19:28:39-05:00",
    "System:FileAttributes": "Regular; (none); Archive"
}
```

ExifTool reports `"ExifTool:Error": "Unknown file type"` as an **informational field in its JSON output** -- this is not a process failure. ExifTool still returns system-level metadata (file size, timestamps, attributes) for the file. The `ExifTool:Error` field simply indicates that exiftool could not parse the file's embedded/format-specific metadata, not that processing failed entirely.

The original MakeIndex captured this data correctly because it used direct subprocess invocation, captured stdout regardless of exit code, and stored whatever valid JSON came back.

### 3.3.1. Root Cause Analysis

The failure chain is:

1. ExifTool processes the `.7z` file and **produces valid JSON output** containing system-level metadata plus an `ExifTool:Error` informational field.
2. ExifTool returns **exit code 1** because it encountered a file type it cannot parse for embedded metadata. This is exiftool's standard behavior -- exit code 1 signals warnings/minor errors, not fatal failure. The JSON output is still valid and complete.
3. The `pyexiftool` library's `ExifToolHelper` class has `check_execute=True` by default. This causes it to **raise `ExifToolExecuteError`** on any non-zero exit status, even when the JSON output is valid and contains usable data.
4. shruggie-indexer's error handler in `core/exif.py` catches `ExifToolExecuteError`, logs a WARNING, **resets the persistent exiftool process** (which is unnecessary -- the process is healthy), and **returns `None`** -- discarding the valid metadata entirely.
5. The file ends up with `"metadata": []` in the output, a **behavioral regression** compared to the original MakeIndex.

The pyexiftool documentation itself acknowledges this exact scenario in the `check_execute` property documentation:

> "Example: dump all exif in a directory with files which don't all have the same tags, exiftool returns exit code 1 for unknown files, but results are valid for other files with those tags"

### 3.3.2. Required Changes

**A. Handle `ExifToolExecuteError` with metadata recovery.**

When `ExifToolExecuteError` is raised, the handler must **not** immediately discard the result. Instead:

1. Check whether the exception object contains valid JSON output (pyexiftool stores the last stdout in `self._last_stdout` on the `ExifTool` base class, and `ExifToolExecuteError` receives the stdout/stderr as constructor arguments).
2. If valid JSON is present and contains metadata beyond just `SourceFile`, **use it** -- apply key filtering and return the result as normal.
3. If no valid JSON is present (true process failure), log at WARNING and return `None` as currently done.

The implementing agent must review the `ExifToolExecuteError` exception class to determine the correct attribute for accessing the stdout that was produced before the error was raised. The pyexiftool source shows this is passed as the second positional argument to the exception constructor and stored on the exception object.

**B. Evaluate `check_execute` configuration.**

Consider instantiating `ExifToolHelper` with `check_execute=False` and instead performing exit-code evaluation manually after each call. This gives shruggie-indexer full control over which exit codes are treated as fatal vs. recoverable. Alternatively, use the lower-level `exiftool.ExifTool` class with `execute_json()` directly, which does not raise on non-zero exit by default.

If `check_execute=False` is used, the implementing agent must add explicit checking for truly fatal conditions (exiftool process death, malformed JSON output, etc.) that `check_execute=True` would have caught.

**C. Do not reset the persistent process unnecessarily.**

A non-zero exit code from exiftool for a single file does **not** indicate that the persistent `-stay_open` process is unhealthy. The current "resetting" behavior (destroying and restarting the exiftool process) is both unnecessary and harmful to performance. The persistent process should only be reset when there is evidence of actual process failure (e.g., broken pipe, timeout, process death).

**D. Log level adjustment.**

When exiftool returns valid JSON containing an `ExifTool:Error` field with value `"Unknown file type"`:
- Log at `INFO` level (not WARNING): `"ExifTool: unknown file type for <filename>; system metadata preserved"`
- The `ExifTool:Error` key itself should be handled by the key filtering system -- it will be excluded if `Error` is added to `EXIFTOOL_EXCLUDED_KEYS`, or preserved if the user/spec decides it carries informational value.

### 3.3.3. Reference: How the Original Handled This

The original PowerShell `MakeIndex` used direct subprocess invocation (`exiftool -@ "$ArgsFile" 2> $null`) and piped stdout through `jq`. This approach inherently tolerates non-zero exit codes because PowerShell subprocess invocation captures stdout regardless of exit code, and `jq` processes whatever JSON it receives. The `2> $null` redirects stderr to null, silencing exiftool's stderr warnings. The result: valid JSON output was always captured and stored, even for files where exiftool reported `"Unknown file type"`.

**Affected files:**

| File | Role |
|------|------|
| `src/shruggie_indexer/core/exif.py` | `ExifToolExecuteError` handling, `check_execute` configuration, process reset logic |
| `tests/unit/test_exif.py` | New test cases for non-zero exit with valid output |

**Spec reference:** `shruggie-indexer-spec.md` SS6.6 -- EXIF and Embedded Metadata Extraction, SS17.5 -- ExifTool Invocation Strategy.

**Acceptance criteria:**

- Processing a `.7z` file captures system-level metadata from exiftool (file size, timestamps, attributes) in the output `metadata` array, matching the original MakeIndex behavior.
- The `ExifTool:Error: "Unknown file type"` informational field is handled appropriately (either filtered by key exclusion or preserved, per spec guidance).
- No WARNING-level log message is produced for files where exiftool returns valid JSON with an `ExifTool:Error` field.
- The persistent exiftool process is not reset when a single file returns a non-zero exit code with valid output.
- A new unit test verifies that `extract_exif()` returns filtered metadata (not `None`) when exiftool exits non-zero but produces valid JSON containing system-level keys.
- The subprocess fallback path also captures stdout on non-zero exit codes and returns valid metadata when present.

---

## 4. ExifTool Configuration -- User-Customizable Key Exclusions (Priority: Medium)

### 4.1. Problem Statement

The `EXIFTOOL_EXCLUDED_KEYS` set (defined in `src/shruggie_indexer/core/exif.py`) is currently hardcoded. Users cannot add or remove keys from this set without modifying source code. The spec acknowledges this limitation (SS6.6: "The excluded key set is not currently configurable"). This item makes it configurable.

### 4.2. Spec Reference

| Reference | Section |
|-----------|---------|
| Key filtering behavior | `shruggie-indexer-spec.md` SS6.6 -- Output parsing and key filtering |
| Configuration system | `shruggie-indexer-spec.md` SS7 -- Configuration |
| Existing collection field conventions | `docs/user-guide/configuration.md` -- Override and Merging Behavior |

### 4.3. Required Changes

**A. Add `exiftool.exclude_keys` to the configuration schema.**

Following the established convention for collection fields (see `docs/user-guide/configuration.md`, "Override and Merging Behavior"), add:

| Config key | Type | Behavior |
|------------|------|----------|
| `exiftool.exclude_keys` | list of strings | **Replace** -- the specified list becomes the complete exclusion set |
| `exiftool.exclude_keys_append` | list of strings | **Append** -- entries are added to the compiled default set |

The compiled default set remains the current `EXIFTOOL_EXCLUDED_KEYS` frozenset. Users who specify `exclude_keys` replace it entirely; users who specify `exclude_keys_append` extend it.

**B. Update `_filter_keys()` to use the configuration.**

The `_filter_keys()` function currently references the module-level constant. It must instead accept the resolved exclusion set from the `IndexerConfig` object (or receive it as a parameter).

**C. TOML configuration example:**

```toml
[exiftool]
# Append additional keys to the default exclusion list
exclude_keys_append = ["Copyright", "Artist"]

# Or replace the entire exclusion list (advanced):
# exclude_keys = ["SourceFile", "Directory", "FileName"]
```

**Affected files:**

| File | Role |
|------|------|
| `src/shruggie_indexer/core/exif.py` | `_filter_keys()` signature, exclusion set resolution |
| `src/shruggie_indexer/config/types.py` | New `exiftool.exclude_keys` / `exclude_keys_append` fields |
| `src/shruggie_indexer/config/defaults.py` | Compiled default exclusion set |
| `src/shruggie_indexer/config/loader.py` | Merge logic for new collection fields |
| `tests/unit/test_exif.py` | Test cases for configurable exclusions |
| `docs/user-guide/configuration.md` | Document the new configuration keys |

**Acceptance criteria:**

- Default behavior (no config override) is identical to current behavior.
- `exiftool.exclude_keys_append = ["Copyright"]` adds "Copyright" to the exclusion set.
- `exiftool.exclude_keys = ["SourceFile"]` replaces the entire set with only "SourceFile".
- The configuration documentation reflects the new keys.
- Unit tests cover both replace and append modes.

---

## 5. Documentation Site Updates (Priority: Medium)

### 5.1. GUI Page -- Screenshot Infrastructure

**Problem:** The GUI documentation page (`docs/user-guide/gui.md`) contains no screenshots. A desktop application guide without visual references is significantly less useful, especially for the non-technical audience this page targets.

**Required actions:**

**A. Create a screenshot storage directory:**

```
docs/assets/images/gui/
```

Add this directory to the repository. It will hold all GUI-related screenshots (PNG format, reasonable resolution).

**B. Add a "To Do" section** at the bottom of `docs/user-guide/gui.md`:

```markdown
## To Do

!!! note "Screenshots Needed"
    This page requires annotated screenshots of the GUI application to illustrate
    the interface elements described above. Screenshots should cover:

    - The Operations page in idle state
    - The Operations page during an active indexing run (progress bar, log stream)
    - The Settings page
    - The About page
    - The output panel showing JSON output and log view
    - A destructive operation confirmation dialog

    Screenshot assets will be stored in `docs/assets/images/gui/`.
```

**Affected files:**

| File | Role |
|------|------|
| `docs/user-guide/gui.md` | Add To Do section |
| `docs/assets/images/gui/` | Create directory (add `.gitkeep` placeholder) |

**Acceptance criteria:** The To Do section is present at the bottom of the GUI docs page. The image directory exists in the repository.

---

## 6. Technical Specification Overhaul (Priority: Medium -- Multi-Session Effort)

### 6.1. Purpose

The technical specification (`shruggie-indexer-spec.md`) was written during the porting phase and carries a tone that emphasizes comparison to the original PowerShell source. Now that the project is an established standalone tool with multiple completed releases, the spec must evolve its voice to match:

1. **Shift tone** from "here's how we differ from the PowerShell original" to "here's what shruggie-indexer is and how it works." The spec should read as an authoritative declaration of the application's behavior, not a porting diary.
2. **Synchronize with the documentation site.** Content drift between the spec and the MkDocs site must be identified and resolved.
3. **Preserve historical context.** Deviation notes (DEV-XX codes) and comparison-to-original sections should be retained but demoted -- moved to clearly labeled "Historical Note" or "Porting Context" callout blocks rather than dominating the narrative.

### 6.2. Risk: Context Window Overflow

The full spec is a large document. Attempting to rewrite it in a single coding session will exceed context window limits and produce incomplete or inconsistent results.

**Required approach -- phased execution:**

| Phase | Scope | Estimated sessions |
|-------|-------|--------------------|
| Phase A | Sections 1--3 (Introduction, Deviations, Repository Structure) | 1 session |
| Phase B | Sections 4--6 (Core Operations, Schema, EXIF/Metadata) | 1--2 sessions |
| Phase C | Sections 7--9 (Configuration, CLI, Python API) | 1 session |
| Phase D | Sections 10--11 (GUI, Logging) | 1 session |
| Phase E | Sections 12--18 (Dependencies, Packaging, Testing, etc.) | 1 session |
| Phase F | Cross-referencing audit + documentation site sync | 1 session |

Each phase must be a self-contained coding session that:

1. Reads the relevant spec sections.
2. Reads the corresponding documentation site pages.
3. Identifies tone, content, and structural discrepancies.
4. Rewrites the spec sections to adopt the authoritative tone.
5. Demotes PowerShell comparison content to clearly labeled callout blocks.
6. Verifies that the spec and docs site agree on behavioral descriptions.
7. Commits the changes with a descriptive commit message.

### 6.3. Tone Guidelines

**Before (porting-era tone):**
> The original uses `jq` to filter exiftool JSON output. The port eliminates `jq` entirely and replaces it with a Python dict comprehension.

**After (authoritative tone):**
> Exiftool JSON output is filtered using a dict comprehension that matches keys by base name against the configured exclusion set. Excluded keys are stripped before the metadata is attached to the IndexEntry.
>
> > **Historical note (DEV-06):** The original PowerShell implementation used `jq` for JSON filtering. The Python port replaced this with native dict operations, eliminating the external dependency.

**Guidelines for AI agents performing the rewrite:**

- Lead with what the tool *does*, not what it *replaced*.
- Use present tense and active voice for behavioral descriptions.
- Move all "Original:" / "Port:" comparison blocks into clearly delineated historical callouts.
- Do not remove DEV-XX deviation codes or comparison content -- just demote it visually.
- Preserve all spec cross-references (SS X.Y notation) and ensure they remain valid after rewriting.
- Do not change the section numbering scheme.

### 6.4. Affected Files

| File | Role |
|------|------|
| `shruggie-indexer-spec.md` | The entire document, processed in phases |
| `docs/` (multiple pages) | Comparison targets for synchronization |

### 6.5. Acceptance Criteria

- The spec reads as an authoritative technical specification for a standalone tool, not a porting guide.
- All DEV-XX deviation notes are preserved but demoted to callout blocks.
- No behavioral contradictions exist between the spec and the documentation site.
- All cross-references (SS X.Y) remain valid.
- The spec's generated `.html` and `.pdf` renderings are regenerated from the updated `.md` source after all phases complete.

---

## 7. Specification Update Directive (Priority: Required -- Execute Last)

### 7.1. Purpose

After all work items in Sections 1--6 have been completed, the project technical specification (`shruggie-indexer-spec.md`) must be updated to reflect the changes that were implemented. This is in addition to and separate from the tone overhaul in Section 6 -- this section addresses specific technical content updates triggered by the behavioral changes in Sections 1--5.

### 7.2. Required Spec Updates

The following spec sections must be reviewed and updated based on the work completed in this document:

| Section affected | Update trigger | Nature of update |
|-----------------|---------------|------------------|
| SS10 (new SS10.9) | Section 1 (GUI design standards) | New subsection documenting adopted Nielsen heuristics and project-specific UI standards. |
| SS11.1 -- Logging Architecture | Section 2, item 2.1 | Update Principle 3 to document optional persistent log file support. Add log file format, destination, and enablement details. |
| SS11.5 -- Log Destinations | Section 2, item 2.1 | Add file destination alongside CLI and GUI destinations. |
| SS10.5 -- Indexing Execution and Progress | Section 2, item 2.2 / Section 3, item 3.1 | Document progress-to-log forwarding and fixed-height progress area. |
| SS10.6 -- Output Display and Export | Section 2, item 2.3 | Document Save/Copy button enablement rules. |
| SS10.3 -- Target Selection and Input | Section 3, item 3.2 | Document the complete control dependency matrix, output handling clarity rules, and centralized state reconciliation. |
| SS6.6 -- EXIF and Embedded Metadata Extraction | Section 3, item 3.3 / Section 4 | Document `ExifToolExecuteError` recovery behavior (capturing valid metadata from non-zero exit codes), `check_execute` configuration rationale, process reset policy, and user-configurable key exclusion set. |
| SS17.5 -- ExifTool Invocation Strategy | Section 3, item 3.3 | Document the error isolation policy change: non-zero exit with valid JSON output is recoverable, not fatal. Update the batch-mode error handling description to reflect metadata recovery from `ExifToolExecuteError`. |
| SS7 -- Configuration | Section 4 | Add `exiftool.exclude_keys` and `exclude_keys_append` to the configuration schema documentation. |
| SS3.1 -- Top-Level Layout | Section 5, item 5.1 | Add `docs/assets/images/gui/` to the repository layout if not already present. |
| SS3.7 -- Documentation Site | Section 5 | Note the screenshot infrastructure and To Do section on the GUI page. |

### 7.3. Update Principles

When updating the spec:

1. **Preserve the document's existing style and conventions.** Use the same cross-referencing notation (SS X.Y), deviation codes (DEV-XX), and formatting patterns already established in the spec.
2. **Do not remove historical context.** Deviation notes and comparison-to-original sections should be preserved. New changes should be documented alongside them, not in place of them.
3. **Mark new content clearly.** If a section is substantially rewritten, add a brief note at the top of the section indicating the update date and the triggering change (e.g., "Updated 2026-02-XX: Reflects GUI design standards per Pending Updates Batch 2, Section 1.").
4. **Regenerate the HTML and PDF renderings** of the spec after all textual updates are complete, using the same VS Code plugin workflow that produced the current `.html` and `.pdf` files.

### 7.4. Acceptance Criteria

- Every behavioral change implemented in Sections 1--5 is reflected in the spec.
- No spec section describes behavior that contradicts the implemented code.
- The spec's SS3.1 repository layout is fully synchronized with the actual repository.
- The new SS10.9 (GUI Design Standards) subsection exists and contains the full standards.
- The generated `.html` and `.pdf` renderings of the spec are regenerated from the updated `.md` source.

---

## Appendix A: Control Dependency Quick-Reference Matrix

This appendix provides a single-table summary of the control dependency rules defined in Section 3.2 for quick reference by implementing agents.

| Control | Depends on | Rule |
|---------|-----------|------|
| Recursive toggle | Target Type | Enabled for `directory` and `auto` (no target selected). Disabled (grayed) for `file` and `auto` (file target selected). |
| Recursive default | Target Type | ON for `directory`. OFF for all others. |
| In-Place Sidecar | Operation Type | Available for all operations. Forced ON and disabled for Meta Merge Delete. |
| Output placeholder text | Target Type + Recursive | Dynamically describes the default output convention for the current configuration. |
| Destructive indicator | Operation Type + Dry-Run | Red for Meta Merge Delete (always) and Rename (when dry-run OFF). Green otherwise. |
| Output Mode (View/Save/Both) | None | Always available. Independent of operation type and target type. |

---

## Appendix B: Nielsen Heuristic Violation Checklist for GUI PRs

AI agents implementing GUI changes should self-audit against this checklist before considering a task complete:

| # | Heuristic | Verification question |
|---|-----------|----------------------|
| 1 | Visibility of system status | Does the UI communicate what is happening at all times during an operation? |
| 2 | Match between system and real world | Are all labels, tooltips, and messages written in user-friendly language? |
| 3 | User control and freedom | Can the user cancel, undo, or escape from any state? |
| 4 | Consistency and standards | Do similar controls behave identically across all pages? |
| 5 | Error prevention | Are destructive actions guarded by confirmation? Are invalid states prevented? |
| 6 | Recognition rather than recall | Can the user understand every control without consulting external documentation? |
| 7 | Flexibility and efficiency | Do keyboard shortcuts work? Are sensible defaults provided? |
| 8 | Aesthetic and minimalist design | Are only relevant controls visible for the current operation type? |
| 9 | Error recovery | Are error messages actionable and human-readable? |
| 10 | Help and documentation | Do tooltips exist for all controls? Is the docs site link accessible? |
