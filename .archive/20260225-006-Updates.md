# shruggie-indexer — Pending Updates (2026-02-25, Batch 6)

- **Project:** `shruggie-indexer`
- **Repository:** [shruggietech/shruggie-indexer](https://github.com/shruggietech/shruggie-indexer)
- **Author:** William Thompson (ShruggieTech LLC)
- **Date:** 2026-02-25
- **Target Release:** Pre-v0.1.1 (GUI stabilization, continued)
- **Audience:** AI-first, Human-second
- **Predecessor:** This document follows `20260225-005-Updates.md`. It assumes the rename path-doubling bug (Section 2) and log-level reclassifications (Section 1) from that document have been resolved. The runtime log (`20260225-005-Updates_Runtime.log`) and filesystem tree (`data_tree.json`) from the successful post-fix run are the primary evidence files for the issues described here.

---

## Purpose

The rename path construction and log-level issues from Batch 5 are resolved. Files are now being renamed to their `storage_name` values at correct paths across all directory depths. However, analysis of the post-fix runtime log and resulting filesystem state reveals three systemic issues that represent fundamental behavioral divergences from the original MakeIndex:

1. **Existing sidecar files are indexed as standalone items** instead of being excluded from traversal. This causes sidecar-of-sidecar output files, inflated item counts, and incorrect renames of metadata files.
2. **MetaMergeDelete does not delete anything.** The "Delete" in MetaMergeDelete is non-functional — no sidecar files are removed from disk after merging.
3. **Some files are silently skipped during the rename phase**, resulting in a mix of renamed and un-renamed files in the same directory tree.

Additionally, a fourth issue with in-place sidecar naming in the presence of renames requires correction.

This document defines four sections addressing these issues plus a fifth section specifying permanent test infrastructure for sidecar handling and MetaMergeDelete behavior.

### Implementation Ordering

1. **Section 1** (Sidecar exclusion from traversal) — Must be fixed first because it changes the set of items that flow through the entire pipeline. All downstream phases (indexing, sidecar discovery, rename, delete) are affected by which files the traversal phase emits.
2. **Section 2** (MetaMergeDelete deletion) — Implement the actual file deletion in Stage 6. Depends on Section 1 producing correct delete queue contents.
3. **Section 3** (Rename phase completeness) — Investigate why 10 files were skipped. Should be investigated after Section 1 because some of the skipped files are sidecars that should not have been in the rename set at all.
4. **Section 4** (In-place sidecar naming after rename) — Fix the sidecar filename to reference the renamed file. Can be addressed independently but logically follows the rename phase work.
5. **Section 5** (Permanent test infrastructure) — Implement after Sections 1–4 so that the tests validate the corrected behavior.

---

## 1. Sidecar Files Indexed as Standalone Items (Priority: Critical)

### 1.1. Problem Statement

Files matching known sidecar and indexer-output patterns (`_meta.json`, `_meta2.json`, `_info.json`) are being treated as regular files by the discovery phase. They are enumerated as items, fully indexed (hashed, EXIF-checked, sidecar-discovered), renamed, and given their own in-place sidecar files. This is a fundamental violation of the spec's traversal exclusion contract.

The spec defines two complementary exclusion mechanisms (§7.5):

- **`metadata_exclude_patterns`**: Files matching these patterns are always excluded from traversal — they are indexer output artifacts that must never be indexed as standalone items. The default patterns are: `_(meta2?|directorymeta2?)\.json$`, `\.(cover|thumb|thumb(s|db|index|nail))$`, `^(thumb|thumb(s|db|index|nail))\.db$`.
- **`metadata_identify` patterns (when MetaMerge is active)**: Files matching any sidecar identification pattern for a sibling item's basename are excluded from the regular item list and processed as sidecars instead.

Neither exclusion mechanism is functioning correctly. The evidence shows both indexer-output files and recognized sidecars appearing as standalone items.

### 1.2. Evidence from Runtime Log

**Indexer-output files indexed as items.** The discovery phase for `data/` finds 9 items (6 files, 3 directories). The actual content files are `123.nfo` and `123.txt`. The other 4 files — `123.nfo_meta.json`, `123.nfo_meta2.json`, `123.txt_meta.json`, `123.txt_meta2.json` — are indexer sidecar output from a prior run. They match `_(meta2?)\.json$` and should be excluded by `metadata_exclude_patterns`:

```
06:47:34  INFO     Discovery complete: 9 items found in 0.000s (6 files, 3 directories)
...
06:47:35  DEBUG    Completed [2/9]: 123.nfo_meta.json in 0.016s
06:47:35  DEBUG    Completed [3/9]: 123.nfo_meta2.json in 0.000s
...
06:47:35  DEBUG    Completed [5/9]: 123.txt_meta.json in 0.000s
06:47:35  DEBUG    Completed [6/9]: 123.txt_meta2.json in 0.000s
```

The same pattern repeats in `not-empty/` (10 items discovered, 7 files — but `FeedsExport.7z_meta.json`, `FeedsExport.7z_meta2.json`, `FeedsExport_meta.json`, `FeedsExport_meta2.json` are all indexer output) and in `not-empty/pdf/pdf/` (6 items discovered — but `_1.pdf_meta.json`, `_1.pdf_meta2.json`, `_2.pdf_meta.json`, `_2.pdf_meta2.json` are indexer output).

**Sidecar files indexed as items (not just excluded output).** The `.7z_info.json` and `_info.json` files are recognized as sidecars by the sidecar discovery system (line 65: `Sidecar discovered: FeedsExport.7z_info.json (type=json_metadata) for item FeedsExport.7z`), but they are ALSO indexed as standalone items (line 71: `Completed [2/10]: FeedsExport.7z_info.json`). These files should be consumed by the sidecar merge system, not indexed independently.

### 1.3. Consequences

The failure to exclude sidecar files cascades through the entire pipeline:

| Consequence | Example from evidence |
|---|---|
| **Inflated item counts.** The discovery phase reports more items than actually exist as content files. | `data/` reports 6 files; should report 2. |
| **Sidecar-of-sidecar output.** Sidecar files that are indexed as standalone items receive their own `_meta2.json` in-place output, creating absurd filenames. | `123.nfo_meta.json_meta2.json`, `FeedsExport.7z_meta2.json_meta2.json` |
| **Incorrect renames.** Sidecar files are renamed to hash-based `storage_name` values, destroying the sidecar naming convention. | `123.nfo_meta.json → y946BB2ACFA9079B53A094F8541402B3A.json` |
| **Redundant sidecar discovery.** Sidecar files that are indexed as standalone items discover OTHER sidecars as their own metadata, creating a combinatorial explosion of cross-references. | `FeedsExport.7z_meta.json` discovers `FeedsExport.7z_info.json` and `FeedsExport_info.json` as its own sidecars. |
| **Delete queue pollution.** When MetaMergeDelete does work (Section 2), the delete queue will contain paths to files that have been renamed, causing deletion failures. | N/A (Section 2 is non-functional currently). |

### 1.4. Root Cause

The traversal module's `list_children()` function (or the entry construction's file-filtering logic) is not applying `metadata_exclude_patterns` during item enumeration. The sidecar module's `_is_excluded()` function exists in `core/sidecar.py` but is applied only to sidecar discovery results — it is not gating the main item list.

The implementing agent must verify:

1. **Is `metadata_exclude_patterns` being applied during `list_children()`?** The spec (§6.1, §7.5) requires these patterns to filter the item list before items enter the processing loop. If the patterns are only applied during sidecar discovery, the exclusion is happening too late.

2. **When MetaMerge is active, is the `metadata_identify` union check applied to filter files that match sidecar patterns for any sibling's basename?** This is the second exclusion layer — even if a file doesn't match `metadata_exclude_patterns`, it should be excluded from the item list if it's a recognized sidecar of another item in the same directory.

### 1.5. How the Original MakeIndex Handles This

In the original PowerShell implementation, the `$MetadataFileParser.Indexer.ExcludeString` alternation is applied as a negative filter during directory enumeration. Files matching the exclude pattern are removed from the items list before the per-item processing loop begins. Separately, when MetaMerge is active, the `$MetadataFileParser.Indexer.IncludeString` alternation identifies files that are sidecars of other items — these are excluded from the standalone item list and instead consumed by `GetFileMetaSiblings` / `ReadMetaFile` during their parent item's processing.

The Python implementation must replicate both exclusion layers:

- **Layer 1 (always active):** Filter `metadata_exclude_patterns` against all filenames during `list_children()`. This removes indexer output artifacts unconditionally.
- **Layer 2 (when MetaMerge is active):** After Layer 1, filter any remaining file that matches a `metadata_identify` pattern for any other file's basename in the same directory. This removes recognized sidecars from the item list so they are processed exclusively through the sidecar merge system.

### 1.6. Affected Files

| File | Role |
|------|------|
| `src/shruggie_indexer/core/traversal.py` | `list_children()` — primary location for exclusion filtering |
| `src/shruggie_indexer/core/entry.py` | `build_directory_entry()` — may contain item filtering logic; also responsible for passing the correct sibling list to sidecar discovery |
| `src/shruggie_indexer/core/sidecar.py` | `discover_and_parse()`, `_is_excluded()` — verify that the exclusion check already present here is complementary to, not a replacement for, the traversal-level exclusion |
| `src/shruggie_indexer/config/defaults.py` | `METADATA_EXCLUDE_PATTERNS` — verify the patterns are compiled and accessible |

### 1.7. Acceptance Criteria

- Files matching `metadata_exclude_patterns` (e.g., `_meta.json`, `_meta2.json`, `_directorymeta2.json`) are never enumerated as standalone items during discovery.
- When MetaMerge is active, files matching sidecar identification patterns for a sibling item are not enumerated as standalone items — they are processed exclusively through sidecar discovery.
- The discovery phase for `data/` with the test directory reports 2 files (not 6).
- No sidecar-of-sidecar output files are created (e.g., no `file_meta.json_meta2.json`).
- No sidecar files are renamed.
- The runtime log shows no `ExifTool invoked for:` entries for sidecar files.

---

## 2. MetaMergeDelete Does Not Delete (Priority: Critical)

### 2.1. Problem Statement

When running in MetaMergeDelete mode (the "Meta Merge Delete" option in the GUI), no sidecar files are deleted from disk after their content is merged into the parent entry's metadata array. The "Delete" functionality is entirely non-operational.

### 2.2. Evidence from Filesystem Tree

The `data_tree.json` post-run snapshot shows every pre-existing sidecar file still present on disk. For example, in `not-empty/`:

- `FeedsExport_meta.json` — still present (should have been merged and deleted)
- `FeedsExport_meta2.json` — still present
- `FeedsExport.7z_meta.json` — renamed to `y68E8EA97A4105E6459E028D63CA2CA47.json` (should have been merged and deleted, not renamed)

No sidecar file in the entire tree was deleted. The MetaMergeDelete mode behaved identically to plain MetaMerge.

### 2.3. Evidence from Runtime Log

The log contains no delete-related messages at any severity level. There is no evidence that the Stage 6 post-processing delete phase executed at all. The log jumps directly from the last in-place sidecar write (line 273) to the discovery summary messages, with no intervening delete operations.

### 2.4. Likely Root Causes (Ordered by Probability)

1. **Stage 6 post-processing is not implemented or not invoked.** The delete queue is populated during sidecar discovery (the `delete_queue` parameter is passed through the call chain), but the code that iterates the queue and removes files in Stage 6 was never written, or the orchestrator (GUI or entry module) never calls it after indexing completes.

2. **The delete queue is created but not passed through the call chain.** If the `delete_queue=None` default is not overridden when `meta_merge_delete=True`, the sidecar module will not append paths to it. Check whether the GUI orchestrator or `index_path()` creates and passes a `list[Path]` when MetaMergeDelete is active.

3. **The delete queue is populated but the deletion loop has a bug.** The queue contains paths, but the loop that removes them encounters an error (e.g., the paths were constructed incorrectly, or the files were already renamed and the original paths no longer exist) and fails silently.

### 2.5. How the Original MakeIndex Handles This

In the original, `$global:DeleteQueue` is a script-scoped ArrayList. During `ReadMetaFile`, each successfully parsed sidecar's full path is added to the queue. After the complete index tree is built and all output is written, the post-processing block iterates `$global:DeleteQueue` and calls `Remove-Item -Force` on each path. The deletion is logged.

The Python implementation must:

1. Create a `delete_queue: list[Path] = []` when `config.meta_merge_delete` is `True`.
2. Pass it into `build_directory_entry()` / `build_file_entry()`, which forward it to `sidecar.discover_and_parse()`.
3. After all indexing, output, and rename operations complete, iterate the queue and delete each file.
4. Log each deletion at `INFO` level: `Sidecar deleted: {path}`.
5. Log deletion failures at `ERROR` level: `Sidecar delete FAILED: {path}: {exception}`.

### 2.6. Interaction with Rename

**Critical ordering concern:** When both rename and MetaMergeDelete are active, the rename phase runs before the delete phase (per the original's behavior). However, if a sidecar file was incorrectly indexed and renamed (Section 1's bug), the delete queue will contain the original pre-rename path — which no longer exists on disk. Once Section 1 is fixed (sidecars excluded from item list and therefore not renamed), the delete queue paths will be correct.

The post-fix ordering must be:

1. Indexing completes (including sidecar discovery, which populates the delete queue).
2. In-place sidecar output is written for each item.
3. Rename phase executes (renames content files, not sidecar files).
4. Delete phase executes (deletes the original sidecar files from the queue).

### 2.7. Affected Files

| File | Role |
|------|------|
| `src/shruggie_indexer/gui/app.py` | GUI orchestrator — must create `delete_queue`, pass it through the pipeline, and execute deletions after indexing completes |
| `src/shruggie_indexer/core/entry.py` | `index_path()`, `build_directory_entry()` — must accept and forward `delete_queue` |
| `src/shruggie_indexer/core/sidecar.py` | `discover_and_parse()` — must append to `delete_queue` when active |
| `src/shruggie_indexer/cli/commands.py` | CLI entry point — same `delete_queue` wiring as the GUI |

### 2.8. Acceptance Criteria

- When MetaMergeDelete is active, every sidecar file whose content was successfully merged into its parent entry's `metadata` array is deleted from disk after all indexing and output operations complete.
- Deleted files are logged at `INFO`: `Sidecar deleted: {path}`.
- Failed deletions are logged at `ERROR`: `Sidecar delete FAILED: {path}: {exception}`.
- Failed deletions do not abort the deletion loop — remaining files are still attempted.
- The delete phase runs after the rename phase.
- The delete queue contains only files that were consumed as sidecars — not indexer output artifacts (those should have been excluded by Section 1's fix and thus never entered the pipeline).

---

## 3. Rename Phase: Missing Files (Priority: High)

### 3.1. Problem Statement

Of the 38 files processed across the entire directory tree, 28 were renamed and 10 were silently skipped. The skipped files received in-place `_meta2.json` sidecar output (proving they were indexed) but no rename attempt appears in the log.

### 3.2. Skipped Files

| File | Directory | Expected? |
|------|-----------|-----------|
| `slippers_01.gif` | `images/` | No — this is a content file that should be renamed. |
| `slippers_01.png` | `images/` | No |
| `slippers_01.webm` | `images/` | No |
| `slippers_02.gif` | `images/` | No |
| `slippers_02.png` | `images/` | No |
| `slippers_02.webm` | `images/` | No |
| `FeedsExport_info.json` | `not-empty/` | **Partially** — this file is a sidecar but should have been excluded by Section 1. If Section 1 is fixed, this file would not be in the rename set. But since it was indexed, it should have been renamed. |
| `FeedsExport_meta.json` | `not-empty/` | Same as above. |
| `FeedsExport_meta2.json` | `not-empty/` | Same as above. |
| `How_the_DNS_works-[2ZUxoi7YNgs].en.vtt` | `not-empty/yt-dlp/` | No — this is a content file. **Additionally, this file is missing from the post-run filesystem tree entirely** — neither the original name nor a renamed version appears on disk. This may indicate data loss. |

### 3.3. Observations

**The `slippers_01/02` files are the most revealing.** These are unambiguous content files with no sidecar relationship to `slippers.*`. They are in the same directory as `slippers.gif`, `slippers.png`, and `slippers.webm` — all of which WERE renamed. This rules out a directory-level issue. Something about these specific files causes the rename loop to skip them.

**The `.en.vtt` file disappearance is concerning.** The file was processed (log line 152, item 4/8 in yt-dlp), its in-place sidecar was written (log line 269: `How_the_DNS_works-[2ZUxoi7YNgs].en.vtt_meta2.json`), but the file itself is absent from the post-run filesystem. It was not renamed (no rename log entry), and it does not appear with its original name in the tree. This file matches the subtitles sidecar pattern (`\.vtt$`), so it IS being discovered as a sidecar of other yt-dlp files. If MetaMergeDelete's delete queue is somehow partially functional (or if a different code path is deleting sidecar matches), this file may have been deleted mid-run. The implementing agent must investigate whether the sidecar discovery system is performing inline deletions instead of deferring to the Stage 6 queue.

### 3.4. Likely Root Causes

1. **The rename phase is iterating a subset of entries.** The rename dispatch loop may be iterating only the `items` field of the top-level directory entry and not recursing into child directory entries. Since `slippers_01.*` files are in a subdirectory (`images/`), and `images/` itself is a child of the top-level `data/` entry, the rename would correctly handle `data/` children (the 6 root files) but miss `images/` children.

   However, this contradicts the evidence: files in `not-empty/pdf/pdf/`, `not-empty/unicode-file-names/`, and `not-empty/yt-dlp/` WERE renamed. So the rename does recurse into some subdirectories. The issue may be more subtle — perhaps the rename recurses through the entry tree but skips entries at certain nesting levels, or skips entries that share a basename prefix with other entries.

2. **Rename is filtered by a condition that excludes some entries.** Possible filtering conditions: the entry's `type` field, the presence of a specific attribute, or a check against the sidecar identification patterns. If the rename loop checks whether the filename matches a sidecar pattern and skips it, the `_01` and `_02` variant files would not be affected — but `.en.vtt` might be (since `.vtt` matches the subtitles pattern).

3. **Race condition in the entry tree.** The rename phase traverses the `IndexEntry` tree after indexing completes. If the tree structure is mutated or incompletely populated (e.g., if some child entries are missing due to the threading model), the rename loop would skip whatever is absent.

### 3.5. Required Investigation

The implementing agent must:

1. Add a `DEBUG`-level log at the start of the rename loop that logs every entry being considered for rename, including those that are skipped: `Rename candidate: {path} (type={type}, storage_name={storage_name}, skip_reason={reason})`.
2. Trace the rename dispatch from the GUI orchestrator through the entry tree to identify which loop structure is used and why 10 entries are missing.
3. Verify that the `.en.vtt` file's disappearance is explained by the code path — if it was deleted by a code path other than the Stage 6 delete queue, that code path must be identified and corrected.

### 3.6. Affected Files

| File | Role |
|------|------|
| `src/shruggie_indexer/gui/app.py` | GUI orchestrator — entry point for the rename dispatch |
| `src/shruggie_indexer/core/entry.py` | `build_directory_entry()` — constructs the entry tree; the rename phase walks this tree |
| `src/shruggie_indexer/core/rename.py` | `rename_item()` — verify it is called for every file entry at all depths |

### 3.7. Acceptance Criteria

- Every non-directory `IndexEntry` in the completed entry tree is processed by the rename phase (either renamed or logged as a dry-run candidate).
- No file entry is silently skipped. If an entry is intentionally excluded from rename (e.g., it is a directory, or it matches an exclusion condition), a `DEBUG`-level log explains the skip.
- After Section 1's fix, the only files passed to the rename phase are actual content files — sidecar files are excluded from the item list entirely and thus never enter the rename set.
- Running against the test directory with all fixes applied results in exactly 2 files renamed in `data/` root (`123.nfo`, `123.txt`), 9 files renamed in `images/`, the actual content files renamed in `not-empty/` and all subdirectories, and zero sidecar files renamed.

---

## 4. In-Place Sidecar Naming After Rename (Priority: High)

### 4.1. Problem Statement

When rename is active, the in-place `_meta2.json` sidecar file should be written alongside the **renamed** file, using the renamed filename as its base. Instead, sidecars are written using the **original** filename.

### 4.2. Evidence

Log line 223:

```
06:47:38  DEBUG    Inplace sidecar written to A:\...\data\123.nfo_meta2.json
```

At this point, `123.nfo` has already been renamed to `y65830E2E332651F6235D52A8553E1864.nfo` (log line 194). The in-place sidecar should be:

```
y65830E2E332651F6235D52A8553E1864.nfo_meta2.json
```

Not:

```
123.nfo_meta2.json
```

### 4.3. Impact

The incorrect naming creates two problems:

1. **Orphaned sidecars.** The `_meta2.json` file references the original filename in `name.text`, but the sidecar file itself sits next to a renamed file. There is no on-disk association between `y65830E2E332651F6235D52A8553E1864.nfo` and `123.nfo_meta2.json` — a consumer looking for the sidecar of the renamed file would look for `y65830E2E332651F6235D52A8553E1864.nfo_meta2.json` and not find it.

2. **Filename collision with prior sidecar output.** When the test directory already contains `123.nfo_meta2.json` from a prior run, the new in-place sidecar write overwrites it. This is data-destructive in the MetaMerge scenario — the prior sidecar's content (which may differ from the current run's output) is silently replaced. With Section 1's fix, the prior `_meta2.json` would be excluded from the item list, so it would not be renamed or re-indexed — but it would still be overwritten by the new sidecar write.

### 4.4. How the Original MakeIndex Handles This

In the original, the `OutFileInPlace` write and the `Rename` operation are coordinated: the in-place sidecar file is written using the post-rename filename. The `MakeObject` function updates the output path after the rename completes. The sidecar file's content still contains the original name in the `Name` field (for reversibility), but the sidecar file itself is named relative to the storage name.

### 4.5. Fix Requirement

The in-place sidecar write must use the post-rename path when rename is active:

- **Without rename:** Sidecar for `photo.jpg` → `photo.jpg_meta2.json` (current behavior, correct).
- **With rename:** Sidecar for `photo.jpg` (renamed to `yABC123.jpg`) → `yABC123.jpg_meta2.json` (not `photo.jpg_meta2.json`).

The sidecar's JSON content still records `name.text = "photo.jpg"` for reversibility.

### 4.6. Timing Implication

Currently, in-place sidecar writes happen during the Stage 3–4 traversal loop (per spec §6.9, for partial-result survival). When rename is active, either:

- **(a)** The sidecar write must be deferred until after the rename phase, so the renamed path is available, OR
- **(b)** The rename phase must also rename the previously-written sidecar file to match the new base filename.

Option (a) changes the write timing (sidecars are no longer written during traversal), which loses the partial-result survival property. Option (b) preserves the existing timing but adds a secondary rename step for each sidecar.

**Recommendation:** Option (b). The rename phase already walks the entry tree; for each renamed file, it should also rename the in-place sidecar from `{original_name}_meta2.json` to `{storage_name}_meta2.json` in the same loop iteration. This preserves partial-result survival for the common non-rename case and adds minimal complexity to the rename path.

### 4.7. Affected Files

| File | Role |
|------|------|
| `src/shruggie_indexer/core/rename.py` | `rename_item()` — add sidecar rename step |
| `src/shruggie_indexer/core/paths.py` | `build_sidecar_path()` — may need a variant that takes a storage_name |
| `src/shruggie_indexer/gui/app.py` | Orchestrator — verify the rename-then-sidecar-rename ordering |

### 4.8. Acceptance Criteria

- When rename is active, each in-place `_meta2.json` sidecar file on disk is named relative to the renamed file: `{storage_name}_meta2.json`.
- The sidecar file's JSON content preserves the original filename in `name.text`.
- When rename is not active, sidecar naming is unchanged (`{original_name}_meta2.json`).
- No orphaned sidecars exist after a rename + in-place operation.

---

## 5. Permanent Test Infrastructure: Sidecar Handling and MetaMergeDelete (Priority: High)

### 5.1. Purpose

The sidecar exclusion, MetaMergeDelete, and rename behaviors have been the source of multiple bug batches. These behaviors must be covered by permanent, automated test cases that run in CI and prevent regressions. The tests validate behavior at two levels: unit tests for individual module functions, and integration tests that exercise the full pipeline against a known directory structure.

### 5.2. Test Fixture: `tests/fixtures/sidecar-testbed/`

Create a static test directory with the following structure. This fixture exercises all sidecar exclusion, merge, delete, and rename scenarios in a single tree:

```
sidecar-testbed/
├── content.txt                         # Plain content file (no sidecars)
├── video.mp4                           # Content file WITH sidecars
├── video.mp4.info.json                 # Sidecar: json_metadata (yt-dlp pattern)
├── video.mp4.description               # Sidecar: description
├── video.mp4_screen.jpg                # Sidecar: screenshot
├── video.mp4_meta.json                 # Prior-run indexer output (v1 sidecar) — MUST be excluded
├── video.mp4_meta2.json                # Prior-run indexer output (v2 sidecar) — MUST be excluded
├── photo.jpg                           # Content file with generic sidecar
├── photo.jpg.md5                       # Sidecar: hash
├── data.csv                            # Content file, no sidecars, non-excluded extension
├── _directorymeta2.json                # Prior-run directory sidecar — MUST be excluded
├── subdir/
│   ├── nested.txt                      # Content file in subdirectory
│   ├── nested.txt_meta.json            # Prior-run indexer output — MUST be excluded
│   ├── nested.txt.yaml                 # Sidecar: generic_metadata
│   └── _directorymeta2.json            # Prior-run directory sidecar — MUST be excluded
└── no-sidecars/
    ├── standalone.pdf                  # Content file, no sidecars
    └── standalone_notes.txt            # NOT a sidecar (naming similarity is coincidental)
```

The fixture files should be minimal — content files can be single-byte or empty. Sidecar files should contain valid (but minimal) data for their type: `info.json` contains `{}`, `.description` contains a line of text, `.md5` contains a hex string, `_screen.jpg` is a 1x1 JPEG, `.yaml` contains `key: value`.

### 5.3. Unit Tests: `tests/test_sidecar_exclusion.py`

These tests validate that the traversal and sidecar modules correctly identify which files to exclude, without running the full indexing pipeline.

```python
# Test 1: metadata_exclude_patterns correctly match indexer output artifacts
def test_exclude_patterns_match_v1_meta():
    """_meta.json files match metadata_exclude_patterns."""

def test_exclude_patterns_match_v2_meta():
    """_meta2.json files match metadata_exclude_patterns."""

def test_exclude_patterns_match_v1_directorymeta():
    """_directorymeta.json files match metadata_exclude_patterns."""

def test_exclude_patterns_match_v2_directorymeta():
    """_directorymeta2.json files match metadata_exclude_patterns."""

def test_exclude_patterns_do_not_match_content_files():
    """Content files like video.mp4, photo.jpg do not match exclusion patterns."""

def test_exclude_patterns_do_not_match_info_json():
    """Sidecar files like video.mp4.info.json do not match metadata_exclude_patterns
    (they are handled by metadata_identify, not the exclude list)."""

# Test 2: list_children respects metadata_exclude_patterns
def test_list_children_excludes_meta_json(sidecar_testbed, default_config):
    """list_children() does not return files matching metadata_exclude_patterns."""

def test_list_children_excludes_directorymeta2_json(sidecar_testbed, default_config):
    """list_children() does not return _directorymeta2.json."""

# Test 3: When MetaMerge is active, sidecar files are excluded from item list
def test_list_children_meta_merge_excludes_sidecars(sidecar_testbed, meta_merge_config):
    """When MetaMerge is active, video.mp4.info.json is not in the item list."""

def test_list_children_meta_merge_keeps_non_sidecars(sidecar_testbed, meta_merge_config):
    """When MetaMerge is active, content files remain in the item list."""

def test_non_sidecar_with_similar_name_not_excluded(sidecar_testbed, meta_merge_config):
    """standalone_notes.txt is NOT excluded even though 'standalone' appears in its name."""
```

### 5.4. Unit Tests: `tests/test_meta_merge_delete.py`

These tests validate the delete queue population and execution.

```python
# Test 1: Delete queue is populated during sidecar discovery
def test_delete_queue_populated_when_active(sidecar_testbed, mmd_config):
    """When meta_merge_delete=True, discover_and_parse() appends sidecar paths
    to the delete_queue."""

def test_delete_queue_empty_when_inactive(sidecar_testbed, merge_only_config):
    """When meta_merge_delete=False (but meta_merge=True), the delete_queue
    is not populated."""

def test_delete_queue_contains_correct_paths(sidecar_testbed, mmd_config):
    """The delete queue contains absolute paths to the sidecar files that were
    successfully parsed, not to content files or indexer output artifacts."""

# Test 2: Delete phase execution
def test_delete_phase_removes_files(tmp_sidecar_testbed, mmd_config):
    """After the full pipeline runs with MetaMergeDelete, sidecar files are
    removed from disk. Uses a tmp copy of the fixture to allow destructive ops."""

def test_delete_phase_does_not_remove_content_files(tmp_sidecar_testbed, mmd_config):
    """Content files (video.mp4, photo.jpg) survive MetaMergeDelete."""

def test_delete_phase_logs_deletions(tmp_sidecar_testbed, mmd_config, caplog):
    """Each deleted sidecar produces an INFO log message."""

def test_delete_phase_continues_on_failure(tmp_sidecar_testbed, mmd_config):
    """If one sidecar deletion fails (e.g., file already removed), the loop
    continues and deletes remaining files."""
```

### 5.5. Integration Tests: `tests/test_integration_mmd_pipeline.py`

These tests run the full indexing pipeline (via `index_path()`) against a temporary copy of the test fixture and validate end-to-end behavior.

```python
# Test 1: Full MetaMergeDelete pipeline
def test_mmd_pipeline_item_count(tmp_sidecar_testbed, mmd_config):
    """The root entry's items list contains only content files and directories,
    no sidecar or indexer-output files."""

def test_mmd_pipeline_metadata_merged(tmp_sidecar_testbed, mmd_config):
    """Content files that have sidecars contain MetadataEntry objects in their
    metadata array with origin='sidecar'."""

def test_mmd_pipeline_sidecars_deleted(tmp_sidecar_testbed, mmd_config):
    """After the pipeline completes, sidecar files are absent from disk."""

def test_mmd_pipeline_content_files_intact(tmp_sidecar_testbed, mmd_config):
    """After the pipeline completes, content files exist on disk with unchanged content."""

# Test 2: Full MetaMergeDelete + Rename pipeline
def test_mmd_rename_pipeline_files_renamed(tmp_sidecar_testbed, mmd_rename_config):
    """Content files are renamed to storage_name values on disk."""

def test_mmd_rename_pipeline_sidecars_deleted(tmp_sidecar_testbed, mmd_rename_config):
    """Sidecar files are deleted even when rename is active."""

def test_mmd_rename_pipeline_inplace_sidecar_named_correctly(tmp_sidecar_testbed, mmd_rename_config):
    """In-place _meta2.json files are named relative to the storage_name, not the original name."""

def test_mmd_rename_no_sidecar_of_sidecar(tmp_sidecar_testbed, mmd_rename_config):
    """No file matching the pattern *_meta*_meta2.json exists after the run."""

# Test 3: Idempotency — running twice should not produce different results
def test_mmd_pipeline_idempotent(tmp_sidecar_testbed, mmd_config):
    """Running MetaMergeDelete twice against the same directory produces identical
    output on the second run (no new sidecars discovered, no new deletions, same
    entry tree structure)."""
```

### 5.6. Pytest Configuration

Add the following markers to `pyproject.toml`:

```toml
[tool.pytest.ini_options]
markers = [
    "sidecar: Tests for sidecar discovery, exclusion, and merge behavior",
    "mmd: Tests for MetaMergeDelete pipeline",
    "integration: Full pipeline integration tests (slower)",
    "destructive: Tests that modify the filesystem (use tmp copies)",
]
```

All `tmp_sidecar_testbed` fixtures should use `pytest`'s `tmp_path` to create a disposable copy of the fixture directory for each test, ensuring test isolation.

### 5.7. CI Integration

The sidecar and MMD tests should run in the standard `pytest` suite. The `integration` marker can be used to separate fast unit tests from slower pipeline tests if needed:

```bash
# Fast tests only
pytest -m "sidecar and not integration"

# Full suite including integration
pytest -m "sidecar or mmd"
```

---

## Reference: Test Directory Structure

The test directory is unchanged from previous batches. Located at `A:\Code\shruggie-indexer-testing\data`. The key structural parameters are: 38 files, 10 directories, max depth 4.

However, after the Batch 5 post-fix run, the directory now contains additional artifacts from this run:

- **28 renamed files** (y-prefixed hash names) coexisting with unrenamed originals
- **53 newly written `_meta2.json` files** (in-place sidecar output)
- **Multiple sidecar-of-sidecar files** (e.g., `123.nfo_meta.json_meta2.json`)

The test directory must be restored to its pre-run state before the next validation run. The `data_tree.json` from the previous batch (Batch 4) documents the pre-run state.

---

## Reference: Runtime Log

The complete runtime log from the Batch 5 post-fix run is attached as `20260225-005-Updates_Runtime.log` (274 lines). Key evidence regions:

| Lines | Content |
|-------|---------|
| 1–4 | Discovery phase: 9 items in root (inflated — should be 5 with 2 files + 3 dirs) |
| 9–22 | Sidecar files processed as standalone items |
| 65–95 | `not-empty/` sidecar files indexed independently, sidecar cross-discovery |
| 128–192 | `yt-dlp/` sidecar discovery cascade (every file discovers every other file as a sidecar) |
| 194–221 | Rename phase: 28 files renamed, 10 missing |
| 222–273 | In-place sidecar writes using pre-rename filenames |
