# Pending Updates (2026-03-01) — Batch 005

**Date:** 2026-03-01
**Scope:** shruggie-indexer
**Status:** PENDING
**Depends on:** All prior batches through 003 (assumed merged)

---

## Overview

This batch introduces the **Rollback** feature — the ability to reverse indexer rename and de-duplication operations by reading `_meta2.json` sidecar files and restoring files to their original names, directory structure, and timestamps. The feature also reconstructs absorbed sidecar metadata files that were consumed by MetaMergeDelete, and restores deduplicated files by copying canonical bytes to each duplicate's original path.

Rollback is designed as an **API-first** feature. The core engine (`core/rollback.py`) is a standalone module with no CLI, GUI, or presentation-layer dependencies. It operates on `IndexEntry` objects and filesystem paths, and is designed for direct importability by downstream ecosystem components — specifically `shruggie-vault`, which will invoke rollback programmatically when delivering files to end users (look up → retrieve → rollback to original form → deliver). The CLI subcommand and GUI operation mode are thin consumers of this API.

This batch also introduces the **subcommand group** pattern for the CLI, migrating from a single flat command to a `click.Group` with `index` (default, backward-compatible) and `rollback` subcommands. This sets the architectural pattern for future subcommands (`migrate`, etc.).

### Session Ordering

Sessions MUST be implemented in the order listed. Each session's preconditions reference prior sessions within this batch.

1. **Section 1** — CLI subcommand group migration. Restructures the CLI entry point.
2. **Section 2** — Core rollback engine (`core/rollback.py`). Data classes, loader, planner, executor.
3. **Section 3** — CLI rollback subcommand (`cli/rollback.py`). Thin Click command consuming the core engine.
4. **Section 4** — GUI rollback operation mode. New operation type in the Operations page dropdown.
5. **Section 5** — Public API surface, documentation, specification amendments, and changelog.

### Design Principles

**D1. API-first.** The core engine is the product. CLI and GUI are presentation layers. All rollback logic lives in `core/rollback.py` and is invocable programmatically without any presentation-layer import. Future `shruggie-vault` operations will consume this API directly.

**D2. Plan-then-execute.** Following the pattern established by `core/dedup.py`, the rollback separates planning from execution. `plan_rollback()` computes the complete operation graph without touching the filesystem. `execute_rollback()` carries it out. This gives callers dry-run, inspection, and selective execution for free.

**D3. Non-destructive by default.** Rollback **copies** files to the target directory. Source files remain untouched. The user inspects the result and cleans up originals manually. This mirrors the safety philosophy of `--dry-run` and the MetaMergeDelete guard.

**D4. Forensic-grade fidelity.** Restored files have their `mtime` and `atime` set from the sidecar's `timestamps.modified` and `timestamps.accessed` fields. On Windows with `pywin32` available, `ctime` (creation time) is also restored. Absorbed sidecar metadata files are reconstructed from their `MetadataEntry` representations. The goal is bit-for-bit and metadata-faithful reconstruction of the pre-indexing filesystem state.

**D5. Pluggable source resolution.** The source file locator accepts an optional resolver callable, enabling downstream tools (vault) to provide custom file retrieval logic rather than assuming files are on the local filesystem adjacent to their sidecars.

**D6. v1 sidecars are not supported.** If a `_meta2.json` file lacks `schema_version` or has `schema_version != 2`, the rollback fails hard with a clear error message directing the user to the future `migrate` tool. No best-effort parsing is attempted.

---

## 1. CLI Subcommand Group Migration (Priority: High)

### 1.1. Problem Statement

The current CLI is a single flat `@click.command()` in `cli/main.py`. Adding rollback as a `--revert` flag on this command would create an awkward mutual-exclusion surface where most flags become irrelevant. The rollback operation has fundamentally different inputs (meta2 path, target directory, source directory) than indexing (target path, output options, rename flags).

The clean solution is a `click.Group` with distinct subcommands. This batch introduces the group; the rollback subcommand is added in Section 3.

### 1.2. Required Changes

**A. Convert `main()` from `@click.command()` to `@click.group()` with a default subcommand.**

The existing `main()` function becomes the group. The current indexing logic moves into an `index` subcommand. Backward compatibility is preserved: `shruggie-indexer <path>` (no explicit subcommand) continues to invoke `index`.

Click does not natively support default subcommands. The **recommended** approach is a minimal `DefaultGroup` class implemented directly in `cli/main.py`:

```python
class DefaultGroup(click.Group):
    """Click group that falls back to a default command."""

    default_cmd_name: str | None = None

    def parse_args(self, ctx: click.Context, args: list[str]) -> list[str]:
        # If the first arg isn't a known subcommand, inject the default.
        if args and args[0] not in self.commands and self.default_cmd_name:
            args = [self.default_cmd_name, *args]
        elif not args and self.default_cmd_name:
            args = [self.default_cmd_name]
        return super().parse_args(ctx, args)
```

This is ~10 lines, avoids adding a new dependency, and handles the common cases (no subcommand, unknown first argument). The implementing agent must verify it handles `--help`, `--version`, and edge cases (flags that look like subcommand names).

If the implementing agent determines that this minimal class does not cover all backward compatibility requirements, the `click-default-group` package may be used instead. If so, it MUST be added to `[project.dependencies]` in `pyproject.toml`.

**B. Move the indexing body into `index_cmd()`.**

All current parameters, options, and logic from the existing `main()` become the `index` subcommand:

```python
@main.command("index")
@click.argument("target", required=False, type=click.Path(exists=True))
@click.option("--rename", is_flag=True, ...)
# ... all existing options ...
def index_cmd(target, rename, ...):
    """Index files and directories (default command)."""
    # ... current main() body ...
```

**C. Register the default.**

```python
main.default_cmd_name = "index"
```

**D. Preserve entry points.**

The `pyproject.toml` entry point remains unchanged:

```toml
[project.scripts]
shruggie-indexer = "shruggie_indexer.cli.main:main"
```

The `__main__.py` import remains unchanged. The `main()` function is now a group, but Click groups are callable in the same way as commands.

### 1.3. Backward Compatibility Contract

After this migration, ALL of the following must work identically to the current behavior:

```bash
# All existing invocations (no subcommand) — delegated to 'index'
shruggie-indexer /path/to/target
shruggie-indexer /path/to/target --rename --inplace
shruggie-indexer /path/to/target --meta-merge-delete --inplace -vv
shruggie-indexer --help
shruggie-indexer --version

# New explicit subcommand form
shruggie-indexer index /path/to/target
shruggie-indexer index /path/to/target --rename --inplace
shruggie-indexer index --help
```

The `--help` output for `shruggie-indexer` (the group) should list available subcommands. The `--help` output for `shruggie-indexer index` should show the full indexing option set (identical to the current `shruggie-indexer --help` option listing).

### 1.4. Affected Files

| File | Nature of change |
|------|------------------|
| `src/shruggie_indexer/cli/main.py` | Convert `main()` to group, extract `index_cmd()`, add `DefaultGroup` |
| `src/shruggie_indexer/cli/__init__.py` | No change (re-exports `main`) |
| `src/shruggie_indexer/__main__.py` | No change |
| `pyproject.toml` | Potentially add `click-default-group` dependency (agent decision) |

### 1.5. Acceptance Criteria

- `shruggie-indexer /path` (no subcommand) behaves identically to the pre-migration CLI.
- `shruggie-indexer index /path` behaves identically.
- `shruggie-indexer --help` lists `index` and (after Section 3) `rollback` subcommands.
- `shruggie-indexer index --help` shows the full indexing option set.
- `shruggie-indexer --version` prints the version.
- `python -m shruggie_indexer /path` still works.
- All existing tests in `tests/` pass without modification (or with minimal adaptation to the group structure).

---

## 2. Core Rollback Engine (Priority: High)

### 2.1. Module Location

**New file:** `src/shruggie_indexer/core/rollback.py`

This module follows the same architectural principles as `core/dedup.py`: standalone, no CLI/GUI/presentation imports, operates on `IndexEntry` objects, designed for downstream importability.

### 2.2. Data Classes

```python
@dataclass
class RollbackAction:
    """A single file restoration action within a rollback plan."""

    source_path: Path | None
    """Where the content bytes currently live. None if unresolvable."""

    target_path: Path
    """Where they should be restored to."""

    entry: IndexEntry
    """The IndexEntry driving this action."""

    action_type: str
    """One of: 'restore', 'duplicate_restore', 'sidecar_restore', 'mkdir'."""

    skip_reason: str | None = None
    """Non-None if this action will be skipped. Contains the reason."""

    verified: bool = False
    """Whether the source file's hash was checked against the sidecar."""


@dataclass
class RollbackStats:
    """Summary statistics for a rollback plan or execution result."""

    total_entries: int = 0
    files_to_restore: int = 0
    duplicates_to_restore: int = 0
    sidecars_to_restore: int = 0
    directories_to_create: int = 0
    skipped_unresolvable: int = 0
    skipped_conflict: int = 0
    skipped_already_exists: int = 0


@dataclass
class RollbackPlan:
    """Complete plan for a rollback operation, computed before execution."""

    actions: list[RollbackAction]
    stats: RollbackStats
    warnings: list[str]


@dataclass
class RollbackResult:
    """Outcome of executing a rollback plan."""

    restored: int = 0
    duplicates_restored: int = 0
    sidecars_restored: int = 0
    directories_created: int = 0
    skipped: int = 0
    failed: int = 0
    errors: list[str] = field(default_factory=list)
```

### 2.3. Source Resolver Protocol

To support both local filesystem rollback (indexer CLI/GUI) and remote storage rollback (vault), the source locator uses a callable protocol:

```python
from typing import Protocol

class SourceResolver(Protocol):
    """Protocol for locating content files during rollback.

    Implementations provide the bytes for a given IndexEntry. The default
    implementation searches the local filesystem. Downstream tools (vault)
    provide implementations that retrieve bytes from remote storage.
    """

    def resolve(self, entry: IndexEntry, search_dir: Path | None) -> Path | None:
        """Return the local path to the content file, or None if not found.

        For remote resolvers, this may involve downloading the file to a
        temporary location and returning that path.
        """
        ...
```

**Default implementation — `LocalSourceResolver`:**

```python
class LocalSourceResolver:
    """Locate content files on the local filesystem.

    Search strategy (tried in order):
    1. Look for storage_name in search_dir → handles renamed files.
    2. Look for name.text in search_dir, verify hash if found → handles
       non-renamed files.
    Returns None if neither match succeeds.
    """

    def __init__(self, *, verify_hash: bool = True) -> None:
        self._verify_hash = verify_hash

    def resolve(self, entry: IndexEntry, search_dir: Path | None) -> Path | None:
        if search_dir is None:
            return None

        # Strategy 1: storage_name match (renamed file)
        storage_path = search_dir / entry.attributes.storage_name
        if storage_path.is_file():
            if self._verify_hash:
                self._check_hash(storage_path, entry)
            return storage_path

        # Strategy 2: original name match (non-renamed file)
        original_path = search_dir / entry.name.text
        if original_path.is_file():
            if self._verify_hash:
                self._check_hash(original_path, entry)
            return original_path

        return None
```

The resolver is passed into `plan_rollback()`, defaulting to `LocalSourceResolver()` when not specified. This keeps the core engine completely agnostic about where bytes come from.

### 2.4. Meta2 Loader

```python
def load_meta2(
    path: Path,
    *,
    recursive: bool = False,
) -> list[IndexEntry]:
    """Load and parse a _meta2.json file into a flat list of IndexEntry objects.

    Handles three input shapes:
    1. Per-file sidecar: single IndexEntry object → returns [entry].
    2. Aggregate output (directory entry with items[]): walks the tree,
       returns all file-type entries flattened.
    3. Directory path: discovers all *_meta2.json files (recursively if
       recursive=True), loads each, returns combined flat list.

    Duplicate entries from the ``duplicates`` array of each canonical entry
    are extracted and included in the returned list. Each duplicate entry
    is annotated with an ``_is_duplicate`` transient attribute (not serialized)
    set to ``True``, and an ``_canonical_storage_name`` attribute containing
    the canonical entry's ``storage_name``. The implementing agent may use
    a wrapper dataclass or parallel list instead of monkey-patching if
    that design is cleaner.

    Raises:
        IndexerConfigError: If the file is not valid JSON.
        IndexerConfigError: If schema_version is not 2. Error message:
            "Unsupported schema version in {path}: expected 2, got {version}.
             v1 sidecar files must be migrated to v2 format before rollback."
        IndexerTargetError: If the path does not exist.
    """
```

**Schema version gate:** If the parsed JSON lacks `schema_version` or has `schema_version != 2`, the loader raises `IndexerConfigError`. This is a hard failure. v1 sidecars are not supported.

**Tree flattening:** When the input is a directory entry with nested `items[]`, the loader recursively walks the tree and extracts all `type == "file"` entries into a flat list. Each entry's `file_system.relative` already encodes its position in the hierarchy, so the tree structure is preserved in the data even when flattened.

**Duplicate extraction:** For each file entry that has a `duplicates` array, the duplicates are included in the returned list with an annotation distinguishing them from canonical entries. The planner uses this annotation to determine the `action_type` and to locate the source file (duplicates share the same bytes as their canonical entry).

**Directory discovery:**

```python
def discover_meta2_files(
    directory: Path,
    *,
    recursive: bool = False,
) -> list[Path]:
    """Find all *_meta2.json files in a directory.

    Args:
        directory: The directory to search.
        recursive: When True, search subdirectories as well.
            When False (default), search only the immediate directory.

    Returns:
        Sorted list of discovered meta2 file paths.
    """
```

The `recursive` parameter defaults to `False`. Recursive discovery is opt-in via the `--recursive` CLI flag (Section 3).

### 2.5. Restore Mode: Structured vs. Flat

Rollback supports two restore modes that control how target paths are computed:

**Structured mode (default).** Uses `file_system.relative` to reconstruct the original directory hierarchy under the target root. This faithfully restores the filesystem state as it existed at index time.

**Flat mode (`flat=True`).** Ignores `file_system.relative` entirely. Restores each file using only `name.text` directly into the target directory with no subdirectory creation.

```
# Structured (default):
{target}/photos/vacation/beach.jpg    ← from file_system.relative

# Flat:
{target}/beach.jpg                    ← from name.text only
```

**When flat mode is appropriate:**

- When delivering a single file to an end user (vault use case).
- When the meta2 inputs originate from multiple indexing sessions with different index roots, making the `file_system.relative` paths incoherent relative to each other.
- When the user does not need the original directory structure and simply wants the original filenames back.

**Flat mode collision handling:** When two entries have the same `name.text`, the second file is skipped with a `WARNING` log:

```
Flat restore collision: {name.text} already exists in target (from a different entry). Skipped.
```

The user can resolve this by switching to structured mode or specifying a different target.

**Mixed-session detection and warning:** When operating in structured mode, if the entries span multiple distinct `session_id` values (excluding `None`), the planner emits a `WARNING`:

```
{n} entries span {m} distinct indexing sessions. Relative paths may not share
a common root. Restored directory tree may be incoherent. Consider using --flat
or specifying --target explicitly.
```

This warning is advisory — the operation proceeds. It alerts the user that the output might not represent any filesystem state that actually existed. The warning is NOT emitted in flat mode (where `file_system.relative` is ignored anyway).

### 2.6. Target Directory Resolution

The `target_dir` parameter in `plan_rollback()` is always an explicit `Path` — it is never `None`. The "default to parent of meta2 path" logic is a presentation-layer convenience resolved by the CLI (Section 3) and GUI (Section 4) before calling the core engine.

| Input shape | CLI default when `--target` is omitted |
|---|---|
| Single meta2 file (`/vault/yAAA.jpg_meta2.json`) | `/vault/` (parent of the file) |
| Directory of sidecars (`/vault/`) | `/vault/` (the directory itself) |
| Aggregate output file (`/output/photos_directorymeta2.json`) | `/output/` (parent of the file) |

### 2.7. Rollback Planner

```python
def plan_rollback(
    entries: list[IndexEntry],
    target_dir: Path,
    *,
    source_dir: Path | None = None,
    resolver: SourceResolver | None = None,
    verify: bool = True,
    force: bool = False,
    flat: bool = False,
    skip_duplicates: bool = False,
    restore_sidecars: bool = True,
) -> RollbackPlan:
    """Compute the full rollback plan without executing it.

    This is the primary API entry point for rollback operations.

    Args:
        entries: Flat list of IndexEntry objects from load_meta2().
        target_dir: Root directory for restored files. Created if absent.
        source_dir: Directory to search for content files. When None,
            the resolver's default search behavior applies.
        resolver: Source file locator. Defaults to LocalSourceResolver().
        verify: Compute and verify content hashes. Default True.
        force: Overwrite existing files in target directory. Default False.
        flat: When True, restore all files directly into target_dir using
            only name.text (no directory structure). Default False.
        skip_duplicates: Do not restore files from duplicates[] arrays.
        restore_sidecars: Restore absorbed sidecar metadata files from
            MetadataEntry records. Default True.

    Returns:
        A RollbackPlan describing all actions to be taken.
    """
```

**Planning algorithm:**

For each `IndexEntry` in the flat list:

1. **Classify.** Is this a canonical entry or a duplicate? (Determined by annotation from `load_meta2()`.)

2. **Locate source.** Call `resolver.resolve(entry, source_dir)`. If the entry is a duplicate, resolve using the canonical entry's `storage_name` (same bytes). If `None`, create a `RollbackAction` with `skip_reason="Source file not found"` and increment `skipped_unresolvable`.

3. **Compute target path.**
   - Structured mode: `target_dir / entry.file_system.relative`. Convert forward slashes to platform-native separators.
   - Flat mode: `target_dir / entry.name.text`.

4. **Path safety check.** If the resolved path (after normalization) would escape `target_dir` via `..` segments, reject with `skip_reason="Path traversal rejected"`.

5. **Conflict check.** If the target path already exists:
   - If `verify=True` and hashes match: `skip_reason="Already exists (same content)"`, increment `skipped_already_exists`.
   - If hashes don't match (or `verify=False`): `skip_reason="Already exists (different content)"`, increment `skipped_conflict`, unless `force=True`.
   - Flat mode collision (same `name.text` from different entries): `skip_reason="Flat restore collision"`, increment `skipped_conflict`.

6. **Create the action.** `RollbackAction(source_path, target_path, entry, action_type, ...)`.

7. **Directory actions.** For each unique parent directory in the target paths (structured mode only), create a `RollbackAction` with `action_type="mkdir"`.

8. **Duplicate actions.** If the entry has a `duplicates` array and `skip_duplicates=False`:
   - For each duplicate, compute the target path using the duplicate's `file_system.relative` (structured) or `name.text` (flat).
   - The source is the same file as the canonical entry (same bytes).
   - Create a `RollbackAction` with `action_type="duplicate_restore"`.

9. **Sidecar restoration actions.** If `restore_sidecars=True`, for each `MetadataEntry` where `origin == "sidecar"`:
   - Structured mode: compute the target path from `metadata_entry.file_system.relative`.
   - Flat mode: compute the target path from `metadata_entry.name.text`.
   - Decode the `data` field according to `metadata_entry.attributes.format`.
   - Create a `RollbackAction` with `action_type="sidecar_restore"`.

10. **Mixed-session warning.** After processing all entries, if structured mode is active (`flat=False`) and the entries contain more than one distinct `session_id` value (excluding `None`), append a warning to `plan.warnings`.

### 2.8. Rollback Executor

```python
def execute_rollback(
    plan: RollbackPlan,
    *,
    dry_run: bool = False,
    progress_callback: Callable[[ProgressEvent], None] | None = None,
    cancel_event: threading.Event | None = None,
) -> RollbackResult:
    """Execute a previously computed rollback plan.

    Processes actions in order: mkdir → restore → duplicate_restore → sidecar_restore.

    In dry-run mode, logs all actions at INFO level without performing them.

    Args:
        plan: The plan from plan_rollback().
        dry_run: Log actions without executing them.
        progress_callback: Optional callback for progress reporting (GUI).
        cancel_event: Optional threading.Event for cancellation (GUI).

    Returns:
        A RollbackResult summarizing the outcome.
    """
```

**Execution order:**

1. Create all directories (`mkdir` actions), deepest-first to avoid intermediate failures.
2. Copy all canonical files (`restore` actions).
3. Copy all duplicate files (`duplicate_restore` actions).
4. Write all restored sidecar files (`sidecar_restore` actions).

**File copy implementation:**

- Use `shutil.copy2()` for the initial copy (preserves metadata).
- After copy, explicitly set `mtime` and `atime` using `os.utime()` with the values from `entry.timestamps.modified.unix` and `entry.timestamps.accessed.unix`. The sidecar timestamps are stored as millisecond Unix timestamps; `os.utime()` expects seconds, so divide by 1000.
- `ctime` (creation time) cannot be portably set on most platforms. On Windows, `ctime` is creation time and can be set via `win32file.SetFileTime()` from the `pywin32` package — but this is a SHOULD, not a MUST. If `pywin32` is available, use it; otherwise, skip `ctime` restoration with a `DEBUG`-level log. `pywin32` MUST NOT be added as a required dependency.

**Sidecar restoration implementation:**

For each `MetadataEntry` being restored:

| `attributes.format` | Restoration action |
|---|---|
| `"json"` | `json.dumps(data, indent=2, ensure_ascii=False)` → write as UTF-8 |
| `"text"` | Write `data` as UTF-8 text |
| `"base64"` | `base64.b64decode(data)` → write as binary |
| `"lines"` | `"\n".join(data)` → write as UTF-8 text |

After writing, set timestamps using the `MetadataEntry.timestamps` fields (same `os.utime()` approach as above).

**Cancellation:** Between each action, check `cancel_event`. If set, stop processing, log the interruption, and return a partial `RollbackResult`. Files already restored remain in the target directory (non-destructive — no cleanup on cancel).

### 2.9. Hash Verification Helper

```python
def verify_file_hash(
    path: Path,
    expected: HashSet,
    algorithm: str = "md5",
) -> bool:
    """Verify a file's content hash against expected values.

    Computes the hash of the file at path and compares against the
    expected HashSet. Uses the algorithm matching the IndexEntry's
    id_algorithm for efficiency (avoids computing all hashes).

    Returns True if the hash matches, False otherwise.
    """
```

This function reuses the existing `core/hashing.hash_file()` infrastructure. It computes only the single algorithm needed for verification rather than the full multi-algorithm pass used during indexing.

### 2.10. Log Messages

| Level | Condition | Message |
|-------|-----------|---------|
| `INFO` | File restored | `Restored: {name.text} → {target_path}` |
| `INFO` | Duplicate restored | `Duplicate restored: {name.text} → {target_path} (copy of {canonical_name})` |
| `INFO` | Sidecar restored | `Sidecar restored: {sidecar_name} → {target_path}` |
| `INFO` | Directory created | `Directory created: {target_path}` |
| `INFO` | Dry-run restore | `Dry run — would restore: {name.text} → {target_path}` |
| `INFO` | Dry-run duplicate | `Dry run — would restore duplicate: {name.text} → {target_path}` |
| `INFO` | Dry-run sidecar | `Dry run — would restore sidecar: {sidecar_name} → {target_path}` |
| `DEBUG` | Skipped (same content) | `Skipped (already exists, same hash): {target_path}` |
| `WARNING` | Skipped (different content) | `Skipped (exists, different content): {target_path}` |
| `WARNING` | Flat collision | `Flat restore collision: {name.text} already exists in target (from a different entry). Skipped.` |
| `WARNING` | Source not found | `Source not found for entry: {storage_name} / {name.text} in {search_dir}` |
| `WARNING` | Hash mismatch | `Hash mismatch: {source_path} — expected {expected_md5}, got {actual_md5}` |
| `WARNING` | Path traversal | `Path traversal rejected: {relative_path}` |
| `WARNING` | Mixed sessions | `{n} entries span {m} distinct indexing sessions. Relative paths may not share a common root. Consider using --flat or specifying --target explicitly.` |
| `ERROR` | Copy failed | `Failed to restore {name.text} → {target_path}: {exception}` |
| `ERROR` | Timestamp set failed | `Failed to set timestamps on {target_path}: {exception}` |
| `INFO` | Summary | `Rollback complete: {restored} restored, {duplicates} duplicates, {sidecars} sidecars, {skipped} skipped, {failed} failed` |

### 2.11. Affected Files

| File | Nature of change |
|------|------------------|
| `src/shruggie_indexer/core/rollback.py` | **New file.** Complete rollback engine. |
| `src/shruggie_indexer/core/__init__.py` | Re-export rollback public API. |
| `src/shruggie_indexer/exceptions.py` | Add `RollbackError(IndexerError)` if needed (agent decision). |
| `tests/unit/test_rollback.py` | **New file.** Unit tests for all rollback functions. |
| `tests/fixtures/rollback-testbed/` | **New directory.** Test fixtures. |

### 2.12. Test Fixtures (`tests/fixtures/rollback-testbed/`)

```
rollback-testbed/
├── renamed/
│   ├── yA8A8C089A6A8583B24C85F5A4A41F5AC.exe
│   ├── yA8A8C089A6A8583B24C85F5A4A41F5AC.exe_meta2.json
│   ├── yBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB.txt
│   └── yBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB.txt_meta2.json
├── non-renamed/
│   ├── readme.txt
│   └── readme.txt_meta2.json
├── aggregate/
│   └── photos_directorymeta2.json   ← contains nested items[]
├── deduplicated/
│   ├── yA8A8C089A.jpg
│   └── yA8A8C089A.jpg_meta2.json   ← contains duplicates[]
├── mixed-sessions/
│   ├── yAAA.jpg                     ← session_id: "aaa...", relative: "vacation/beach.jpg"
│   ├── yAAA.jpg_meta2.json
│   ├── yBBB.mp4                     ← session_id: "bbb...", relative: "media/clips/drone.mp4"
│   ├── yBBB.mp4_meta2.json
│   ├── yCCC.txt                     ← session_id: "ccc...", relative: "notes.txt"
│   └── yCCC.txt_meta2.json
├── malformed/
│   └── bad_meta2.json               ← invalid JSON
└── v1/
    └── legacy_meta.json             ← schema_version absent
```

The meta2 JSON fixtures must contain realistic field values with valid `file_system.relative` paths, timestamps, and hashes that correspond to the fixture files' actual content. The implementing agent constructs these.

### 2.13. Unit Test Coverage

| Test class | Covers |
|---|---|
| `TestLoadMeta2` | Per-file sidecar parsing, aggregate tree flattening, directory discovery (non-recursive and recursive), v1 rejection, malformed JSON handling, duplicate extraction with annotations |
| `TestLocalSourceResolver` | Storage name match, original name match, hash verification pass/fail, not found |
| `TestPlanRollback` | Renamed files, non-renamed files, duplicates, sidecar restoration, conflict detection (same hash, different hash, force), path traversal rejection, `skip_duplicates` flag |
| `TestPlanRollbackFlat` | Flat mode target path computation, flat collision detection, duplicates in flat mode |
| `TestPlanRollbackMixedSessions` | Warning emitted when entries span multiple `session_id` values in structured mode, no warning in flat mode |
| `TestTargetDefault` | Verify core engine always receives explicit `target_dir` (CLI/GUI responsibility to resolve default) |
| `TestExecuteRollback` | Dry-run (no filesystem writes), file copy + timestamp restoration (`mtime`/`atime` via `os.utime()`), duplicate copy, sidecar decoding (json/text/base64/lines), cancellation mid-plan, error handling (copy failure) |
| `TestVerifyFileHash` | Matching hash, non-matching hash, missing file |

### 2.14. Acceptance Criteria

- `load_meta2()` correctly parses per-file sidecars, aggregate outputs, and directories of sidecars.
- `load_meta2()` raises `IndexerConfigError` for v1 sidecars with a clear message.
- `plan_rollback()` produces correct actions for renamed, non-renamed, deduplicated, and mixed scenarios.
- `plan_rollback()` rejects paths containing `..` segments.
- `plan_rollback(flat=True)` computes target paths from `name.text` without directory structure.
- `plan_rollback()` emits a mixed-session warning when entries span multiple `session_id` values in structured mode.
- `plan_rollback()` does NOT emit the mixed-session warning in flat mode.
- `execute_rollback()` creates the target directory structure matching `file_system.relative` paths (structured mode).
- `execute_rollback()` places files directly in target directory (flat mode).
- `execute_rollback()` copies files and sets `mtime`/`atime` from sidecar timestamps.
- `execute_rollback()` restores absorbed sidecar files with correct format decoding.
- `execute_rollback(dry_run=True)` logs actions without writing anything.
- Hash verification catches corrupt or mismatched files.
- Conflict resolution respects the same-hash/different-hash/force matrix.
- Flat mode collision detection works correctly.
- All unit tests pass.

---

## 3. CLI Rollback Subcommand (Priority: High)

### 3.1. Subcommand Registration

**New file:** `src/shruggie_indexer/cli/rollback.py`

The rollback subcommand is registered on the group created in Section 1:

```python
# In cli/main.py, after the group definition:
from shruggie_indexer.cli.rollback import rollback_cmd
main.add_command(rollback_cmd)
```

Or via the import in `cli/rollback.py`:

```python
from shruggie_indexer.cli.main import main

@main.command("rollback")
@click.argument("meta2_path", type=click.Path(exists=True))
@click.option("--target", "-t", type=click.Path(), default=None,
              help="Target directory for restored files. [default: parent of META2_PATH]")
# ... remaining options ...
def rollback_cmd(meta2_path, target, ...):
    """Restore files from metadata to their original names and structure."""
```

The implementing agent should choose the registration pattern that avoids circular imports. The recommended approach is to have `cli/main.py` import and register the subcommand at the bottom of the file (after the group is defined), or use Click's lazy-loading pattern.

### 3.2. CLI Interface

```
Usage: shruggie-indexer rollback [OPTIONS] META2_PATH

  Restore files from shruggie-indexer metadata to their original names
  and directory structure.

Arguments:
  META2_PATH  Path to a _meta2.json file, aggregate output file, or
              directory containing _meta2.json sidecars.

Options:
  -t, --target PATH       Target directory for restored files.
                          [default: parent directory of META2_PATH]
  --source PATH           Explicit source directory containing content files.
  --recursive             Search META2_PATH subdirectories for sidecar files
                          (only when META2_PATH is a directory).
  --flat                  Restore files using original names only, without
                          reconstructing directory structure.
  --dry-run               Preview restore operations without writing.
  --no-verify             Skip hash verification of source files.
  --force                 Overwrite existing files in target directory.
  --skip-duplicates       Do not restore files from duplicates[] arrays.
  --no-restore-sidecars   Do not restore absorbed sidecar metadata files.
  -v, --verbose           Increase verbosity (repeatable).
  -q, --quiet             Suppress non-error output.
  --log-file [PATH]       Write log to file.
  --help                  Show this message and exit.
```

**Design notes:**

- `--target` is **optional**. When omitted, defaults to the parent directory of `META2_PATH` (if `META2_PATH` is a file) or to `META2_PATH` itself (if it is a directory). The CLI resolves this before calling the core engine.
- `--recursive` is opt-in. Only meaningful when `META2_PATH` is a directory.
- `--flat` activates flat restore mode (§2.5). When active, `file_system.relative` is ignored and files are placed directly in the target using `name.text`.
- Sidecar restoration is **on by default** (`restore_sidecars=True`). The flag `--no-restore-sidecars` disables it.
- Logging options (`-v`, `-q`, `--log-file`) reuse the same `configure_logging()` infrastructure from `cli/main.py`.

### 3.3. Command Body

The CLI body follows the same pattern as the existing `index` command — thin orchestration:

```python
def rollback_cmd(meta2_path, target, source, recursive, flat, dry_run,
                 no_verify, force, skip_duplicates, no_restore_sidecars,
                 verbose, quiet, log_file):
    configure_logging(verbose=verbose, quiet=quiet, log_file=log_file)

    meta2 = Path(meta2_path)

    # 1. Resolve target default
    if target is None:
        target_dir = meta2.parent if meta2.is_file() else meta2
    else:
        target_dir = Path(target)

    # 2. Load
    entries = load_meta2(meta2, recursive=recursive)

    # 3. Plan
    plan = plan_rollback(
        entries,
        target_dir=target_dir,
        source_dir=Path(source) if source else None,
        verify=not no_verify,
        force=force,
        flat=flat,
        skip_duplicates=skip_duplicates,
        restore_sidecars=not no_restore_sidecars,
    )

    # 4. Report plan warnings
    for warning in plan.warnings:
        click.echo(f"WARNING: {warning}", err=True)

    _print_plan_summary(plan)

    # 5. Execute (or dry-run)
    result = execute_rollback(plan, dry_run=dry_run)

    # 6. Report result
    _print_result_summary(result)

    sys.exit(0 if result.failed == 0 else 1)
```

### 3.4. Exit Codes

| Code | Meaning |
|------|---------|
| 0 | All actions succeeded (or dry-run completed) |
| 1 | One or more actions failed |
| 2 | Configuration error (bad meta2 path, invalid arguments, v1 schema) |
| 3 | Target error (target directory not writable) |

These map to the existing `ExitCode` enum in `cli/main.py`.

### 3.5. Affected Files

| File | Nature of change |
|------|------------------|
| `src/shruggie_indexer/cli/rollback.py` | **New file.** Click subcommand. |
| `src/shruggie_indexer/cli/main.py` | Register `rollback_cmd` on the group. |
| `src/shruggie_indexer/cli/__init__.py` | Re-export `rollback_cmd` if appropriate. |
| `tests/integration/test_rollback_cli.py` | **New file.** CLI integration tests. |

### 3.6. Integration Test Coverage

| Test | Scenario |
|---|---|
| `test_rollback_renamed_directory` | Index with rename → rollback → verify tree matches original |
| `test_rollback_with_dedup` | Index with rename + dedup → rollback → verify all copies restored |
| `test_rollback_aggregate_output` | Rollback from aggregate output file + explicit `--source` |
| `test_rollback_flat_mode` | `--flat` restores files without directory structure |
| `test_rollback_flat_collision` | `--flat` with name collisions produces warnings and skips |
| `test_rollback_mixed_sessions_warning` | Structured mode with mixed `session_id` emits warning to stderr |
| `test_rollback_target_default_file` | Omitting `--target` for a single meta2 file defaults to its parent directory |
| `test_rollback_target_default_dir` | Omitting `--target` for a directory defaults to that directory |
| `test_rollback_dry_run` | Dry-run produces log output, no filesystem writes |
| `test_rollback_no_verify` | `--no-verify` skips hash computation |
| `test_rollback_force_overwrite` | `--force` overwrites existing target files |
| `test_rollback_skip_duplicates` | `--skip-duplicates` restores only canonical entries |
| `test_rollback_v1_rejection` | v1 sidecar input produces clear error and exit code 2 |
| `test_rollback_backward_compat` | `shruggie-indexer /path` (no subcommand) still invokes index |
| `test_rollback_timestamp_restoration` | Restored files have correct `mtime` and `atime` |

### 3.7. Acceptance Criteria

- `shruggie-indexer rollback <meta2>` restores files to the meta2 parent directory.
- `shruggie-indexer rollback <meta2> --target <dir>` restores files to the specified directory.
- `shruggie-indexer rollback <meta2> --flat` restores without directory structure.
- `shruggie-indexer rollback --help` displays the full option set including default target behavior.
- All flags work as documented.
- Exit codes are correct.
- Backward compatibility from Section 1 is preserved.

---

## 4. GUI Rollback Operation Mode (Priority: Medium)

### 4.1. Operation Type Selector Extension

Add `"Rollback"` as a fourth option in the operation type `CTkOptionMenu` dropdown on the Operations page:

| Label | Internal key | Configuration overrides |
|-------|-------------|------------------------|
| Index | `index` | Base indexing; optional EXIF extraction. |
| Meta Merge | `meta_merge` | `extract_exif=True`, `meta_merge=True`. |
| Meta Merge Delete | `meta_merge_delete` | `extract_exif=True`, `meta_merge=True`, `meta_merge_delete=True`. |
| **Rollback** | `rollback` | Entirely different pipeline — see below. |

### 4.2. UI Morphing When Rollback Is Selected

When the user selects "Rollback" from the operation type dropdown, the Operations page's collapsible card sections morph to present rollback-specific controls. The existing cards (Target, Options, Output) are repurposed or replaced:

**Card 1 — Operation (always expanded, unchanged):** The dropdown itself. No changes.

**Card 2 — Source (replaces "Target"):**

| Control | Widget | Description |
|---|---|---|
| Meta2 path | `CTkEntry` + Browse buttons | Path to a `_meta2.json` file or directory of sidecars. Browse buttons follow the same dual-button pattern as the indexer target (File… / Folder…). |
| Source path | `CTkEntry` + Browse button (folder only) | Optional explicit source directory for content files. When empty, the engine searches adjacent to the meta2 file. |
| Recursive | `CTkCheckBox` | When meta2 path is a directory, search subdirectories for sidecar files. Disabled when meta2 path is a file. |

**Card 3 — Options (replaces "Options"):**

| Control | Widget | Default | Description |
|---|---|---|---|
| Flat restore | `CTkCheckBox` | ☐ Unchecked | Restore files using original names only, without reconstructing directory structure. |
| Verify hashes | `CTkCheckBox` | ✓ Checked | Verify content hashes before restoring. |
| Force overwrite | `CTkCheckBox` | ☐ Unchecked | Overwrite existing files in target directory. |
| Skip duplicates | `CTkCheckBox` | ☐ Unchecked | Do not restore files from `duplicates[]` arrays. |
| Restore sidecars | `CTkCheckBox` | ✓ Checked | Restore absorbed metadata sidecar files. |

**Card 4 — Target (replaces "Output"):**

| Control | Widget | Description |
|---|---|---|
| Target directory | `CTkEntry` + Browse button (folder only) | The root directory for restored files. When empty, defaults to the parent of the meta2 path (displayed as placeholder text). |

The card is labeled "Target" (not "Output") because rollback does not produce JSON output files. The output mode selector (Single file / Multi-file / View only) is hidden when rollback is active.

### 4.3. Reconcile Controls

`_reconcile_controls()` must handle the rollback state:

- When `operation_type == "rollback"`:
  - The destructive operation indicator shows **green** (non-destructive — rollback only copies).
  - The START button label remains "▶ START".
  - The START button is disabled if the meta2 path field is empty. (Target directory may be empty — it defaults to meta2 parent.)
  - All indexing-specific controls (ID algorithm, SHA-512, EXIF, rename) are hidden or disabled.
  - The "Recursive" checkbox is disabled when the meta2 path points to a file (not a directory).

### 4.4. Background Job

The rollback job follows the same threading pattern as the indexing job:

```python
def _background_rollback(self, meta2_path, target_dir, source_dir, options):
    meta2 = Path(meta2_path)

    # Resolve target default (same logic as CLI)
    if not target_dir:
        resolved_target = meta2.parent if meta2.is_file() else meta2
    else:
        resolved_target = Path(target_dir)

    entries = load_meta2(meta2, recursive=options.recursive)
    plan = plan_rollback(entries, resolved_target, ...)
    result = execute_rollback(
        plan,
        progress_callback=self._progress_queue.put,
        cancel_event=self._cancel_event,
    )
    return result
```

Progress events are forwarded through the same `ProgressEvent` mechanism and displayed on the progress panel. The progress bar shows fraction complete based on `actions_completed / total_actions`.

### 4.5. Post-Job Display

After a rollback job completes:

- The **Output tab** displays a human-readable text summary of what was restored, skipped, and failed (not JSON — rollback does not produce index output).
- The **Log tab** displays the full log output as with indexing operations.
- Plan warnings (e.g., mixed-session warning) are displayed in the output panel before the summary.

### 4.6. Session Persistence

The rollback-specific control values are persisted in the session file under a `rollback_state` key within the `operations_state` object:

```json
{
  "operations_state": {
    "operation_type": "rollback",
    "rollback_state": {
      "meta2_path": "/path/to/sidecars/",
      "source_path": "",
      "target_path": "",
      "recursive": false,
      "flat": false,
      "verify": true,
      "force": false,
      "skip_duplicates": false,
      "restore_sidecars": true
    }
  }
}
```

When `target_path` is empty in the session, the GUI displays placeholder text showing the default (parent of meta2 path) and passes `None` / empty string to the background job, which triggers the default resolution logic.

### 4.7. Affected Files

| File | Nature of change |
|------|------------------|
| `src/shruggie_indexer/gui/app.py` | Extend `OperationsPage` with rollback mode UI, reconcile logic, background job. |

### 4.8. Acceptance Criteria

- Selecting "Rollback" from the dropdown morphs the Operations page to show rollback-specific controls.
- Selecting any other operation type reverts the page to its normal indexing layout.
- The rollback job runs in a background thread with progress reporting and cancellation support.
- All rollback-specific control states persist across application sessions.
- The destructive operation indicator shows green for rollback.
- The START button is disabled when the meta2 path field is empty.
- Placeholder text in the target field shows the default (meta2 parent) when empty.
- Plan warnings (mixed sessions, etc.) appear in the output panel.

---

## 5. Public API, Documentation, Spec Amendments, and Changelog (Priority: High)

This section MUST be executed last, after Sections 1–4 are complete and verified.

### 5.1. Public API Surface

Add rollback symbols to `src/shruggie_indexer/__init__.py`:

```python
from shruggie_indexer.core.rollback import (
    RollbackPlan,
    RollbackAction,
    RollbackStats,
    RollbackResult,
    SourceResolver,
    LocalSourceResolver,
    load_meta2,
    discover_meta2_files,
    plan_rollback,
    execute_rollback,
    verify_file_hash,
)
```

Add all names to `__all__`.

### 5.2. Documentation Updates

| File | Change |
|------|--------|
| `docs/user-guide/cli-reference.md` | Add `rollback` subcommand section with all options, default behaviors (including optional `--target`), and examples covering structured, flat, and single-file use cases. Update the top-level command description to reflect the subcommand group structure. |
| `docs/user-guide/gui.md` | Add "Rollback Operation" section describing the morphed UI, card layout, and rollback-specific controls. |
| `docs/user-guide/python-api.md` | Add rollback API section: `load_meta2()`, `plan_rollback()`, `execute_rollback()`, data classes, `SourceResolver` protocol, `LocalSourceResolver` default, `verify_file_hash()`. Include vault integration example showing `flat=True` for single-file delivery. |
| `docs/user-guide/rollback.md` | **New file.** Dedicated rollback guide with scenario walkthroughs: single renamed file, renamed directory, deduplicated files, aggregate output, non-renamed files, mixed-session chimera with warning, flat mode, default target behavior, vault delivery use case. |
| `docs/index.md` | Add rollback to Quick Links. |

### 5.3. Specification Amendments

| Section | Amendment type | Description |
|---------|---------------|-------------|
| §3.2 (Source Package Layout) | Addition | Add `core/rollback.py` and `cli/rollback.py` to the directory tree. |
| §4.1 (Processing Pipeline) | Addition | Add note that the rollback pipeline is a separate processing path invoked via the `rollback` subcommand, not a stage of the indexing pipeline. |
| §6.10 (File Rename) | Addition | Cross-reference the rollback feature as the mechanism for reversing rename operations. Update the "Rename implies in-place output" section to note that in-place sidecars serve as the rollback manifest. |
| §8.1 (Command Structure) | Revision | Update from single command to subcommand group. Document `index` (default) and `rollback` subcommands. Document `DefaultGroup` backward compatibility mechanism. |
| §8 (new subsection) | Addition | Full CLI reference for `shruggie-indexer rollback`: arguments, options (including optional `--target` with default, `--flat`, `--recursive`), default behaviors, exit codes. |
| §9.1 (Public API Surface) | Addition | Add all rollback symbols to the `__all__` listing. |
| §10.2 (Window Layout) | Addition | Document the Rollback operation type in the operation type selector table. Describe the UI morphing behavior. |
| New §6.11 (Rollback Operations) | Addition | Full behavioral contract: inputs (single sidecar, aggregate, directory), restore modes (structured vs. flat), target directory resolution (explicit vs. default-to-parent), timestamp restoration, sidecar reconstruction, conflict resolution, mixed-session detection and warning, `SourceResolver` protocol, error handling. |
| §18.1.2 (Rename Revert Operation) | Revision | Change status from "future consideration" to "**Implemented**" with cross-reference to §6.11. |

### 5.4. Changelog

Add to `CHANGELOG.md` under the appropriate version heading:

```markdown
### Added
- **Rollback feature** — Restore files from `_meta2.json` sidecar metadata to
  their original filenames, directory structure, and timestamps. Supports renamed
  files, deduplicated files (restores all copies), and absorbed sidecar metadata
  reconstruction. Available via CLI (`shruggie-indexer rollback`), GUI (Rollback
  operation type), and Python API (`plan_rollback()`, `execute_rollback()`).
- **Flat restore mode** (`--flat`) — Restore files using original names only,
  without reconstructing directory structure. Useful for vault delivery and
  mixed-session rollback scenarios.
- **Optional target directory** — The `--target` flag defaults to the parent
  directory of the input meta2 file when omitted, enabling single-command
  in-place rollback: `shruggie-indexer rollback yABC.jpg_meta2.json`.
- **CLI subcommand group** — The CLI now uses a subcommand structure.
  `shruggie-indexer index` is the explicit form of the default indexing command.
  `shruggie-indexer rollback` provides the new rollback capability. Bare
  `shruggie-indexer <path>` remains fully backward-compatible.
- **Timestamp restoration** — Rollback sets `mtime` and `atime` on restored files
  from sidecar metadata. On Windows with `pywin32` available, `ctime` (creation
  time) is also restored.
- **Pluggable source resolution** — The `SourceResolver` protocol enables
  downstream tools (e.g., `shruggie-vault`) to provide custom file retrieval
  logic for rollback operations.
- **Mixed-session detection** — When rollback processes entries from multiple
  indexing sessions in structured mode, a warning is emitted advising the user
  that relative paths may not share a common root.
```

### 5.5. Affected Files

| File | Nature of change |
|------|------------------|
| `src/shruggie_indexer/__init__.py` | Add rollback imports and `__all__` entries. |
| `shruggie-indexer-spec.md` | Amendments per §5.3 table. |
| `CHANGELOG.md` | New entries per §5.4. |
| `docs/user-guide/cli-reference.md` | Subcommand group + rollback subcommand documentation. |
| `docs/user-guide/gui.md` | Rollback operation type documentation. |
| `docs/user-guide/python-api.md` | Rollback API documentation with vault example. |
| `docs/user-guide/rollback.md` | **New file.** Dedicated rollback guide. |
| `docs/index.md` | Quick Links update. |

### 5.6. Acceptance Criteria

- All rollback symbols are importable from `shruggie_indexer`.
- `docs/user-guide/rollback.md` exists with comprehensive scenario walkthroughs including the mixed-session chimera case, flat mode, and default target behavior.
- The spec accurately describes the implemented behavior including both restore modes and optional target.
- The changelog reflects all user-facing changes.
- `mkdocs build` succeeds with the new documentation pages.
