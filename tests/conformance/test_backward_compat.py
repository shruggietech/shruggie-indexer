"""Backward compatibility validation skeleton for shruggie-indexer.

Scaffolds the v1-to-v2 backward compatibility framework defined in §14.6.
All tests are skipped until reference data is generated by running the
original MakeIndex against known inputs and converting the output to v2
format.

Reference data files are expected at:
    tests/fixtures/reference/{test_name}.v2.json

The reference directory is created with a .gitkeep placeholder.
"""

from __future__ import annotations

import json
from pathlib import Path

import pytest

REFERENCE_DIR = Path(__file__).resolve().parent.parent / "fixtures" / "reference"


def _load_reference(name: str) -> dict:
    """Load a reference v2 JSON fixture by test name."""
    path = REFERENCE_DIR / f"{name}.v2.json"
    return json.loads(path.read_text(encoding="utf-8"))


# ---------------------------------------------------------------------------
# Test 1: Hash identity
# ---------------------------------------------------------------------------


@pytest.mark.skip(reason="Reference data not yet generated")
def test_hash_identity_matches_reference() -> None:
    """Port's ``id`` field must match the reference entry's ``id``.

    Validates that the hash-based identity produced by the Python port
    is semantically equivalent to the value the original MakeIndex would
    produce for the same input file (accounting for v1-to-v2 restructuring).
    """
    ref = _load_reference("hash_identity")
    # TODO: run index_path on the same input and compare id fields.
    assert ref["id"] is not None


# ---------------------------------------------------------------------------
# Test 2: Name hash
# ---------------------------------------------------------------------------


@pytest.mark.skip(reason="Reference data not yet generated")
def test_name_hash_matches_reference() -> None:
    """Port's ``name.hashes`` must match the reference entry's name hashes.

    Validates that NFC normalization (DEV-15) and uppercase hex formatting
    produce identical name hash values.
    """
    ref = _load_reference("name_hash")
    assert ref["name"]["hashes"]["md5"] is not None


# ---------------------------------------------------------------------------
# Test 3: Directory identity
# ---------------------------------------------------------------------------


@pytest.mark.skip(reason="Reference data not yet generated")
def test_directory_identity_matches_reference() -> None:
    """Port's two-layer directory ``id`` — ``hash(hash(name) + hash(parent))``
    — must match the reference.

    Validates correct implementation of the directory identity scheme where
    the id depends on both the directory's own name and its parent's name.
    """
    ref = _load_reference("directory_identity")
    assert ref["id"] is not None


# ---------------------------------------------------------------------------
# Test 4: Timestamp equivalence
# ---------------------------------------------------------------------------


@pytest.mark.skip(reason="Reference data not yet generated")
def test_timestamps_within_tolerance() -> None:
    """Port's timestamps must be within ±1 second (ISO) and ±1000 milliseconds
    (Unix) of the reference.

    The tolerance accounts for DEV-07 (direct stat derivation instead of
    round-trip through .NET DateTime).
    """
    ref = _load_reference("timestamps")
    # TODO: compare iso fields within ±1s, unix fields within ±1000 ms.
    assert ref["timestamps"]["created"]["unix"] is not None


# ---------------------------------------------------------------------------
# Test 5: Sidecar discovery
# ---------------------------------------------------------------------------


@pytest.mark.skip(reason="Reference data not yet generated")
def test_sidecar_discovery_matches_reference() -> None:
    """Port must discover the same set of sidecar files as the reference.

    Validates that the 10-type sidecar detection logic finds identical
    sidecars for a given primary file.
    """
    ref = _load_reference("sidecar_discovery")
    assert "metadata" in ref


# ---------------------------------------------------------------------------
# Test 6: Sidecar content
# ---------------------------------------------------------------------------


@pytest.mark.skip(reason="Reference data not yet generated")
def test_sidecar_content_matches_reference() -> None:
    """Parsed sidecar metadata must match the reference entry's metadata
    content.

    Validates that text, JSON, and binary sidecar parsing produces
    semantically equivalent MetadataEntry objects.
    """
    ref = _load_reference("sidecar_content")
    assert ref["metadata"] is not None
