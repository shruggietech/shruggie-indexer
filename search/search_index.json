{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"shruggie-indexer","text":"<p>A Python reimplementation of the <code>MakeIndex</code> function from the original PowerShell-based pslib library. <code>shruggie-indexer</code> produces structured JSON index entries for files and directories \u2014 capturing identity hashes, timestamps, EXIF metadata, sidecar metadata, and filesystem attributes in the v2 schema format.</p>"},{"location":"#documentation-sections","title":"Documentation Sections","text":"<ul> <li>Schema Reference \u2014 Canonical v2 JSON Schema definition, type descriptions, and validation examples.</li> <li>Porting Reference \u2014 Reference materials from the original PowerShell implementation: dependency catalogs, operations catalog, v1 schema, and the MetadataFileParser configuration object.</li> <li>User Guide \u2014 Installation, quick start, configuration reference, and changelog.</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>GitHub Repository</li> <li>Technical Specification</li> <li>V2 JSON Schema (canonical)</li> </ul>"},{"location":"porting-reference/","title":"Porting Reference","text":"<p>This section contains reference materials derived from the original PowerShell implementation of <code>MakeIndex</code>. These documents inform the Python port but are not part of the runtime codebase. They are read-only reference artifacts committed for traceability and to support AI implementation agents during sprint execution.</p>"},{"location":"porting-reference/#operations-catalog","title":"Operations Catalog","text":"<ul> <li>MakeIndex Operations Catalog \u2014 Categorized inventory of all logical operations in the original <code>MakeIndex</code> and its dependency tree, mapped to recommended Python modules.</li> </ul>"},{"location":"porting-reference/#configuration-reference","title":"Configuration Reference","text":"<ul> <li>MetadataFileParser Object \u2014 Isolated PowerShell script containing the complete <code>$global:MetadataFileParser</code> object definition. Source of truth for sidecar metadata file discovery and classification patterns.</li> </ul>"},{"location":"porting-reference/#dependency-catalogs","title":"Dependency Catalogs","text":"<p>Each catalog documents a single function from the original pslib library that <code>MakeIndex</code> depends on \u2014 its parameters, internal sub-functions, external calls, and behavioral contract.</p> Function Catalog Status in Port MakeIndex MakeIndex_DependencyCatalog.md Top-level function being ported. Base64DecodeString Base64DecodeString_DependencyCatalog.md Eliminated \u2014 exiftool arguments passed directly. Date2UnixTime Date2UnixTime_DependencyCatalog.md Eliminated \u2014 timestamps derived from stat results. DirectoryId DirectoryId_DependencyCatalog.md Ported to <code>core/hashing.py</code>. FileId FileId_DependencyCatalog.md Ported to <code>core/hashing.py</code>. MetaFileRead MetaFileRead_DependencyCatalog.md Ported to <code>core/sidecar.py</code>. TempOpen TempOpen_DependencyCatalog.md Eliminated \u2014 replaced by <code>tempfile</code>. TempClose TempClose_DependencyCatalog.md Eliminated \u2014 replaced by context manager cleanup. Vbs Vbs_DependencyCatalog.md Replaced by Python <code>logging</code> framework."},{"location":"porting-reference/#v1-output-schema","title":"V1 Output Schema","text":"<ul> <li>MakeIndex_OutputSchema.json \u2014 The original v1 output schema definition. Retained as a porting reference only \u2014 the port targets the v2 schema.</li> </ul>"},{"location":"porting-reference/#v1-output-examples","title":"V1 Output Examples","text":"<p>The v1-examples/ directory contains real-world output files from the original <code>MakeIndex</code> function:</p> <ul> <li>apktool.jar_meta.json</li> <li>exiftool.exe_meta.json</li> <li>flashplayer.exe_meta.json</li> <li>SearchMyFiles.chm_meta.json</li> </ul>"},{"location":"porting-reference/Base64DecodeString_DependencyCatalog/","title":"Base64DecodeString \u2014 Dependency Catalog","text":"<p>Source: <code>main.ps1</code>, line 764 Purpose: Decodes a Base64-encoded string into plaintext with optional URL decoding and configurable encoding type Audience: AI-first, Human-second  </p>"},{"location":"porting-reference/Base64DecodeString_DependencyCatalog/#1-external-pslib-functions-called","title":"1. External PsLib Functions Called","text":"Function Defined At Called From Purpose <code>Vbs</code> main.ps1:16412 Top-level body Verbose/logging output handler. Called with <code>-Caller</code>, <code>-Status</code> (e/w), <code>-Message</code>, <code>-Verbosity</code> <p>This function has a minimal external dependency footprint. It only calls <code>Vbs</code> for error/warning logging (e.g., empty input string, unknown encoding type).</p>"},{"location":"porting-reference/Base64DecodeString_DependencyCatalog/#2-external-variables-loaded","title":"2. External Variables Loaded","text":"Variable Defined At Type Description (none) \u2014 \u2014 This function does not reference any script-level or global variables. All state is derived from its own parameters."},{"location":"porting-reference/Base64DecodeString_DependencyCatalog/#3-external-binaries-executables-invoked","title":"3. External Binaries / Executables Invoked","text":"Binary Notes (none) This function is entirely .NET-based and does not invoke any external executables."},{"location":"porting-reference/Base64DecodeString_DependencyCatalog/#4-parameters","title":"4. Parameters","text":"Parameter Type Alias(es) Default Description <code>Help</code> <code>[Switch]</code> <code>h</code> <code>$false</code> Print detailed help text and return <code>InputString</code> <code>[System.String]</code> <code>i</code>, <code>in</code>, <code>str</code>, <code>string</code> <code>$null</code> The Base64-encoded string to decode <code>Encoding</code> <code>[System.String]</code> <code>e</code>, <code>encode</code> <code>UTF8</code> Encoding type: <code>UTF8</code> or <code>ASCII</code>. Unknown values fall back to UTF8 with a warning <code>UrlDecode</code> <code>[System.Boolean]</code> <code>u</code> <code>$false</code> If <code>$true</code>, the decoded output is additionally passed through <code>[System.Web.HttpUtility]::UrlDecode()</code> <code>Verbosity</code> <code>[System.Boolean]</code> <code>v</code> <code>$true</code> Controls whether verbose/log messages are printed to the console"},{"location":"porting-reference/Base64DecodeString_DependencyCatalog/#5-internal-logic-summary","title":"5. Internal Logic Summary","text":"<p>The function uses a numeric \"OpsCode\" pattern to select the correct decoding path. The OpsCode is computed by summing two values: one based on the <code>Encoding</code> parameter (0 for UTF8, 1 for ASCII) and one based on the <code>UrlDecode</code> parameter (0 for <code>$false</code>, 10 for <code>$true</code>). The resulting OpsCode determines which of four branches executes:</p> OpsCode Encoding UrlDecode Action 0 UTF8 No <code>[System.Text.Encoding]::UTF8.GetString(FromBase64String(...))</code> 1 ASCII No <code>[System.Text.Encoding]::ASCII.GetString(FromBase64String(...))</code> 10 UTF8 Yes UTF8 decode \u2192 <code>[System.Web.HttpUtility]::UrlDecode(...)</code> 11 ASCII Yes ASCII decode \u2192 <code>[System.Web.HttpUtility]::UrlDecode(...)</code>"},{"location":"porting-reference/Base64DecodeString_DependencyCatalog/#6-internal-sub-functions","title":"6. Internal Sub-Functions","text":"<p>This function defines no internal sub-functions.</p>"},{"location":"porting-reference/Base64DecodeString_DependencyCatalog/#7-net-types-and-methods-used","title":"7. .NET Types and Methods Used","text":"Type / Method Usage <code>[System.Convert]::FromBase64String()</code> Core Base64 \u2192 byte-array conversion <code>[System.Text.Encoding]::UTF8.GetString()</code> Byte-array \u2192 UTF8 string conversion <code>[System.Text.Encoding]::ASCII.GetString()</code> Byte-array \u2192 ASCII string conversion <code>[System.Web.HttpUtility]::UrlDecode()</code> URL-decoding of the decoded string output"},{"location":"porting-reference/Base64DecodeString_DependencyCatalog/#8-powershell-built-in-cmdlets-used","title":"8. PowerShell Built-in Cmdlets Used","text":"Cmdlet Usage Context <code>Get-Help</code> Displaying function help when <code>-Help</code> is specified"},{"location":"porting-reference/Base64DecodeString_DependencyCatalog/#9-return-value","title":"9. Return Value","text":"<p>Returns a <code>[System.String]</code> containing the decoded plaintext. Returns nothing (implicit <code>$null</code>) if the input string is empty.</p>"},{"location":"porting-reference/Base64DecodeString_DependencyCatalog/#10-call-graph","title":"10. Call Graph","text":"<pre><code>Base64DecodeString\n\u251c\u2500\u2500 [validates InputString is non-empty]\n\u2502   \u2514\u2500\u2500 Vbs \u25c4\u2500\u2500 external pslib (on error)\n\u251c\u2500\u2500 [validates Encoding parameter]\n\u2502   \u2514\u2500\u2500 Vbs \u25c4\u2500\u2500 external pslib (on unknown encoding warning)\n\u251c\u2500\u2500 [computes OpsCode from Encoding + UrlDecode]\n\u2514\u2500\u2500 [executes decode branch based on OpsCode]\n    \u251c\u2500\u2500 (OpsCode=0)  \u2192 UTF8 decode\n    \u251c\u2500\u2500 (OpsCode=1)  \u2192 ASCII decode\n    \u251c\u2500\u2500 (OpsCode=10) \u2192 UTF8 decode + UrlDecode\n    \u2514\u2500\u2500 (OpsCode=11) \u2192 ASCII decode + UrlDecode\n</code></pre>"},{"location":"porting-reference/Date2UnixTime_DependencyCatalog/","title":"Date2UnixTime \u2014 Dependency Catalog","text":"<p>Source: <code>main.ps1</code>, line 2517 Purpose: Converts a formatted date string to a Unix timestamp (milliseconds since epoch) with optional or auto-detected format codes Audience: AI-first, Human-second  </p>"},{"location":"porting-reference/Date2UnixTime_DependencyCatalog/#1-external-pslib-functions-called","title":"1. External PsLib Functions Called","text":"Function Defined At Called From Purpose <code>Date2FormatCode</code> main.ps1:2374 Top-level body Attempts to determine a date-time format code from a raw date string. Called when no explicit <code>-Format</code> parameter is provided. Returns a format code string or <code>$null</code> <code>Vbs</code> main.ps1:16412 Top-level body Verbose/logging output handler. Called with <code>-Caller</code>, <code>-Status</code> (e), <code>-Message</code>, <code>-Verbosity</code>"},{"location":"porting-reference/Date2UnixTime_DependencyCatalog/#dependency-note-date2formatcode","title":"Dependency Note: <code>Date2FormatCode</code>","text":"<p><code>Date2FormatCode</code> is a separate top-level pslib function (defined at main.ps1:2374) that analyzes the structure of a date string and returns a matching .NET date-time format code. It is the primary means by which <code>Date2UnixTime</code> auto-detects the format of an input date string when no explicit <code>-Format</code> is specified. If <code>Date2FormatCode</code> fails to detect a format, <code>Date2UnixTime</code> falls back to its own internal format-guessing logic via the <code>Date2UnixTimeSquash</code> \u2192 <code>Date2UnixTimeCountDigits</code> \u2192 <code>Date2UnixTimeFormatCode</code> chain.</p>"},{"location":"porting-reference/Date2UnixTime_DependencyCatalog/#2-external-variables-loaded","title":"2. External Variables Loaded","text":"Variable Defined At Type Description (none) \u2014 \u2014 This function does not reference any script-level or global variables. All state is derived from its own parameters."},{"location":"porting-reference/Date2UnixTime_DependencyCatalog/#3-external-binaries-executables-invoked","title":"3. External Binaries / Executables Invoked","text":"Binary Notes (none) This function is entirely .NET-based and does not invoke any external executables."},{"location":"porting-reference/Date2UnixTime_DependencyCatalog/#4-parameters","title":"4. Parameters","text":"Parameter Type Alias(es) Default Description <code>Date</code> <code>[System.String]</code> <code>d</code>, <code>i</code>, <code>in</code>, <code>inputdate</code> <code>$null</code> The date string to convert (e.g., <code>\"2021-12-31 23:59:59\"</code>) <code>Format</code> <code>[System.String]</code> <code>f</code>, <code>formatstring</code> <code>$null</code> An explicit .NET date-time format code (e.g., <code>\"yyyy-MM-dd HH:mm:ss\"</code>). If omitted, the function auto-detects the format <code>Help</code> <code>[Switch]</code> <code>h</code> <code>$false</code> Print detailed help text and return <code>Verbosity</code> <code>[System.Boolean]</code> <code>v</code> <code>$true</code> Controls whether verbose/log messages are printed to the console"},{"location":"porting-reference/Date2UnixTime_DependencyCatalog/#5-internal-sub-functions-defined-within-date2unixtime","title":"5. Internal Sub-Functions (Defined Within Date2UnixTime)","text":"Function Line Purpose <code>Date2UnixTimeCountDigits</code> main.ps1:2577 Counts the number of numeric characters (digits) in the input date string using regex matching <code>Date2UnixTimeFormatCode</code> main.ps1:2595 Maps a digit count (4\u201320) to a .NET date-time format code string via a switch statement. Returns <code>$null</code> for out-of-range counts <code>Date2UnixTimeSquash</code> main.ps1:2626 Strips all non-numeric characters from the input date string using regex replacement (<code>-replace '[^\\d]', ''</code>)"},{"location":"porting-reference/Date2UnixTime_DependencyCatalog/#6-internal-logic-summary","title":"6. Internal Logic Summary","text":"<p>The function follows a three-stage process:</p> <p>Stage 1 \u2014 Input Validation: Checks that a non-empty <code>-Date</code> parameter was provided. Returns an error via <code>Vbs</code> if missing.</p> <p>Stage 2 \u2014 Format Code Resolution: If an explicit <code>-Format</code> is provided, it is used directly and the date string is passed through unchanged. Otherwise, the function first attempts format detection via the external <code>Date2FormatCode</code> function. If that returns <code>$null</code>, the function falls back to its own internal pipeline: the date string is stripped of non-numeric characters (<code>Date2UnixTimeSquash</code>), digits are counted (<code>Date2UnixTimeCountDigits</code>), and the count is mapped to a format code (<code>Date2UnixTimeFormatCode</code>). Additional edge-case handling includes rejecting dates with fewer than 4 digits, truncating dates longer than 20 digits, and trimming odd-count digit strings by one character to produce an even count.</p> <p>Stage 3 \u2014 Conversion: The resolved date string and format code are passed to <code>[DateTimeOffset]::ParseExact()</code> and the result is converted to Unix time in milliseconds via <code>.ToUnixTimeMilliseconds()</code>.</p>"},{"location":"porting-reference/Date2UnixTime_DependencyCatalog/#7-net-types-and-methods-used","title":"7. .NET Types and Methods Used","text":"Type / Method Usage <code>[DateTimeOffset]::ParseExact()</code> Parses the date string using the resolved format code <code>.ToUnixTimeMilliseconds()</code> Converts the parsed <code>DateTimeOffset</code> to Unix epoch milliseconds <code>[int64]</code> Cast for the final return value"},{"location":"porting-reference/Date2UnixTime_DependencyCatalog/#8-powershell-built-in-cmdlets-used","title":"8. PowerShell Built-in Cmdlets Used","text":"Cmdlet Usage Context <code>Get-Help</code> Displaying function help when <code>-Help</code> is specified"},{"location":"porting-reference/Date2UnixTime_DependencyCatalog/#9-return-value","title":"9. Return Value","text":"<p>Returns an <code>[int64]</code> representing the Unix timestamp in milliseconds since the Unix epoch (1970-01-01T00:00:00Z). Returns nothing (implicit <code>$null</code>) if the input date is empty or has fewer than 4 numeric characters.</p>"},{"location":"porting-reference/Date2UnixTime_DependencyCatalog/#10-call-graph","title":"10. Call Graph","text":"<pre><code>Date2UnixTime\n\u251c\u2500\u2500 [validates Date parameter is non-empty]\n\u2502   \u2514\u2500\u2500 Vbs \u25c4\u2500\u2500 external pslib (on error)\n\u251c\u2500\u2500 [Format code resolution]\n\u2502   \u251c\u2500\u2500 (Format provided) \u2192 use as-is\n\u2502   \u2514\u2500\u2500 (Format not provided)\n\u2502       \u251c\u2500\u2500 Date2FormatCode \u25c4\u2500\u2500 external pslib\n\u2502       \u2514\u2500\u2500 (Date2FormatCode returned $null) \u2192 fallback:\n\u2502           \u251c\u2500\u2500 Date2UnixTimeSquash (internal)\n\u2502           \u251c\u2500\u2500 Date2UnixTimeCountDigits (internal)\n\u2502           \u2502   \u2514\u2500\u2500 Vbs \u25c4\u2500\u2500 external pslib (on &lt;4 digits error)\n\u2502           \u2514\u2500\u2500 Date2UnixTimeFormatCode (internal)\n\u2514\u2500\u2500 [DateTimeOffset]::ParseExact() \u2192 .ToUnixTimeMilliseconds()\n</code></pre>"},{"location":"porting-reference/DirectoryId_DependencyCatalog/","title":"DirectoryId \u2014 Dependency Catalog","text":"<p>Source: <code>main.ps1</code>, line 2819 Purpose: Generates hash-based unique identifiers for directories by combining hashes of the directory name and its parent directory name Audience: AI-first, Human-second  </p>"},{"location":"porting-reference/DirectoryId_DependencyCatalog/#1-external-pslib-functions-called","title":"1. External PsLib Functions Called","text":"Function Defined At Called From Purpose <code>Vbs</code> main.ps1:16412 Top-level body and <code>DirectoryId-ResolvePath</code> Verbose/logging output handler. Called with <code>-Caller</code>, <code>-Status</code> (i/e), <code>-Message</code>, <code>-Verbosity</code> <p>This function has a minimal external dependency footprint. It only calls <code>Vbs</code> for informational logging and error reporting (missing directory, non-existent directory, empty input in path resolution).</p>"},{"location":"porting-reference/DirectoryId_DependencyCatalog/#2-external-variables-loaded","title":"2. External Variables Loaded","text":"Variable Defined At Type Description (none) \u2014 \u2014 This function does not reference any script-level or global variables. All state is derived from its own parameters and the filesystem."},{"location":"porting-reference/DirectoryId_DependencyCatalog/#3-external-binaries-executables-invoked","title":"3. External Binaries / Executables Invoked","text":"Binary Notes (none) This function is entirely .NET-based and does not invoke any external executables."},{"location":"porting-reference/DirectoryId_DependencyCatalog/#4-parameters","title":"4. Parameters","text":"Parameter Type Alias(es) Default Description <code>Directory</code> <code>[System.String]</code> <code>d</code>, <code>dir</code>, <code>p</code>, <code>path</code> <code>$null</code> The full path to the target directory. Mandatory unless <code>-Here</code> is <code>$true</code> <code>Here</code> <code>[System.Boolean]</code> (none) <code>$false</code> If <code>$true</code>, the current working directory (<code>$PWD</code>) is used instead of <code>-Directory</code> <code>OutputObject</code> <code>[Switch]</code> <code>o</code> <code>$false</code> Return a <code>[PSCustomObject]</code> with all properties instead of a single hash string <code>OutputJson</code> <code>[Switch]</code> <code>j</code> <code>$false</code> Return a JSON-formatted string of the full result object <code>Verbosity</code> <code>[System.Boolean]</code> <code>v</code> <code>$false</code> Controls whether verbose/log messages are printed to the console"},{"location":"porting-reference/DirectoryId_DependencyCatalog/#5-internal-sub-functions-defined-within-directoryid","title":"5. Internal Sub-Functions (Defined Within DirectoryId)","text":"Function Line Purpose Nesting <code>DirectoryId-GetName</code> main.ps1:2939 Extracts the leaf name from a directory path using <code>[System.IO.Path]::GetFileName()</code>. Returns <code>$null</code> for root-level paths Top-level internal <code>DirectoryId-HashString</code> main.ps1:2963 Dispatcher function that routes hashing requests to the appropriate algorithm-specific sub-function based on a <code>-Type</code> parameter (<code>MD5</code>, <code>SHA1</code>, <code>SHA256</code>, <code>SHA512</code>) Top-level internal <code>DirectoryId-HashString-Md5</code> main.ps1:2973 Hashes a string using <code>[System.Security.Cryptography.MD5]::Create()</code>. Returns the null-hash constant <code>D41D8CD98F00B204E9800998ECF8427E</code> for empty/null inputs Nested inside <code>DirectoryId-HashString</code> <code>DirectoryId-HashString-Sha1</code> main.ps1:2993 Hashes a string using <code>[System.Security.Cryptography.SHA1]::Create()</code>. Returns the null-hash constant for empty/null inputs Nested inside <code>DirectoryId-HashString</code> <code>DirectoryId-HashString-Sha256</code> main.ps1:3013 Hashes a string using <code>[System.Security.Cryptography.SHA256]::Create()</code>. Returns the null-hash constant for empty/null inputs Nested inside <code>DirectoryId-HashString</code> <code>DirectoryId-HashString-Sha512</code> main.ps1:3033 Hashes a string using <code>[System.Security.Cryptography.SHA512]::Create()</code>. Returns the null-hash constant for empty/null inputs Nested inside <code>DirectoryId-HashString</code> <code>DirectoryId-ParentName</code> main.ps1:3063 Derives the parent directory's name by calling <code>Split-Path</code> then <code>DirectoryId-GetName</code>. Returns <code>$null</code> for root-level directories Top-level internal <code>DirectoryId-ResolvePath</code> main.ps1:3086 Resolves a path to its absolute form using <code>Resolve-Path</code> with a <code>[System.IO.Path]::GetFullPath()</code> fallback for hypothetical paths Top-level internal"},{"location":"porting-reference/DirectoryId_DependencyCatalog/#6-internal-logic-summary","title":"6. Internal Logic Summary","text":"<p>ID Generation Algorithm:</p> <p>The directory ID is computed by a two-layer hashing scheme:</p> <ol> <li>Hash the directory's own name \u2192 <code>DirectoryNameHash</code></li> <li>Hash the parent directory's name \u2192 <code>ParentNameHash</code></li> <li>Concatenate both hash strings \u2192 <code>CombinedParts</code></li> <li>Hash the concatenated string \u2192 Final <code>Id</code></li> </ol> <p>This is performed independently for each of four hash algorithms (MD5, SHA1, SHA256, SHA512), producing four distinct IDs.</p> <p>The final IDs are prefixed with <code>\"x\"</code> to distinguish directory IDs from file IDs (which use the <code>\"y\"</code> prefix in the companion function <code>FileId</code>).</p> <p>Null Hash Handling:</p> <p>When a directory is at the root of a filesystem (and thus has no parent name), the hash of an empty string is used for the parent component. The known null-hash constants for each algorithm are hardcoded in the sub-functions:</p> Algorithm Null Hash MD5 <code>D41D8CD98F00B204E9800998ECF8427E</code> SHA1 <code>DA39A3EE5E6B4B0D3255BFEF95601890AFD80709</code> SHA256 <code>E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855</code> SHA512 <code>CF83E1357EEFB8BDF1542850D66D8007D620E4050B5715DC83F4A921D36CE9CE47D0D13C5D85F2B0FF8318D2877EEC2F63B931BD47417A81A538327AF927DA3E</code>"},{"location":"porting-reference/DirectoryId_DependencyCatalog/#7-output-object-properties","title":"7. Output Object Properties","text":"<p>The full <code>[PSCustomObject]</code> (returned when <code>-OutputObject</code> is used) contains:</p> Property Type Description <code>IsDirectory</code> <code>[Boolean]</code> Always <code>$true</code> for valid directory inputs <code>IsFile</code> <code>[Boolean]</code> Always <code>$false</code> (inverse of <code>IsDirectory</code>) <code>IsLink</code> <code>[Boolean]</code> Always hardcoded to <code>$false</code> (symlink detection is not performed in this function) <code>DirectoryName</code> <code>[String]</code> The leaf name of the directory <code>DirectoryNameMD5</code> <code>[String]</code> MD5 hash of the directory name <code>DirectoryNameSHA1</code> <code>[String]</code> SHA1 hash of the directory name <code>DirectoryNameSHA256</code> <code>[String]</code> SHA256 hash of the directory name <code>DirectoryNameSHA512</code> <code>[String]</code> SHA512 hash of the directory name <code>ParentName</code> <code>[String]</code> The leaf name of the parent directory <code>ParentNameMD5</code> <code>[String]</code> MD5 hash of the parent name <code>ParentNameSHA1</code> <code>[String]</code> SHA1 hash of the parent name <code>ParentNameSHA256</code> <code>[String]</code> SHA256 hash of the parent name <code>ParentNameSHA512</code> <code>[String]</code> SHA512 hash of the parent name <code>IdMD5</code> <code>[String]</code> Final directory ID (MD5), prefixed with <code>\"x\"</code> <code>IdSHA1</code> <code>[String]</code> Final directory ID (SHA1), prefixed with <code>\"x\"</code> <code>IdSHA256</code> <code>[String]</code> Final directory ID (SHA256), prefixed with <code>\"x\"</code> <code>IdSHA512</code> <code>[String]</code> Final directory ID (SHA512), prefixed with <code>\"x\"</code>"},{"location":"porting-reference/DirectoryId_DependencyCatalog/#8-net-types-and-methods-used","title":"8. .NET Types and Methods Used","text":"Type / Method Usage <code>[System.IO.Path]::GetFileName()</code> Extracting directory leaf name <code>[System.IO.Path]::GetFullPath()</code> Resolving hypothetical paths <code>[System.Security.Cryptography.MD5]::Create()</code> MD5 hash computation <code>[System.Security.Cryptography.SHA1]::Create()</code> SHA1 hash computation <code>[System.Security.Cryptography.SHA256]::Create()</code> SHA256 hash computation <code>[System.Security.Cryptography.SHA512]::Create()</code> SHA512 hash computation <code>[System.Text.Encoding]::UTF8.GetBytes()</code> String \u2192 byte-array conversion for hashing <code>[BitConverter]::ToString()</code> Byte-array \u2192 hex-string conversion <code>[PSCustomObject]@{}</code> Output object construction"},{"location":"porting-reference/DirectoryId_DependencyCatalog/#9-powershell-built-in-cmdlets-used","title":"9. PowerShell Built-in Cmdlets Used","text":"Cmdlet Usage Context <code>ConvertTo-Json</code> Serializing output object when <code>-OutputJson</code> is specified (<code>-Depth 100</code>) <code>Resolve-Path</code> Resolving directory paths to absolute form (<code>-LiteralPath</code>) <code>Select-Object</code> Extracting <code>$PWD</code> path (<code>-Expand Path</code>) <code>Split-Path</code> Extracting parent directory path (<code>-LiteralPath</code>) <code>Test-Path</code> Validating directory existence (<code>-LiteralPath</code>, <code>-PathType Container</code>)"},{"location":"porting-reference/DirectoryId_DependencyCatalog/#10-return-value","title":"10. Return Value","text":"<p>Default (no output switches): Returns a <code>[System.String]</code> containing the SHA256-based directory ID (prefixed with <code>\"x\"</code>).</p> <p>With <code>-OutputObject</code>: Returns the full <code>[PSCustomObject]</code> described in Section 7.</p> <p>With <code>-OutputJson</code>: Returns a JSON-formatted string of the full result object.</p> <p>Returns <code>$null</code> if the input directory is missing or does not exist.</p>"},{"location":"porting-reference/DirectoryId_DependencyCatalog/#11-call-graph","title":"11. Call Graph","text":"<pre><code>DirectoryId\n\u251c\u2500\u2500 [resolves -Here or -Directory input]\n\u2502   \u2514\u2500\u2500 Vbs \u25c4\u2500\u2500 external pslib (on missing/invalid directory)\n\u251c\u2500\u2500 DirectoryId-ResolvePath\n\u2502   \u2514\u2500\u2500 Vbs \u25c4\u2500\u2500 external pslib (on empty input)\n\u251c\u2500\u2500 DirectoryId-GetName (directory name)\n\u251c\u2500\u2500 DirectoryId-HashString (\u00d74 algorithms, directory name)\n\u2502   \u251c\u2500\u2500 DirectoryId-HashString-Md5\n\u2502   \u251c\u2500\u2500 DirectoryId-HashString-Sha1\n\u2502   \u251c\u2500\u2500 DirectoryId-HashString-Sha256\n\u2502   \u2514\u2500\u2500 DirectoryId-HashString-Sha512\n\u251c\u2500\u2500 DirectoryId-ParentName\n\u2502   \u251c\u2500\u2500 Split-Path\n\u2502   \u2514\u2500\u2500 DirectoryId-GetName (parent name)\n\u251c\u2500\u2500 DirectoryId-HashString (\u00d74 algorithms, parent name)\n\u251c\u2500\u2500 [concatenate directory + parent hashes]\n\u251c\u2500\u2500 DirectoryId-HashString (\u00d74 algorithms, concatenated parts \u2192 final IDs)\n\u2514\u2500\u2500 [format output based on switches]\n</code></pre>"},{"location":"porting-reference/FileId_DependencyCatalog/","title":"FileId \u2014 Dependency Catalog","text":"<p>Source: <code>main.ps1</code>, line 4941 Purpose: Generates hash-based unique identifiers for files based on file content hashing (or name hashing for symbolic links) Audience: AI-first, Human-second  </p>"},{"location":"porting-reference/FileId_DependencyCatalog/#1-external-pslib-functions-called","title":"1. External PsLib Functions Called","text":"Function Defined At Called From Purpose <code>Vbs</code> main.ps1:16412 Top-level body and <code>FileId-ResolvePath</code> Verbose/logging output handler. Called with <code>-Caller</code>, <code>-Status</code> (e/w), <code>-Message</code>, <code>-Verbosity</code> <p>This function has a minimal external dependency footprint. It only calls <code>Vbs</code> for error/warning logging (missing input, invalid file, invalid hash types, empty path in resolution).</p>"},{"location":"porting-reference/FileId_DependencyCatalog/#2-external-variables-loaded","title":"2. External Variables Loaded","text":"Variable Defined At Type Description (none) \u2014 \u2014 This function does not reference any script-level or global variables. All state is derived from its own parameters and the filesystem."},{"location":"porting-reference/FileId_DependencyCatalog/#3-external-binaries-executables-invoked","title":"3. External Binaries / Executables Invoked","text":"Binary Notes (none) This function is entirely .NET-based and does not invoke any external executables."},{"location":"porting-reference/FileId_DependencyCatalog/#4-parameters","title":"4. Parameters","text":"Parameter Type Alias(es) Default Description <code>FileIdPendingFile</code> <code>[System.String]</code> (none) <code>$null</code> The file path to generate an identifier for <code>OutputObject</code> <code>[Switch]</code> <code>o</code> <code>$false</code> Return a <code>[PSCustomObject]</code> with all properties <code>OutputJson</code> <code>[Switch]</code> <code>j</code> <code>$false</code> Return a JSON-formatted string of the full result object <code>IncludeHashTypes</code> <code>[System.Array]</code> (none) <code>@('md5','sha256')</code> Array of hash algorithms to use. Valid values: <code>md5</code>, <code>sha1</code>, <code>sha256</code>, <code>sha512</code>, <code>all</code>. Case-insensitive. Specifying <code>all</code> expands to all four types <code>Verbosity</code> <code>[System.Boolean]</code> <code>v</code> <code>$true</code> Controls whether verbose/log messages are printed to the console"},{"location":"porting-reference/FileId_DependencyCatalog/#5-internal-sub-functions-defined-within-fileid","title":"5. Internal Sub-Functions (Defined Within FileId)","text":"Function Line Purpose Nesting <code>FileId-GetName</code> main.ps1:5041 Extracts the simple file name from a path using <code>[System.IO.Path]::GetFileName()</code>. Returns <code>$null</code> for empty paths Top-level internal <code>FileId-HashMd5</code> main.ps1:5063 Computes MD5 hash of file contents via <code>[System.IO.File]::OpenRead()</code> and <code>[System.Security.Cryptography.MD5]::Create()</code> Top-level internal <code>FileId-HashMd5-String</code> main.ps1:5076 Computes MD5 hash of a string value. Returns null-hash constant for empty/null inputs Top-level internal <code>FileId-HashSha1</code> main.ps1:5094 Computes SHA1 hash of file contents Top-level internal <code>FileId-HashSha1-String</code> main.ps1:5107 Computes SHA1 hash of a string value. Returns null-hash constant for empty/null inputs Top-level internal <code>FileId-HashSha256</code> main.ps1:5125 Computes SHA256 hash of file contents Top-level internal <code>FileId-HashSha256-String</code> main.ps1:5138 Computes SHA256 hash of a string value. Returns null-hash constant for empty/null inputs Top-level internal <code>FileId-HashSha512</code> main.ps1:5156 Computes SHA512 hash of file contents Top-level internal <code>FileId-HashSha512-String</code> main.ps1:5169 Computes SHA512 hash of a string value. Returns null-hash constant for empty/null inputs Top-level internal <code>FileId-ResolvePath</code> main.ps1:5187 Resolves a file path to its absolute form using <code>Resolve-Path</code> with a <code>[System.IO.Path]::GetFullPath()</code> fallback Top-level internal"},{"location":"porting-reference/FileId_DependencyCatalog/#6-internal-logic-summary","title":"6. Internal Logic Summary","text":"<p>ID Generation Algorithm:</p> <p>Unlike <code>DirectoryId</code> (which hashes directory + parent name), <code>FileId</code> hashes file contents directly:</p> <ol> <li>Resolve the file path to absolute form</li> <li>Detect if the file is a symbolic link (via <code>ReparsePoint</code> attribute check)</li> <li>For each requested hash type:</li> <li>If the file is a symbolic link \u2192 hash the file name string instead of contents</li> <li>If the file is not a symbolic link \u2192 hash the file contents via file stream</li> <li>Prepend <code>\"y\"</code> to each content hash to form the final ID</li> </ol> <p>The <code>\"y\"</code> prefix distinguishes file IDs from directory IDs (which use the <code>\"x\"</code> prefix in <code>DirectoryId</code>).</p> <p>Symlink Handling:</p> <p>Symbolic links are detected via: <code>(Get-Item -LiteralPath $FilePath -Force).Attributes -band [System.IO.FileAttributes]::ReparsePoint</code></p> <p>When a file is a symlink, the content hash is replaced with the name hash, ensuring the ID remains deterministic without requiring the link target to be accessible.</p> <p>Name Hashes:</p> <p>Name hashes (MD5, SHA1, SHA256, SHA512 of the file name string) are always computed regardless of the <code>IncludeHashTypes</code> parameter, as they are low-overhead and are needed for the symlink fallback path.</p>"},{"location":"porting-reference/FileId_DependencyCatalog/#7-output-object-properties","title":"7. Output Object Properties","text":"<p>The full <code>[PSCustomObject]</code> (returned when <code>-OutputObject</code> is used) contains:</p> Property Type Description <code>IsDirectory</code> <code>[Boolean]</code> Always <code>$false</code> for valid file inputs <code>IsFile</code> <code>[Boolean]</code> <code>$true</code> if the file exists <code>IsLink</code> <code>[Boolean]</code> <code>$true</code> if the file is a symbolic link (ReparsePoint) <code>Name</code> <code>[String]</code> The simple file name (with extension, no path) <code>Path</code> <code>[String]</code> The resolved absolute file path <code>NameMD5</code> <code>[String]</code> MD5 hash of the file name string <code>NameSHA1</code> <code>[String]</code> SHA1 hash of the file name string <code>NameSHA256</code> <code>[String]</code> SHA256 hash of the file name string <code>NameSHA512</code> <code>[String]</code> SHA512 hash of the file name string <code>ContentMD5</code> <code>[String]</code> or <code>$null</code> MD5 hash of file contents (or name hash if symlink). <code>$null</code> if not in <code>IncludeHashTypes</code> <code>ContentSHA1</code> <code>[String]</code> or <code>$null</code> SHA1 hash of file contents (or name hash if symlink). <code>$null</code> if not requested <code>ContentSHA256</code> <code>[String]</code> or <code>$null</code> SHA256 hash of file contents (or name hash if symlink). <code>$null</code> if not requested <code>ContentSHA512</code> <code>[String]</code> or <code>$null</code> SHA512 hash of file contents (or name hash if symlink). <code>$null</code> if not requested <code>IdMD5</code> <code>[String]</code> or <code>$null</code> <code>\"y\"</code> + ContentMD5. <code>$null</code> if not requested <code>IdSHA1</code> <code>[String]</code> or <code>$null</code> <code>\"y\"</code> + ContentSHA1. <code>$null</code> if not requested <code>IdSHA256</code> <code>[String]</code> or <code>$null</code> <code>\"y\"</code> + ContentSHA256. <code>$null</code> if not requested <code>IdSHA512</code> <code>[String]</code> or <code>$null</code> <code>\"y\"</code> + ContentSHA512. <code>$null</code> if not requested <code>ContentHashTypes</code> <code>[Array]</code> Array of hash type strings that were actually processed"},{"location":"porting-reference/FileId_DependencyCatalog/#8-net-types-and-methods-used","title":"8. .NET Types and Methods Used","text":"Type / Method Usage <code>[System.IO.File]::OpenRead()</code> Opening file stream for content hashing <code>[System.IO.FileAttributes]::ReparsePoint</code> Symbolic link detection via bitwise AND <code>[System.IO.Path]::GetFileName()</code> Extracting file name from path <code>[System.IO.Path]::GetFullPath()</code> Resolving hypothetical paths <code>[System.Security.Cryptography.MD5]::Create()</code> MD5 hash computation <code>[System.Security.Cryptography.SHA1]::Create()</code> SHA1 hash computation <code>[System.Security.Cryptography.SHA256]::Create()</code> SHA256 hash computation <code>[System.Security.Cryptography.SHA512]::Create()</code> SHA512 hash computation <code>[System.Text.Encoding]::UTF8.GetBytes()</code> String \u2192 byte-array conversion for name hashing <code>[BitConverter]::ToString()</code> Byte-array \u2192 hex-string conversion <code>[PSCustomObject]@{}</code> Output object construction"},{"location":"porting-reference/FileId_DependencyCatalog/#9-powershell-built-in-cmdlets-used","title":"9. PowerShell Built-in Cmdlets Used","text":"Cmdlet Usage Context <code>ConvertTo-Json</code> Serializing output when <code>-OutputJson</code> is specified (<code>-Depth 100</code>) <code>Get-Item</code> Checking file attributes for symlink detection (<code>-Force</code>, <code>-LiteralPath</code>) <code>Resolve-Path</code> Resolving file paths to absolute form (<code>-LiteralPath</code>) <code>Test-Path</code> Validating file existence (<code>-LiteralPath</code>, <code>-PathType Leaf/Container</code>)"},{"location":"porting-reference/FileId_DependencyCatalog/#10-return-value","title":"10. Return Value","text":"<p>Default (no output switches): Returns a <code>[System.String]</code> containing the last content hash ID processed (corresponds to the last element in the <code>IncludeHashTypes</code> array; with defaults this is the SHA256-based ID prefixed with <code>\"y\"</code>).</p> <p>With <code>-OutputObject</code>: Returns the full <code>[PSCustomObject]</code> described in Section 7.</p> <p>With <code>-OutputJson</code>: Returns a JSON-formatted string of the full result object.</p> <p>Returns <code>$null</code> if the input file is missing, does not exist, or no valid hash types were processed.</p>"},{"location":"porting-reference/FileId_DependencyCatalog/#11-call-graph","title":"11. Call Graph","text":"<pre><code>FileId\n\u251c\u2500\u2500 [validates FileIdPendingFile is non-empty and exists]\n\u2502   \u2514\u2500\u2500 Vbs \u25c4\u2500\u2500 external pslib (on error)\n\u251c\u2500\u2500 FileId-ResolvePath\n\u2502   \u2514\u2500\u2500 Vbs \u25c4\u2500\u2500 external pslib (on empty input)\n\u251c\u2500\u2500 FileId-GetName\n\u251c\u2500\u2500 [compute name hashes \u2014 always performed]\n\u2502   \u251c\u2500\u2500 FileId-HashMd5-String\n\u2502   \u251c\u2500\u2500 FileId-HashSha1-String\n\u2502   \u251c\u2500\u2500 FileId-HashSha256-String\n\u2502   \u2514\u2500\u2500 FileId-HashSha512-String\n\u251c\u2500\u2500 [detect symbolic link via ReparsePoint]\n\u251c\u2500\u2500 [expand \"all\" keyword in IncludeHashTypes]\n\u251c\u2500\u2500 [for each requested hash type]\n\u2502   \u251c\u2500\u2500 (is symlink) \u2192 use name hash as content hash\n\u2502   \u2514\u2500\u2500 (not symlink) \u2192 compute content hash via:\n\u2502       \u251c\u2500\u2500 FileId-HashMd5 (file stream)\n\u2502       \u251c\u2500\u2500 FileId-HashSha1 (file stream)\n\u2502       \u251c\u2500\u2500 FileId-HashSha256 (file stream)\n\u2502       \u2514\u2500\u2500 FileId-HashSha512 (file stream)\n\u2502   \u2514\u2500\u2500 prepend \"y\" to form final ID\n\u2514\u2500\u2500 [format output based on switches]\n</code></pre>"},{"location":"porting-reference/MakeIndex_DependencyCatalog/","title":"MakeIndex \u2014 Dependency Catalog","text":"<p>Source: <code>main.ps1</code>, line 7531 Purpose: Generates JSON-formatted nested indexes of files and directories with metadata Audience: AI-first, Human-second  </p>"},{"location":"porting-reference/MakeIndex_DependencyCatalog/#1-external-pslib-functions-called","title":"1. External PsLib Functions Called","text":"<p>These functions are defined at the top level of <code>main.ps1</code> (outside of MakeIndex) and are called from within MakeIndex or its nested sub-functions.</p> Function Defined At Called From (within MakeIndex) Purpose <code>Base64DecodeString</code> main.ps1:764 <code>GetFileExif</code> \u2192 <code>GetFileExifArgsWrite</code> Decodes Base64-encoded exiftool argument strings (with URL-decode and UTF8 encoding support) <code>Date2UnixTime</code> main.ps1:2517 <code>MakeObject</code> Converts formatted date strings to Unix timestamps <code>DirectoryId</code> main.ps1:2819 <code>MakeObject</code> Generates unique identifiers (MD5, SHA256) for directories based on directory name hashing. Returns an object with <code>.IdMD5</code>, <code>.IdSHA256</code>, <code>.DirectoryName</code>, <code>.DirectoryNameMD5</code>, <code>.DirectoryNameSHA256</code>, <code>.IsLink</code> properties <code>FileId</code> main.ps1:4941 <code>MakeObject</code> Generates unique identifiers (MD5, SHA256) for files based on content hashing. Returns an object with <code>.IdMD5</code>, <code>.IdSHA256</code>, <code>.ContentMD5</code>, <code>.ContentSHA256</code>, <code>.NameMD5</code>, <code>.NameSHA256</code>, <code>.IsLink</code> properties <code>MetaFileRead</code> main.ps1:10233 <code>ReadMetaFile</code> Reads and parses external metadata files (sidecar files). Accepts <code>-InputFile</code>, <code>-Format \"object\"</code>, <code>-ProgressString</code>, <code>-Verbosity</code>. Returns an object with <code>.Type</code>, <code>.Data</code>, <code>.Name</code> properties <code>TempOpen</code> main.ps1:15119 <code>GetFileExif</code> Creates a temporary file and returns its path. Called with <code>-Type 'txt'</code> <code>TempClose</code> main.ps1:15044 <code>GetFileExif</code> Deletes a temporary file. Called with <code>-Target &lt;path&gt;</code> <code>Vbs</code> main.ps1:16412 Throughout (all sub-functions) Verbose/logging output handler. Called with <code>-Caller</code>, <code>-Status</code> (i/d/w/e), <code>-Message</code>, <code>-Verbosity</code>"},{"location":"porting-reference/MakeIndex_DependencyCatalog/#listed-but-not-directly-called","title":"Listed but Not Directly Called","text":"Function Notes <code>ValidateIsLink</code> Listed in the MakeIndex docstring under \"Function Dependencies\" but never directly invoked within MakeIndex code. The <code>.IsLink</code> property is obtained indirectly via the return objects of <code>DirectoryId</code> and <code>FileId</code>, which likely call <code>ValidateIsLink</code> internally."},{"location":"porting-reference/MakeIndex_DependencyCatalog/#2-external-variables-loaded","title":"2. External Variables Loaded","text":"<p>These variables are defined at the script level of <code>main.ps1</code> (in the variable declarations section, lines ~17383\u201317441) and are accessed by MakeIndex through scope inheritance or the <code>$global:</code> prefix.</p> Variable Defined At Type Description <code>$global:MetadataFileParser</code> main.ps1:16977 <code>[ordered]@{}</code> (Hashtable) Large configuration object governing metadata file parsing behavior. MakeIndex consumes the following sub-properties:<code>.Exiftool.Exclude</code> \u2014 Array of file extensions to skip for exiftool processing<code>.Indexer.Include</code> \u2014 Array of regex patterns identifying metadata sidecar file suffixes<code>.Indexer.IncludeString</code> \u2014 Joined regex string of the Include array<code>.Indexer.Exclude</code> \u2014 Array of regex patterns for metadata files to exclude<code>.Indexer.ExcludeString</code> \u2014 Joined regex string of the Exclude array<code>.Identify.&lt;Key&gt;</code> \u2014 Sub-objects mapping metadata file types to their regex patterns (used by <code>MetaFileRead</code> downstream) <code>$Sep</code> main.ps1:17383 <code>[System.Char]</code> Directory separator character (<code>[System.IO.Path]::DirectorySeparatorChar</code>). Used when constructing renamed file paths in <code>MakeDirectoryIndexLogic</code>, <code>MakeDirectoryIndexRecursiveLogic</code>, and <code>MakeFileIndex</code>"},{"location":"porting-reference/MakeIndex_DependencyCatalog/#global-variables-createdmanaged-at-runtime","title":"Global Variables Created/Managed at Runtime","text":"<p>MakeIndex promotes several local parameter values to global scope for access by deeply nested sub-functions, then cleans them up at the end of execution:</p> Variable Lifecycle Purpose <code>$global:ExiftoolRejectList</code> Created at start, removed at end Copy of <code>$MetadataFileParser.Exiftool.Exclude</code> <code>$global:MetaSuffixInclude</code> Created at start, removed at end Copy of <code>$MetadataFileParser.Indexer.Include</code> <code>$global:MetaSuffixIncludeString</code> Created at start, removed at end Copy of <code>$MetadataFileParser.Indexer.IncludeString</code> <code>$global:MetaSuffixExclude</code> Created at start, removed at end Copy of <code>$MetadataFileParser.Indexer.Exclude</code> <code>$global:MetaSuffixExcludeString</code> Created at start, removed at end Copy of <code>$MetadataFileParser.Indexer.ExcludeString</code> <code>$global:DeleteQueue</code> Created at start (<code>@()</code>), removed at end Accumulates file paths of metadata sidecar files to delete when <code>-MetaMergeDelete</code> is active"},{"location":"porting-reference/MakeIndex_DependencyCatalog/#3-external-binaries-executables-invoked","title":"3. External Binaries / Executables Invoked","text":"Binary Called From (within MakeIndex) How Invoked Purpose <code>exiftool</code> <code>GetFileExif</code> \u2192 <code>GetFileExifRun</code> <code>exiftool -@ \"$ArgsFile\" 2&gt; $null</code> \u2014 Invoked via bare command name (must be in system PATH). Receives arguments from a temporary file written by <code>GetFileExifArgsWrite</code>. Extracts EXIF/metadata from files. Arguments include: <code>-extractEmbedded3</code>, <code>-scanForXMP</code>, <code>-unknown2</code>, <code>-json</code>, <code>-G3:1</code>, <code>-struct</code>, <code>-ignoreMinorErrors</code>, <code>-charset filename=utf8</code>, <code>-api requestall=3</code>, <code>-api largefilesupport=1</code> (plus <code>-quiet</code> when verbosity is off) <code>jq</code> <code>GetFileExif</code> \u2192 <code>GetFileExifRun</code> <code>$ExiftoolOutput \\| jq -c '.[] \\| .' 2&gt; $null</code> and a second pass with <code>jq -c 'del(\u2026)'</code> to strip unwanted keys Parses and filters JSON output from exiftool. Removes system/exiftool metadata keys (ExifToolVersion, FileSequence, NewGUID, Directory, FileName, FilePath, BaseName, FilePermissions, etc.)"},{"location":"porting-reference/MakeIndex_DependencyCatalog/#note-on-binary-resolution","title":"Note on Binary Resolution","text":"<p>Neither <code>exiftool</code> nor <code>jq</code> are referenced via absolute paths. Both must be available in the system <code>PATH</code> environment variable at runtime. The MakeIndex docstring explicitly states: \"exiftool must be installed and available in the system PATH. This function will not work without it.\" The <code>jq</code> dependency is implicit (not mentioned in the docstring) but is equally required for metadata extraction to work.</p>"},{"location":"porting-reference/MakeIndex_DependencyCatalog/#4-internal-sub-functions-defined-within-makeindex","title":"4. Internal Sub-Functions (Defined Within MakeIndex)","text":"<p>For completeness and call-chain tracing, these are the functions defined inside the MakeIndex function body. They are not accessible outside of MakeIndex.</p>"},{"location":"porting-reference/MakeIndex_DependencyCatalog/#top-level-internal-functions","title":"Top-Level Internal Functions","text":"Function Purpose Calls (internal) Calls (external PsLib) <code>GetFileEncoding</code> Detects file encoding via BOM byte inspection \u2014 \u2014 <code>GetFileExif</code> Orchestrates exiftool execution for a single file <code>GetFileExifArgsWrite</code>, <code>GetFileExifRun</code>, <code>UpdateFunctionStack</code> <code>Base64DecodeString</code>, <code>TempOpen</code>, <code>TempClose</code>, <code>Vbs</code> <code>GetFileMetaSiblings</code> Finds sibling metadata files matching a given file's basename <code>GetParentPath</code>, <code>UpdateFunctionStack</code> <code>Vbs</code> <code>GetParentPath</code> Extracts parent directory path from a full path string \u2014 \u2014 <code>MakeDirectoryIndex</code> Entry point for non-recursive directory indexing <code>MakeDirectoryIndexLogic</code>, <code>UpdateFunctionStack</code> <code>Vbs</code> <code>MakeDirectoryIndexRecursive</code> Entry point for recursive directory indexing <code>MakeDirectoryIndexRecursiveLogic</code>, <code>UpdateFunctionStack</code> <code>Vbs</code> <code>MakeFileIndex</code> Entry point for single-file indexing <code>MakeObject</code>, <code>GetParentPath</code>, <code>UpdateFunctionStack</code> <code>Vbs</code> <code>MakeObject</code> Core object builder \u2014 constructs the PSCustomObject for any file or directory <code>GetFileEncoding</code>, <code>GetFileExif</code>, <code>GetFileMetaSiblings</code>, <code>GetParentPath</code>, <code>ReadMetaFile</code>, <code>VariableStringify</code>, <code>UpdateFunctionStack</code> <code>Date2UnixTime</code>, <code>DirectoryId</code>, <code>FileId</code>, <code>Vbs</code> <code>ReadMetaFile</code> Reads a metadata sidecar file and wraps it in a standard object <code>ReadMetaFile-GetNameHashMD5</code>, <code>ReadMetaFile-GetNameHashSHA256</code>, <code>UpdateFunctionStack</code> <code>MetaFileRead</code>, <code>Vbs</code> <code>ResolvePath</code> Resolves real or hypothetical filesystem paths <code>UpdateFunctionStack</code> <code>Vbs</code> <code>UpdateFunctionStack</code> Maintains a colon-delimited call-stack string for logging \u2014 \u2014 <code>VariableStringify</code> Converts variables to string representations (handles null/empty) \u2014 \u2014"},{"location":"porting-reference/MakeIndex_DependencyCatalog/#nested-internal-functions-defined-inside-other-internal-functions","title":"Nested Internal Functions (defined inside other internal functions)","text":"Function Parent Function Purpose <code>GetFileExifArgsWrite</code> <code>GetFileExif</code> Writes decoded exiftool argument strings to a temp file <code>GetFileExifRun</code> <code>GetFileExif</code> Executes <code>exiftool</code> and pipes output through <code>jq</code> <code>MakeDirectoryIndexLogic</code> <code>MakeDirectoryIndex</code> Core non-recursive directory traversal and object assembly <code>MakeDirectoryIndexRecursiveLogic</code> <code>MakeDirectoryIndexRecursive</code> Core recursive directory traversal and object assembly (calls itself recursively for child directories) <code>ReadMetaFile-GetNameHashMD5</code> <code>ReadMetaFile</code> Computes MD5 hash of a filename string <code>ReadMetaFile-GetNameHashSHA256</code> <code>ReadMetaFile</code> Computes SHA256 hash of a filename string"},{"location":"porting-reference/MakeIndex_DependencyCatalog/#5-powershell-built-in-cmdlets-and-net-types-used","title":"5. PowerShell Built-in Cmdlets and .NET Types Used","text":"<p>For porting reference, MakeIndex relies on these PowerShell cmdlets and .NET framework types.</p>"},{"location":"porting-reference/MakeIndex_DependencyCatalog/#cmdlets","title":"Cmdlets","text":"Cmdlet Usage Context <code>Add-Content</code> Appending filename to exiftool args file <code>ConvertFrom-Json</code> Parsing exiftool JSON output (<code>-AsHashtable</code>) <code>ConvertTo-Json</code> Serializing output objects (<code>-Depth 100</code>) <code>Get-ChildItem</code> Directory listing (with <code>-Force</code>, <code>-File</code>, <code>-Recurse</code>, <code>-LiteralPath</code>) <code>Get-Help</code> (not directly, but pattern exists in other functions) <code>Get-Item</code> File/directory info retrieval (<code>-Force</code>, <code>-LiteralPath</code>) <code>Measure-Object</code> Directory size calculation (<code>-Property Length -Sum</code>) <code>Move-Item</code> File renaming (<code>-LiteralPath</code>, <code>-Destination</code>, <code>-Force</code>) <code>Out-File</code> Writing final JSON output (<code>-Encoding UTF8</code>) <code>Out-Null</code> Suppressing output from <code>Remove-Item</code> <code>Remove-Item</code> Deleting metadata files from DeleteQueue (<code>-LiteralPath</code>, <code>-Force</code>) <code>Remove-Variable</code> Cleaning up global variables at end of execution <code>Resolve-Path</code> Path resolution (<code>-LiteralPath</code>) <code>Select-Object</code> Property selection and exclusion <code>Set-Content</code> Writing in-place metadata JSON files (<code>-LiteralPath</code>, <code>-Force</code>) <code>Set-Location</code> Changing working directory for exiftool and directory traversal <code>Split-Path</code> Extracting parent path <code>Test-Path</code> Validating file/directory existence (<code>-LiteralPath</code>, <code>-PathType Leaf/Container</code>) <code>Where-Object</code> Filtering child items (excluding <code>$RECYCLE.BIN</code>, <code>System Volume Information</code>; separating files from directories)"},{"location":"porting-reference/MakeIndex_DependencyCatalog/#net-types-and-methods","title":".NET Types and Methods","text":"Type / Method Usage <code>[math]::Round()</code> Progress percentage calculation <code>[System.Collections.ArrayList]</code> Combining file and directory child item arrays <code>[System.IO.FileStream]</code> BOM-based encoding detection <code>[System.IO.Path]::GetFileName()</code> Extracting filename from full path <code>[System.IO.Path]::GetFileNameWithoutExtension()</code> Extracting basename <code>[System.IO.Path]::GetFullPath()</code> Resolving hypothetical paths <code>[System.IO.Path]::GetDirectoryName()</code> Extracting directory from file path <code>[System.Security.Cryptography.MD5]::Create()</code> MD5 hashing (in ReadMetaFile sub-functions) <code>[System.Security.Cryptography.SHA256]::Create()</code> SHA256 hashing (in ReadMetaFile sub-functions) <code>[System.Text.Encoding]::UTF8</code> Encoding for hash computation <code>[System.Text.RegularExpressions.Regex]::Escape()</code> Escaping basename for regex matching <code>[BitConverter]::ToString()</code> Converting hash bytes to hex string <code>[DateTimeOffset]::Now.ToUnixTimeMilliseconds()</code> Session ID generation <code>[PSCustomObject]@{}</code> All output object construction <code>[Text.Encoding]::ASCII/UTF7/Unicode/BigEndianUnicode/UTF32/UTF8</code> Encoding type constants for BOM detection"},{"location":"porting-reference/MakeIndex_DependencyCatalog/#6-summary-call-graph","title":"6. Summary Call Graph","text":"<pre><code>MakeIndex\n\u251c\u2500\u2500 [validates inputs, resolves paths, sets up globals]\n\u251c\u2500\u2500 ResolvePath \u2192 Vbs\n\u251c\u2500\u2500 GetParentPath\n\u2502\n\u251c\u2500\u2500 (TargetTyp=0) MakeDirectoryIndexRecursive \u2192 Vbs\n\u2502   \u2514\u2500\u2500 MakeDirectoryIndexRecursiveLogic (recursive)\n\u2502       \u251c\u2500\u2500 MakeObject \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502       \u2502   \u251c\u2500\u2500 VariableStringify                    \u2502\n\u2502       \u2502   \u251c\u2500\u2500 GetParentPath                        \u2502\n\u2502       \u2502   \u251c\u2500\u2500 DirectoryId \u25c4\u2500\u2500\u2500\u2500\u2500\u2500 external pslib   \u2502\n\u2502       \u2502   \u251c\u2500\u2500 FileId \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 external pslib    \u2502\n\u2502       \u2502   \u251c\u2500\u2500 Date2UnixTime \u25c4\u2500\u2500\u2500\u2500 external pslib   \u2502\n\u2502       \u2502   \u251c\u2500\u2500 GetFileEncoding                      \u2502\n\u2502       \u2502   \u251c\u2500\u2500 GetFileExif                          \u2502\n\u2502       \u2502   \u2502   \u251c\u2500\u2500 Base64DecodeString \u25c4\u2500\u2500 ext pslib \u2502\n\u2502       \u2502   \u2502   \u251c\u2500\u2500 TempOpen \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 ext pslib \u2502\n\u2502       \u2502   \u2502   \u251c\u2500\u2500 TempClose \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 ext pslib \u2502\n\u2502       \u2502   \u2502   \u251c\u2500\u2500 [exiftool] \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 BINARY    \u2502\n\u2502       \u2502   \u2502   \u2514\u2500\u2500 [jq] \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 BINARY     \u2502\n\u2502       \u2502   \u251c\u2500\u2500 GetFileMetaSiblings                  \u2502\n\u2502       \u2502   \u251c\u2500\u2500 ReadMetaFile                         \u2502\n\u2502       \u2502   \u2502   \u251c\u2500\u2500 MetaFileRead \u25c4\u2500\u2500\u2500\u2500 external pslib\u2502\n\u2502       \u2502   \u2502   \u251c\u2500\u2500 ReadMetaFile-GetNameHashMD5      \u2502\n\u2502       \u2502   \u2502   \u2514\u2500\u2500 ReadMetaFile-GetNameHashSHA256   \u2502\n\u2502       \u2502   \u2514\u2500\u2500 Vbs \u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 external pslib     \u2502\n\u2502       \u2514\u2500\u2500 MakeDirectoryIndexRecursiveLogic (self)  \u2502\n\u2502                                                    \u2502\n\u251c\u2500\u2500 (TargetTyp=1) MakeFileIndex \u2192 Vbs                \u2502\n\u2502   \u2514\u2500\u2500 MakeObject \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\u2502\n\u251c\u2500\u2500 (TargetTyp=2) MakeDirectoryIndex \u2192 Vbs\n\u2502   \u2514\u2500\u2500 MakeDirectoryIndexLogic\n\u2502       \u2514\u2500\u2500 MakeObject (same as above)\n\u2502\n\u251c\u2500\u2500 [DeleteQueue processing]\n\u251c\u2500\u2500 [Global variable cleanup via Remove-Variable]\n\u251c\u2500\u2500 [OutFile via ConvertTo-Json | Out-File]\n\u2514\u2500\u2500 [StandardOutput via ConvertTo-Json]\n</code></pre>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/","title":"Operations Catalog \u2014 MakeIndex Port to Python","text":"<p>Purpose: Categorize all logical operations found in the original MakeIndex function (and its dependency tree) into defined groups, correlate each group to recommended Python modules/libraries, and flag improvements over the original implementation. Audience: AI-first, Human-second Scope: Covers MakeIndex, its 8 external pslib dependencies (Base64DecodeString, Date2UnixTime, DirectoryId, FileId, MetaFileRead, TempOpen, TempClose, Vbs), 2 external binaries (exiftool, jq), and all internal sub-functions. Schema Reference: <code>MakeIndex_OutputSchema.json</code> \u2014 the <code>Encoding</code> key is intentionally excluded from the ported software per project requirements.</p>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#how-to-read-this-document","title":"How to Read This Document","text":"<p>Each operation category below contains:</p> <ul> <li>What It Does: A summary of the original behavior across MakeIndex and its dependencies.</li> <li>Where It Lives (Original): The specific functions/sub-functions in the PowerShell source that implement the operation.</li> <li>Python Modules: The recommended Python standard-library or third-party modules for the ported implementation.</li> <li>Improvement Notes: Where the original logic was inefficient, fragile, or platform-locked, and how the Python port should diverge.</li> </ul> <p>Categories are ordered by architectural importance (foundational operations first, output/presentation operations last).</p>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#category-index","title":"Category Index","text":"# Category Primary Python Modules 1 Filesystem Traversal &amp; Discovery <code>pathlib</code>, <code>os</code> 2 Path Resolution &amp; Manipulation <code>pathlib</code> 3 Hashing &amp; Identity Generation <code>hashlib</code> 4 Symlink Detection <code>pathlib</code> 5 Filesystem Timestamps &amp; Date Conversion <code>datetime</code> 6 EXIF / Embedded Metadata Extraction <code>subprocess</code> + <code>exiftool</code>, <code>json</code> 7 Sidecar Metadata File Handling <code>json</code>, <code>re</code>, <code>pathlib</code> 8 Output Object Construction &amp; Schema <code>dataclasses</code>, <code>json</code> 9 JSON Serialization &amp; Output Routing <code>json</code> (or <code>orjson</code>), <code>pathlib</code>, <code>sys</code> 10 File Rename &amp; In-Place Write Operations <code>pathlib</code>, <code>shutil</code> 11 Configuration Management <code>dataclasses</code>, <code>tomllib</code> (or <code>pyyaml</code>) 12 Logging &amp; Verbosity <code>logging</code> 13 Progress Reporting <code>tqdm</code> (or <code>rich</code>) 14 CLI Argument Parsing &amp; Entry Point <code>click</code> (or <code>argparse</code>) 15 Temporary File Management <code>tempfile</code>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#1-filesystem-traversal-discovery","title":"1. Filesystem Traversal &amp; Discovery","text":""},{"location":"porting-reference/MakeIndex_OperationsCatalog/#what-it-does","title":"What It Does","text":"<p>Enumerates files and directories within a target path. Supports recursive and non-recursive modes. Filters out system artifacts (<code>$RECYCLE.BIN</code>, <code>System Volume Information</code>). Separates child items into file and directory lists. Counts items for progress reporting. Handles the three input scenarios: single file, single directory (flat), and directory tree (recursive).</p>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#where-it-lives-original","title":"Where It Lives (Original)","text":"Function Role <code>MakeDirectoryIndexRecursiveLogic</code> Recursive tree walk via <code>Get-ChildItem -Force -Recurse</code> combined with self-recursive calls per child directory <code>MakeDirectoryIndexLogic</code> Non-recursive single-directory enumeration via <code>Get-ChildItem -Force</code> <code>MakeFileIndex</code> Single-file path; skips traversal entirely, calls <code>Get-Item</code> on one file <code>Where-Object</code> filters Excludes <code>$RECYCLE.BIN</code> and <code>System Volume Information</code> by name match <code>[System.Collections.ArrayList]</code> Combines file and directory child arrays into a single ordered collection"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#python-modules","title":"Python Modules","text":"Module Usage <code>pathlib.Path.iterdir()</code> Non-recursive directory listing <code>pathlib.Path.rglob('*')</code> Recursive traversal (replaces <code>Get-ChildItem -Recurse</code>) <code>os.scandir()</code> High-performance directory iteration when <code>pathlib</code> overhead matters (large trees) <code>pathlib.Path.is_file()</code> / <code>.is_dir()</code> Item type classification (replaces <code>Where-Object</code> separation)"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#improvement-notes","title":"Improvement Notes","text":"<p>The original uses two entirely separate code paths for recursive vs. non-recursive traversal (<code>MakeDirectoryIndexRecursiveLogic</code> which calls itself, vs. <code>MakeDirectoryIndexLogic</code>). This created near-complete code duplication. The Python port should use a single traversal function parameterized by a <code>recursive: bool</code> flag. When <code>recursive=True</code>, use <code>Path.rglob('*')</code> or <code>os.walk()</code>. When <code>recursive=False</code>, use <code>Path.iterdir()</code>. Both paths feed into the same object-construction pipeline.</p> <p>The original manually assembles an <code>ArrayList</code> from two separate <code>Get-ChildItem</code> calls (one for files, one for directories). Python's <code>os.scandir()</code> returns <code>DirEntry</code> objects that already expose <code>.is_file()</code> and <code>.is_dir()</code> without additional stat calls, making the separation trivially cheap in a single pass.</p> <p>The hardcoded exclusion of <code>$RECYCLE.BIN</code> and <code>System Volume Information</code> is Windows-specific. The port should externalize the exclusion list into configuration (see Category 11) and default to a cross-platform set that also covers <code>.DS_Store</code>, <code>.Spotlight-V100</code>, <code>.Trashes</code>, and similar platform artifacts.</p>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#2-path-resolution-manipulation","title":"2. Path Resolution &amp; Manipulation","text":""},{"location":"porting-reference/MakeIndex_OperationsCatalog/#what-it-does_1","title":"What It Does","text":"<p>Resolves relative, hypothetical, or symbolic paths into absolute canonical forms. Extracts parent directories, basenames, extensions, and filenames from path strings. Constructs new paths for renamed files and sidecar metadata outputs. Validates extension strings against a regex pattern to reject malformed or suspiciously long extensions.</p>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#where-it-lives-original_1","title":"Where It Lives (Original)","text":"Function Role <code>ResolvePath</code> Resolves real paths via <code>Resolve-Path</code>; falls back to <code>[System.IO.Path]::GetFullPath()</code> for hypothetical (non-existent) paths <code>GetParentPath</code> Extracts parent directory via <code>Split-Path</code> <code>MakeObject</code> Extracts extension, basename, filename via <code>[System.IO.Path]</code> methods; validates extension with regex <code>^(([a-z0-9]){1,2}\\|([a-z0-9]){1}([a-z0-9\\-]){1,12}([a-z0-9]){1})$</code> <code>FileId-ResolvePath</code> / <code>DirectoryId-ResolvePath</code> Redundant copies of the same resolve logic inside FileId and DirectoryId <code>$Sep</code> (global) <code>[System.IO.Path]::DirectorySeparatorChar</code> used for manual string concatenation of paths"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#python-modules_1","title":"Python Modules","text":"Module Usage <code>pathlib.Path.resolve()</code> Canonical absolute path resolution (replaces <code>Resolve-Path</code> + <code>GetFullPath</code> fallback) <code>pathlib.Path.parent</code> Parent directory extraction (replaces <code>Split-Path</code> and <code>GetParentPath</code>) <code>pathlib.Path.name</code> / <code>.stem</code> / <code>.suffix</code> Filename, basename, and extension extraction (replaces all <code>[System.IO.Path]</code> calls) <code>pathlib.PurePosixPath</code> / <code>PureWindowsPath</code> Cross-platform path construction without touching the filesystem"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#improvement-notes_1","title":"Improvement Notes","text":"<p>The original has three independent copies of the \"resolve path\" logic: <code>ResolvePath</code> in MakeIndex, <code>FileId-ResolvePath</code> in FileId, and <code>DirectoryId-ResolvePath</code> in DirectoryId. All three do the same thing. The Python port should have exactly one path resolution utility.</p> <p>The original constructs paths by string-concatenating components with <code>$Sep</code> as a manual separator character. This is brittle and unnecessary. <code>pathlib</code> operator overloading (<code>parent / filename</code>) handles path construction correctly across platforms with no separator management.</p> <p>The extension validation regex in the original rejects extensions longer than 14 characters or those containing non-alphanumeric characters (beyond hyphens). This is reasonable but should be made configurable rather than hardcoded, as some legitimate extensions (e.g., <code>.numbers</code>, <code>.download</code>) may be affected.</p>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#3-hashing-identity-generation","title":"3. Hashing &amp; Identity Generation","text":""},{"location":"porting-reference/MakeIndex_OperationsCatalog/#what-it-does_2","title":"What It Does","text":"<p>Computes cryptographic hashes of file contents and name strings to produce deterministic unique identifiers. Files get content-based IDs (prefixed <code>y</code>); directories get name-based IDs computed from a two-layer scheme: <code>hash( hash(dirName) + hash(parentDirName) )</code> (prefixed <code>x</code>). Handles null/empty inputs with known null-hash constants. Handles symlinks by falling back to name hashing instead of content hashing.</p> <p>The original only computes MD5 and SHA256 at runtime, despite the output schema defining fields for SHA1 and SHA512 as well.</p>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#where-it-lives-original_2","title":"Where It Lives (Original)","text":"Function Role <code>FileId</code> + 8 nested hash sub-functions File content hashing (MD5, SHA1, SHA256, SHA512) via <code>[System.Security.Cryptography.*]::Create()</code> + <code>[System.IO.File]::OpenRead()</code> stream hashing; name string hashing via same algorithms on UTF-8 byte encoding <code>DirectoryId</code> + 8 nested hash sub-functions Directory name hashing using the two-layer <code>hash(hash(name) + hash(parentName))</code> scheme <code>ReadMetaFile-GetNameHashMD5</code> / <code>ReadMetaFile-GetNameHashSHA256</code> Yet more copies of string hashing logic, duplicated inside <code>ReadMetaFile</code> <code>MetaFileRead-Sha256-File</code> / <code>MetaFileRead-Sha256-String</code> Even more copies inside <code>MetaFileRead</code> itself Null-hash constants Hardcoded per-algorithm empty-string hash values for edge cases"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#python-modules_2","title":"Python Modules","text":"Module Usage <code>hashlib</code> All hash computation: <code>hashlib.md5()</code>, <code>hashlib.sha1()</code>, <code>hashlib.sha256()</code>, <code>hashlib.sha512()</code> \u2014 supports both file stream hashing (via <code>.update()</code> in chunks) and string hashing (via <code>.update(s.encode('utf-8'))</code>) <code>hashlib.file_digest()</code> Python 3.11+ convenience function for hashing file contents directly from a file object; ideal for the file content hashing path"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#improvement-notes_2","title":"Improvement Notes","text":"<p>Critical code duplication problem. The original has no fewer than four separate locations where hashing logic is independently implemented: <code>FileId</code>, <code>DirectoryId</code>, <code>ReadMetaFile</code> sub-functions, and <code>MetaFileRead</code> sub-functions. Each reimplements the same <code>Create() \u2192 ComputeHash() \u2192 ToString() \u2192 replace('-','')</code> pattern. The Python port should provide exactly one hashing utility module exposing functions like <code>hash_file(path, algorithm) -&gt; str</code> and <code>hash_string(value, algorithm) -&gt; str</code>, called from everywhere.</p> <p>Expand runtime hash coverage. The original only computes MD5 and SHA256 at runtime, but the output schema defines SHA1 and SHA512 fields. Since <code>hashlib</code> can compute all four algorithms in a single file read pass (feeding the same byte chunks to four hash objects simultaneously), the Python port should compute all four by default with near-zero marginal cost. This fills the previously-empty schema fields and enables downstream consumers to select their preferred algorithm.</p> <p>Chunked file reading. The original opens the entire file stream and calls <code>ComputeHash()</code> on it in one pass. For very large files this is fine at the .NET level (it streams internally), but the Python port should be explicit about chunked reads (e.g., 8 KB or 64 KB chunks fed to <code>hashlib.update()</code>) to keep memory usage bounded and to enable multi-algorithm hashing in a single pass.</p> <p>The <code>x</code>/<code>y</code> prefix convention for directory vs. file IDs is a design choice carried forward from the original. It should be preserved for backward compatibility with the output schema.</p> <p>Null-hash constants should not be hardcoded. Instead, the Python port can compute them once at module load time: <code>hashlib.md5(b'').hexdigest().upper()</code>, etc. This is self-documenting and eliminates the risk of copy-paste errors in long hex strings.</p>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#4-symlink-detection","title":"4. Symlink Detection","text":""},{"location":"porting-reference/MakeIndex_OperationsCatalog/#what-it-does_3","title":"What It Does","text":"<p>Determines whether a file or directory is a symbolic link (reparse point). When a file is a symlink, the identity system falls back to hashing the file's name string rather than its content (because the link target may not be accessible). The <code>IsLink</code> boolean is included in the output schema.</p>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#where-it-lives-original_3","title":"Where It Lives (Original)","text":"Function Role <code>FileId</code> Checks <code>(Get-Item).Attributes -band [System.IO.FileAttributes]::ReparsePoint</code> <code>DirectoryId</code> Same reparse point check for directories <code>ValidateIsLink</code> Listed as a dependency but never directly called; <code>FileId</code> and <code>DirectoryId</code> perform the check inline <code>MakeObject</code> Reads <code>.IsLink</code> from the <code>FileId</code>/<code>DirectoryId</code> return object; skips encoding detection and exiftool for symlinks"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#python-modules_3","title":"Python Modules","text":"Module Usage <code>pathlib.Path.is_symlink()</code> Single cross-platform call; returns <code>True</code> for both file and directory symlinks <code>os.path.islink()</code> Alternative for string-path interfaces"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#improvement-notes_3","title":"Improvement Notes","text":"<p>The original checks for the <code>ReparsePoint</code> attribute, which is a Windows-specific concept that covers symlinks but also covers junction points and other reparse point types. <code>pathlib.Path.is_symlink()</code> is the correct cross-platform equivalent. On Windows it still detects reparse points; on Linux/macOS it detects POSIX symlinks. This is a strict improvement in portability.</p> <p>The <code>ValidateIsLink</code> function listed in the original docstring but never called is dead code. It should not be carried forward.</p>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#5-filesystem-timestamps-date-conversion","title":"5. Filesystem Timestamps &amp; Date Conversion","text":""},{"location":"porting-reference/MakeIndex_OperationsCatalog/#what-it-does_4","title":"What It Does","text":"<p>Reads filesystem timestamps (created, modified, accessed) from file/directory stat data. Formats them as ISO 8601 strings with timezone offset (format: <code>yyyy-MM-ddTHH:mm:ss.fffffffzzz</code>). Converts those formatted strings to Unix timestamps (milliseconds since epoch) via the external <code>Date2UnixTime</code> function.</p>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#where-it-lives-original_4","title":"Where It Lives (Original)","text":"Function Role <code>MakeObject</code> Reads <code>.LastAccessTime</code>, <code>.CreationTime</code>, <code>.LastWriteTime</code> from <code>Get-Item</code>; formats via <code>.ToString($DateFormat)</code> <code>Date2UnixTime</code> (external pslib) Parses formatted date strings back into <code>[DateTimeOffset]</code> objects and calls <code>.ToUnixTimeMilliseconds()</code>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#python-modules_4","title":"Python Modules","text":"Module Usage <code>datetime.datetime</code> Timestamp formatting via <code>.isoformat()</code> or <code>.strftime()</code> <code>datetime.datetime.timestamp()</code> Direct conversion to Unix epoch seconds (multiply by 1000 for milliseconds) <code>os.stat_result</code> / <code>pathlib.Path.stat()</code> Reading <code>st_mtime</code>, <code>st_atime</code>, <code>st_ctime</code> (or <code>st_birthtime</code> on macOS)"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#improvement-notes_4","title":"Improvement Notes","text":"<p>The original performs an unnecessary round-trip. It formats a datetime to a string, then passes that string to <code>Date2UnixTime</code> which parses it back into a datetime object just to call <code>.ToUnixTimeMilliseconds()</code>. The Python port should extract the Unix timestamp directly from the stat result's float value: <code>int(stat_result.st_mtime * 1000)</code>. The formatted ISO string can be produced separately from the same source datetime. No round-trip parsing needed.</p> <p>Creation time portability. Windows provides a true creation time (<code>CreationTime</code>). Linux typically does not expose birth time in <code>os.stat()</code> unless the filesystem and kernel support <code>st_birthtime</code> (available on some systems via <code>os.stat_result.st_birthtime</code>). The port should attempt <code>st_birthtime</code> and fall back to <code>st_ctime</code> (metadata change time on Linux) with a documented caveat. This is a platform reality, not a bug.</p> <p>The date format string <code>yyyy-MM-ddTHH:mm:ss.fffffffzzz</code> uses .NET formatting tokens. The Python equivalent is <code>%Y-%m-%dT%H:%M:%S.%f%z</code>, noting that Python's <code>%f</code> gives microseconds (6 digits) rather than .NET's 7-digit fractional seconds. For backward compatibility, the port should zero-pad to 7 digits if exact schema match is required, or accept the 6-digit microsecond precision as a minor, acceptable deviation.</p>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#6-exif-embedded-metadata-extraction","title":"6. EXIF / Embedded Metadata Extraction","text":""},{"location":"porting-reference/MakeIndex_OperationsCatalog/#what-it-does_5","title":"What It Does","text":"<p>Invokes the <code>exiftool</code> binary against individual files to extract embedded EXIF/XMP/IPTC metadata. The exiftool arguments are Base64-encoded in the source and decoded at runtime, written to a temporary argument file, and passed to exiftool via its <code>-@</code> (argfile) switch. The raw JSON output from exiftool is piped through <code>jq</code> to compact it and strip unwanted system keys (ExifToolVersion, FileName, FilePath, Directory, FilePermissions, etc.). Certain file types (<code>.csv</code>, <code>.htm</code>, <code>.html</code>, <code>.json</code>, <code>.tsv</code>, <code>.xml</code>) are excluded because exiftool tends to dump their entire content into the metadata output.</p>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#where-it-lives-original_5","title":"Where It Lives (Original)","text":"Function Role <code>GetFileExif</code> Orchestrator: decodes args, manages temp file lifecycle, calls runner <code>GetFileExifArgsWrite</code> Decodes Base64 argument strings via <code>Base64DecodeString</code>, writes them to a temp file via <code>Add-Content</code> <code>GetFileExifRun</code> Executes <code>exiftool -@ $ArgsFile</code> and pipes output through <code>jq -c '.[] \\| .'</code> then a second <code>jq</code> pass to delete unwanted keys <code>Base64DecodeString</code> (external pslib) URL-decodes and Base64-decodes the argument strings with UTF-8 encoding support <code>TempOpen</code> / <code>TempClose</code> (external pslib) Creates and deletes the temporary argument file"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#python-modules_5","title":"Python Modules","text":"Module Usage <code>subprocess.run()</code> Invoking <code>exiftool</code> with arguments passed directly (no temp file needed) <code>json</code> Parsing exiftool's <code>-json</code> output directly (replaces <code>jq</code> entirely) <code>PyExifTool</code> (third-party, optional) A Python wrapper around exiftool that manages a persistent exiftool process for batch operations; significantly faster for large directory trees"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#improvement-notes_5","title":"Improvement Notes","text":"<p>Eliminate jq dependency entirely. The original pipes exiftool output through <code>jq</code> for two purposes: JSON compaction and key deletion. Python's <code>json.loads()</code> handles the parsing natively, and unwanted keys can be removed with a simple dict comprehension: <code>{k: v for k, v in data.items() if k not in EXCLUDED_KEYS}</code>. This eliminates a binary dependency with zero functionality loss.</p> <p>Eliminate the Base64 argument encoding scheme. The original stores exiftool arguments as Base64-encoded strings and decodes them at runtime via <code>Base64DecodeString</code> (which itself has a complex OpsCode-based branching pattern and calls <code>certutil</code> on Windows). This appears to have been a mechanism for safely embedding complex argument strings in the PowerShell source. In Python, we can simply define the arguments as a list of strings and pass them directly to <code>subprocess.run()</code>. This eliminates the entire <code>Base64DecodeString</code> \u2192 <code>TempOpen</code> \u2192 write-args \u2192 <code>TempClose</code> pipeline.</p> <p>Eliminate the temporary argument file. The original writes decoded arguments to a temp <code>.txt</code> file and passes it to exiftool via <code>-@</code>. The Python port should pass arguments directly via <code>subprocess.run(['exiftool', ...args, filepath])</code>. If argument lists are very long, <code>subprocess</code> handles them correctly on all platforms.</p> <p>Consider PyExifTool for batch mode. When indexing large directory trees, the original invokes <code>exiftool</code> once per file (a separate process spawn each time). <code>PyExifTool</code> keeps a single exiftool process alive and communicates with it via stdin/stdout, which is dramatically faster for batch operations. The port should support both modes: direct <code>subprocess</code> invocation for single-file use, and <code>PyExifTool</code> batch mode for directory traversal.</p> <p>The extension exclusion list (<code>.csv</code>, <code>.htm</code>, <code>.html</code>, <code>.json</code>, <code>.tsv</code>, <code>.xml</code>) should be externalized into configuration (see Category 11) rather than hardcoded, so users can customize it.</p>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#7-sidecar-metadata-file-handling","title":"7. Sidecar Metadata File Handling","text":""},{"location":"porting-reference/MakeIndex_OperationsCatalog/#what-it-does_6","title":"What It Does","text":"<p>Discovers, reads, parses, and optionally merges external metadata \"sidecar\" files that live alongside the files they describe. Sidecar files are identified by regex patterns matching known suffixes (defined in <code>$global:MetadataFileParser</code>). Each sidecar file undergoes type detection (matching against the <code>Identify</code> configuration), format-specific reading (JSON, plain text, binary/Base64, subtitles, hash files, URL/LNK shortcuts), and construction of a metadata entry object with source attribution, type, name, name hashes, and data payload. When <code>MetaMerge</code> is active, sidecar metadata is folded into the parent item's <code>Metadata</code> array. When <code>MetaMergeDelete</code> is active, merged sidecar files are queued for deletion after processing.</p>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#where-it-lives-original_6","title":"Where It Lives (Original)","text":"Function Role <code>GetFileMetaSiblings</code> Scans the parent directory for files matching the target basename + known metadata suffixes; uses regex with <code>[System.Text.RegularExpressions.Regex]::Escape()</code> for basename escaping <code>ReadMetaFile</code> Wrapper: calls <code>MetaFileRead</code>, adds name hashes, constructs standardized metadata entry objects <code>MetaFileRead</code> (external pslib) The actual parser: type detection, format-specific readers (<code>ReadJson</code>, <code>ReadText</code>, <code>ReadBinary</code>, <code>ReadText-Hash</code>, <code>ReadText-Subtitles</code>, <code>ReadLink</code>), parent file resolution, SHA256 hashing <code>ReadMetaFile-GetNameHashMD5</code> / <code>-SHA256</code> Hash the sidecar filename for the <code>NameHashes</code> field <code>$global:MetadataFileParser</code> Configuration object defining suffix patterns, exclusion patterns, and type identification rules <code>$global:DeleteQueue</code> Runtime accumulator for sidecar file paths to delete when <code>MetaMergeDelete</code> is active"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#python-modules_6","title":"Python Modules","text":"Module Usage <code>re</code> Regex pattern matching for sidecar file identification and type detection <code>json</code> Reading JSON-format sidecar files (replaces <code>jq -c '.'</code> piped through <code>ConvertFrom-Json</code>) <code>pathlib</code> Directory scanning for sibling files, basename extraction, suffix matching <code>hashlib</code> Name hashing for sidecar files (shared with Category 3) <code>base64</code> Reading binary sidecar files as Base64-encoded data (replaces <code>certutil -encode</code>)"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#improvement-notes_6","title":"Improvement Notes","text":"<p>Eliminate certutil dependency. The original uses <code>certutil -encode</code> to convert binary sidecar file data to Base64 strings. Python's <code>base64.b64encode()</code> does this natively and portably.</p> <p>Simplify type detection. The original iterates through all keys in <code>$MetadataFileParser.Identify</code> and matches each file against regex pattern arrays. This is fine algorithmically but the Python port should express this as a clean mapping structure (a dict of <code>{type_name: [compiled_regex_patterns]}</code>) rather than the deeply nested ordered hashtable structure of the original.</p> <p>The DeleteQueue pattern (accumulate paths during traversal, delete after completion) is sound and should be preserved. In Python this is simply a <code>list[Path]</code> built up during traversal and iterated at the end with <code>Path.unlink()</code>.</p>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#8-output-object-construction-schema","title":"8. Output Object Construction &amp; Schema","text":""},{"location":"porting-reference/MakeIndex_OperationsCatalog/#what-it-does_7","title":"What It Does","text":"<p>Assembles a structured data object (the \"index entry\") for every file and directory processed. Each entry contains identity fields (<code>_id</code>, <code>Ids</code>, <code>NameHashes</code>, <code>ContentHashes</code>), filesystem metadata (<code>Name</code>, <code>BaseName</code>, <code>Extension</code>, <code>StorageName</code>, <code>Size</code>, <code>IsDirectory</code>, <code>IsLink</code>), relationship fields (<code>ParentId</code>, <code>ParentIds</code>, <code>ParentName</code>, <code>ParentNameHashes</code>), timestamps (<code>TimeAccessed/Created/Modified</code>, <code>UnixTimeAccessed/Created/Modified</code>), child items (<code>Items</code> array for directories), and extracted metadata (<code>Metadata</code> array).</p> <p>The original output schema also includes an <code>Encoding</code> key (a complex object describing file encoding properties from BOM detection). This key is being intentionally dropped from the ported software.</p>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#where-it-lives-original_7","title":"Where It Lives (Original)","text":"Function Role <code>MakeObject</code> The core builder. Contains a massive <code>switch</code> on <code>$ObjectType</code> (<code>makeobjectfile</code>, <code>makeobjectdirectory</code>, <code>makeobjectdirectoryrecursive</code>) that constructs <code>[PSCustomObject]@{...}</code> with all schema fields. Repeated near-identically across 5+ switch branches. <code>VariableStringify</code> Null-safe string conversion used before inserting values into the output object <code>GetFileEncoding</code> BOM byte inspection for the <code>Encoding</code> field (being dropped)"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#python-modules_7","title":"Python Modules","text":"Module Usage <code>dataclasses</code> Define the output schema as <code>@dataclass</code> classes with type annotations; provides <code>asdict()</code> for JSON serialization. Strongly preferred for a project of this scope. <code>pydantic</code> (third-party, optional) Alternative to dataclasses with built-in validation, JSON schema generation, and serialization. More powerful but heavier dependency. Worth considering if schema validation against legacy consumers is important. <code>typing</code> Type annotations for nullable fields, union types, and recursive structures (<code>Items</code> referencing the same schema)"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#improvement-notes_7","title":"Improvement Notes","text":"<p>Eliminate the ObjectType switch duplication. The original <code>MakeObject</code> constructs the output object inside a <code>switch</code> statement with 5+ branches (<code>makeobjectfile</code>, <code>makeobjectdirectory</code>, <code>makeobjectdirectoryrecursive</code>, plus <code>default</code> branches). The actual fields are nearly identical across all branches \u2014 the only differences are: directories get <code>Items = @()</code> while files do not, and recursive directories get <code>Items = @()</code> for later population. The Python port should define one <code>IndexEntry</code> dataclass and conditionally populate <code>Items</code> and <code>Metadata</code> based on item type. One class, one construction path.</p> <p>Drop the <code>Encoding</code> key. As specified. The <code>GetFileEncoding</code> sub-function (BOM byte inspection) and all <code>$IEncoding</code> variable assignments are omitted from the port. For backward compatibility, the output schema can include <code>\"Encoding\": null</code> for all items if legacy consumers expect the field to exist. Alternatively, omit it entirely and let legacy consumers handle the missing key. This is a project decision to be made when we address backward compatibility testing.</p> <p>Typed schema definition. The original <code>[PSCustomObject]@{...}</code> has no compile-time type checking. Using Python <code>dataclasses</code> gives us type annotations, IDE support, and <code>dataclasses.asdict()</code> for clean JSON serialization. A rough sketch of the core structure:</p> <pre><code>IndexEntry:\n    _id: str\n    Ids: HashIds            # {MD5: str, SHA256: str, ...}\n    Name: str\n    NameHashes: HashIds | None\n    ContentHashes: HashIds | None\n    Extension: str | None\n    BaseName: str\n    StorageName: str\n    Size: int\n    IsDirectory: bool\n    IsLink: bool\n    ParentId: str | None\n    ParentIds: HashIds | None\n    ParentName: str | None\n    ParentNameHashes: HashIds | None\n    UnixTimeAccessed: int\n    UnixTimeCreated: int\n    UnixTimeModified: int\n    TimeAccessed: str\n    TimeCreated: str\n    TimeModified: str\n    Items: list[IndexEntry] | None   # Recursive reference; None for files\n    Metadata: list[MetadataEntry] | None\n</code></pre> <p>This sketch is illustrative. The actual implementation should be derived from the output schema JSON with adjustments for the dropped <code>Encoding</code> key and expanded hash fields.</p>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#9-json-serialization-output-routing","title":"9. JSON Serialization &amp; Output Routing","text":""},{"location":"porting-reference/MakeIndex_OperationsCatalog/#what-it-does_8","title":"What It Does","text":"<p>Converts the assembled index tree into JSON format and routes it to one or more output destinations. The original supports 7 distinct output scenarios combining three flags: <code>StandardOutput</code> (write to stdout), <code>OutFile</code> (write to a single aggregate file), and <code>OutFileInPlace</code> (write individual <code>_meta.json</code> sidecar files alongside each processed item). The <code>ConvertTo-Json -Depth 100</code> cmdlet is used for serialization, with a documented known issue: extremely large output trees can cause out-of-memory errors.</p>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#where-it-lives-original_8","title":"Where It Lives (Original)","text":"Function Role <code>MakeIndex</code> (top-level output logic) The 7-scenario routing switch at the end of the function; calls <code>ConvertTo-Json -Depth 100</code> and <code>Out-File -Encoding UTF8</code> or writes to stdout <code>MakeDirectoryIndexLogic</code> / <code>MakeDirectoryIndexRecursiveLogic</code> In-place sidecar writing via <code>ConvertTo-Json -Depth 100 \\| Set-Content -LiteralPath $FileMetaPath</code>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#python-modules_8","title":"Python Modules","text":"Module Usage <code>json</code> Standard library JSON serialization via <code>json.dumps()</code> with <code>indent</code> and <code>ensure_ascii=False</code> for UTF-8 output <code>orjson</code> (third-party, optional) Significantly faster JSON serialization for large trees; outputs bytes directly; handles <code>dataclasses</code> natively <code>sys.stdout</code> Standard output routing <code>pathlib.Path.write_text()</code> Writing JSON to output files and in-place sidecar files"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#improvement-notes_8","title":"Improvement Notes","text":"<p>The ConvertTo-Json memory problem does not exist in Python. Python's <code>json.dumps()</code> handles arbitrarily large nested structures without the memory ceiling that plagues PowerShell's <code>ConvertTo-Json</code>. If performance is a concern for very large trees (hundreds of thousands of items), <code>orjson</code> is a drop-in replacement that serializes 5-10x faster and produces bytes directly. The note in the original docstring about \"good luck, take it up with Microsoft\" can be retired.</p> <p>Simplify the output routing model. The original's 7-scenario matrix is confusing. The Python port should express this as three independent boolean flags that compose naturally: <code>--stdout</code>, <code>--outfile PATH</code>, <code>--inplace</code>. Any combination is valid. The routing logic becomes a simple loop over enabled destinations after the index tree is built (or during traversal for in-place writes).</p> <p>Streaming in-place writes. For in-place mode, the original writes each sidecar file as it processes items within the traversal loop. This is correct and should be preserved \u2014 it means partial results are available even if the process is interrupted. The aggregate output file and stdout writes happen after traversal completes, which is also correct.</p>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#10-file-rename-in-place-write-operations","title":"10. File Rename &amp; In-Place Write Operations","text":""},{"location":"porting-reference/MakeIndex_OperationsCatalog/#what-it-does_9","title":"What It Does","text":"<p>When the <code>Rename</code> flag is active, processed files are renamed from their original name to their hash-based <code>StorageName</code> (format: <code>&lt;_id&gt;.&lt;extension&gt;</code>). The original file is destroyed and replaced with the renamed version. A sidecar <code>_meta.json</code> file is written alongside each renamed file. Directory items get <code>_directorymeta.json</code> sidecar files. The <code>Rename</code> flag implies <code>OutFileInPlace</code>.</p>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#where-it-lives-original_9","title":"Where It Lives (Original)","text":"Function Role <code>MakeDirectoryIndexLogic</code> / <code>MakeDirectoryIndexRecursiveLogic</code> Contains the rename-or-not branching logic using <code>Move-Item -LiteralPath -Destination -Force</code> for renames and <code>Set-Content -LiteralPath -Force</code> for sidecar writes <code>MakeIndex</code> (parameter validation) Forces <code>OutFileInPlace = $true</code> when <code>Rename = $true</code> (safety measure)"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#python-modules_9","title":"Python Modules","text":"Module Usage <code>pathlib.Path.rename()</code> Atomic file rename (same filesystem) <code>shutil.move()</code> Cross-filesystem move if needed (fallback) <code>pathlib.Path.write_text()</code> Writing sidecar <code>_meta.json</code> files"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#improvement-notes_9","title":"Improvement Notes","text":"<p>The rename operation is destructive and irreversible in the original. The original docstring includes a \"To-Do\" note about adding a <code>Revert</code> parameter. The Python port should consider implementing revert capability from the start, since the in-place sidecar files contain the original filename in the <code>Name</code> field and can serve as the revert manifest.</p> <p>Safety: MetaMergeDelete guard. The original has a <code>$MMDSafe</code> variable that prevents <code>MetaMergeDelete</code> from activating unless an output mechanism (<code>OutFile</code> or <code>OutFileInPlace</code>) is specified, protecting against accidental metadata file deletion when no output is being captured. This safety logic should be preserved.</p>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#11-configuration-management","title":"11. Configuration Management","text":""},{"location":"porting-reference/MakeIndex_OperationsCatalog/#what-it-does_10","title":"What It Does","text":"<p>Loads and provides access to the parser configuration that governs metadata file behavior: which file suffixes are recognized as sidecar files, which types they map to, which file extensions are excluded from exiftool processing, and the regex patterns used for identification. The original stores this in a large <code>[ordered]@{}</code> hashtable (<code>$global:MetadataFileParser</code>) defined at the script level and promoted to global scope for access by deeply nested sub-functions.</p>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#where-it-lives-original_10","title":"Where It Lives (Original)","text":"Function Role <code>$global:MetadataFileParser</code> (script-level variable, line ~16977) The master configuration object containing <code>.Exiftool.Exclude</code>, <code>.Indexer.Include/Exclude/IncludeString/ExcludeString</code>, <code>.Identify.&lt;Key&gt;</code> sub-objects <code>MakeIndex</code> (parameter block) Copies sub-properties from <code>$MetadataFileParser</code> into global variables (<code>$global:ExiftoolRejectList</code>, <code>$global:MetaSuffixInclude</code>, etc.) at function start; cleans them up via <code>Remove-Variable</code> at function end"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#python-modules_10","title":"Python Modules","text":"Module Usage <code>dataclasses</code> Define configuration as typed <code>@dataclass</code> objects that can be validated at load time <code>tomllib</code> (Python 3.11+ stdlib) Load configuration from a TOML file; human-readable, well-suited for this kind of structured config <code>pyyaml</code> (third-party, optional) Alternative config format if TOML is insufficient <code>json</code> Alternative config format; the least human-friendly but the most schema-compatible"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#improvement-notes_10","title":"Improvement Notes","text":"<p>Eliminate global variable promotion entirely. The original promotes configuration values to <code>$global:</code> scope because PowerShell's nested function scoping makes it difficult to pass data into deeply nested sub-functions cleanly. Python has no such limitation. The configuration object should be instantiated once and passed through the call chain via function parameters, or held on a class instance if using an OOP architecture. No global state needed.</p> <p>Externalize the configuration to a file. The original hardcodes the configuration in the script source. The Python port should load it from an external file (TOML recommended) that ships alongside the tool as a default but can be overridden by the user. This makes the extension exclusion lists, sidecar suffix patterns, and type identification rules user-customizable without modifying source code.</p> <p>Provide sensible defaults. The port should include a built-in default configuration that matches the original's behavior, so the tool works out of the box without requiring a config file. The external config file should only be needed for customization.</p>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#12-logging-verbosity","title":"12. Logging &amp; Verbosity","text":""},{"location":"porting-reference/MakeIndex_OperationsCatalog/#what-it-does_11","title":"What It Does","text":"<p>Provides structured log output with severity levels (info, debug, warning, error, critical, success), caller identification via a colon-delimited call stack string, session IDs, colorized console output, and persistent log file writing. The <code>Vbs</code> function is the single most widely-called function in the entire pslib library \u2014 virtually every other function routes its output through it.</p>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#where-it-lives-original_11","title":"Where It Lives (Original)","text":"Function Role <code>Vbs</code> (external pslib) The terminal logging endpoint. Accepts <code>Caller</code>, <code>Status</code>, <code>Message</code>, <code>Verbosity</code>, <code>LogDir</code>, <code>LibName</code>, <code>VbsSessionID</code>. Writes to log files and optionally to colorized console output. <code>UpdateFunctionStack</code> Maintains the colon-delimited call-stack string (e.g., <code>\"MakeIndex:MakeObject:GetFileExif\"</code>) for the <code>Caller</code> parameter <code>VbsFormatter</code> (inside MetaFileRead) Wrapper that prepends a progress string to messages before passing them to <code>Vbs</code> <code>$LibSessionID</code> / <code>$D_PSLIB_LOGS</code> (global variables) Session identifier (GUID) and log directory path"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#python-modules_11","title":"Python Modules","text":"Module Usage <code>logging</code> Python's standard logging framework. Supports named loggers (replacing the manual call-stack string), severity levels, file handlers, console handlers with formatting, and session-scoped context via <code>LogRecord</code> attributes or <code>logging.LoggerAdapter</code>. <code>rich</code> (third-party, optional) Colorized console output, progress bars, and structured logging. If the port wants to replicate the colorized console output of <code>Vbs</code>, <code>rich.logging.RichHandler</code> is an excellent drop-in handler."},{"location":"porting-reference/MakeIndex_OperationsCatalog/#improvement-notes_11","title":"Improvement Notes","text":"<p>Eliminate <code>UpdateFunctionStack</code> entirely. The original manually builds a colon-delimited string (<code>\"MakeIndex:MakeObject:GetFileExif\"</code>) and passes it through every function call. Python's <code>logging</code> module automatically captures the call location via <code>%(funcName)s</code>, <code>%(module)s</code>, and <code>%(pathname)s</code> format tokens. For hierarchical logger names, the port should use Python's dotted-name logger convention (e.g., <code>logging.getLogger('indexer.make_object.get_file_exif')</code>). This gives the same traceability with zero manual bookkeeping.</p> <p>Replace the <code>Verbosity</code> boolean with standard log levels. The original has a binary verbosity toggle (<code>$true</code> / <code>$false</code>) that gates console output. Python's <code>logging</code> already supports <code>DEBUG</code>, <code>INFO</code>, <code>WARNING</code>, <code>ERROR</code>, <code>CRITICAL</code> levels, controlled by configuring the handler's level. The CLI can expose <code>--verbose</code> / <code>--debug</code> / <code>--quiet</code> flags that map to log levels.</p> <p>Session IDs are useful for correlating log entries across a single run. The Python port should generate one via <code>uuid.uuid4().hex</code> at startup and inject it into all log records using a <code>logging.Filter</code> or <code>LoggerAdapter</code>.</p>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#13-progress-reporting","title":"13. Progress Reporting","text":""},{"location":"porting-reference/MakeIndex_OperationsCatalog/#what-it-does_12","title":"What It Does","text":"<p>Tracks and reports processing progress during directory traversal: counts total items, computes percentage complete, measures elapsed time, and formats progress strings for log messages.</p>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#where-it-lives-original_12","title":"Where It Lives (Original)","text":"Function Role <code>MakeDirectoryIndexLogic</code> / <code>MakeDirectoryIndexRecursiveLogic</code> Maintains counters (<code>$ChildrenCountProcessed</code>, <code>$ChildrenCountTotal</code>), computes <code>[math]::Round()</code> percentage, formats progress strings like <code>\"[42/100 (42%)]\"</code> <code>MakeIndex</code> (top-level) Captures <code>$TimeStart</code> at the beginning, computes elapsed time at end using <code>(Get-Date) - $TimeStart</code> formatted as <code>H:M:S.ms</code>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#python-modules_12","title":"Python Modules","text":"Module Usage <code>tqdm</code> (third-party) Progress bars for iterables. Clean, minimal, widely used. Wrap the item iterator in <code>tqdm(items)</code> and progress reporting is automatic. <code>rich.progress</code> (third-party, optional) More visually sophisticated progress bars with elapsed time, ETA, and transfer rate. Pairs naturally with <code>rich</code> logging (see Category 12). <code>time.perf_counter()</code> High-resolution elapsed time measurement (replaces <code>Get-Date</code> arithmetic)"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#improvement-notes_12","title":"Improvement Notes","text":"<p>The original manually formats progress strings and injects them into log messages, creating tight coupling between progress tracking and logging. The Python port should separate these concerns: use a progress bar library (<code>tqdm</code> or <code>rich</code>) for user-facing progress display, and use the logging system for structured log output. They can coexist cleanly \u2014 <code>tqdm</code> even has a <code>tqdm.write()</code> method for printing messages without disrupting the progress bar, and <code>rich</code> integrates both natively.</p>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#14-cli-argument-parsing-entry-point","title":"14. CLI Argument Parsing &amp; Entry Point","text":""},{"location":"porting-reference/MakeIndex_OperationsCatalog/#what-it-does_13","title":"What It Does","text":"<p>Accepts user input specifying the target path, output mode, recursion behavior, metadata options, rename flag, ID type, and verbosity level. Validates input combinations (e.g., <code>File</code> and <code>Directory</code> are mutually exclusive; <code>Rename</code> implies <code>OutFileInPlace</code>). Routes execution to the appropriate traversal entry point based on the resolved target type (file, directory flat, directory recursive).</p>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#where-it-lives-original_13","title":"Where It Lives (Original)","text":"Function Role <code>MakeIndex</code> (Param block) Declares 14 parameters with aliases, types, defaults, and switch behaviors <code>MakeIndex</code> (validation and routing logic) ~200 lines of input validation, mutual exclusion checks, output scenario determination, and <code>TargetTyp</code> (0/1/2) routing"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#python-modules_13","title":"Python Modules","text":"Module Usage <code>click</code> (third-party) Decorator-based CLI framework. Clean syntax for defining commands, options, arguments, and mutual exclusions. Recommended for new Python CLI tools. <code>argparse</code> (stdlib) Standard library alternative. More verbose but zero dependencies."},{"location":"porting-reference/MakeIndex_OperationsCatalog/#improvement-notes_13","title":"Improvement Notes","text":"<p>The original's parameter validation contains a significant amount of defensive logic to handle conflicting flags (e.g., <code>Recursive</code> with <code>File</code>, <code>StandardOutput</code> with <code>NoStandardOutput</code>). <code>click</code> handles mutual exclusions declaratively, reducing the validation boilerplate. The original's 7 output scenarios can be expressed as three independent <code>--stdout</code> / <code>--outfile</code> / <code>--inplace</code> boolean flags with natural composition rules.</p> <p>The <code>IdType</code> parameter (selecting MD5 vs. SHA256 as the <code>_id</code> field source) should be preserved for backward compatibility. However, since the port will compute all four hash algorithms (see Category 3), this becomes a presentation choice rather than a computation toggle.</p>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#15-temporary-file-management","title":"15. Temporary File Management","text":""},{"location":"porting-reference/MakeIndex_OperationsCatalog/#what-it-does_14","title":"What It Does","text":"<p>Creates and deletes temporary files used as intermediaries during exiftool argument passing and Base64 encoding operations. Temp files use UUID-based naming in a dedicated temp directory.</p>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#where-it-lives-original_14","title":"Where It Lives (Original)","text":"Function Role <code>TempOpen</code> (external pslib) Creates a temp file using UUID+timestamp naming in <code>$D_PSLIB_TEMP</code>; supports type suffixes <code>TempClose</code> (external pslib) Deletes a temp file by path with error suppression <code>MetaFileRead-Temp-Open</code> / <code>MetaFileRead-Temp-Close</code> Duplicated temp file logic inside <code>MetaFileRead</code>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#python-modules_14","title":"Python Modules","text":"Module Usage <code>tempfile</code> <code>tempfile.NamedTemporaryFile()</code> or <code>tempfile.mkstemp()</code> for creating temp files with automatic cleanup. Context manager support ensures cleanup even on exceptions."},{"location":"porting-reference/MakeIndex_OperationsCatalog/#improvement-notes_14","title":"Improvement Notes","text":"<p>This category may be largely unnecessary in the Python port. The primary consumers of temp files in the original are (a) exiftool argument passing (eliminated by passing args directly to <code>subprocess</code>) and (b) <code>certutil</code> Base64 encoding (eliminated by using <code>base64.b64encode()</code>). If no operations remain that require temp files, this entire category can be dropped. If temp files are needed for any future operation, <code>tempfile.NamedTemporaryFile(delete=True)</code> with a context manager provides automatic cleanup that is strictly superior to the manual <code>TempOpen</code>/<code>TempClose</code> pattern.</p>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#eliminated-dependencies-summary","title":"Eliminated Dependencies Summary","text":"<p>The following original dependencies are not carried forward into the Python port because their functionality is absorbed by Python's standard library or rendered unnecessary by architectural improvements:</p> Original Dependency Reason for Elimination Replaced By <code>jq</code> (binary) JSON parsing and filtering done natively <code>json</code> stdlib <code>certutil</code> (binary) Base64 encoding done natively <code>base64</code> stdlib <code>Base64DecodeString</code> (pslib function) Exiftool args passed directly; no encoding round-trip needed Direct argument lists <code>TempOpen</code> / <code>TempClose</code> (pslib functions) No temp files needed for arg passing or Base64 ops <code>tempfile</code> (if needed at all) <code>Date2UnixTime</code> (pslib function) Timestamp conversion done directly from stat results <code>datetime</code> stdlib <code>Vbs</code> (pslib function) Replaced by Python's logging framework <code>logging</code> stdlib <code>ValidateIsLink</code> (pslib function) Never actually called in the original; dead code (removed) <code>GetFileEncoding</code> (internal sub-function) <code>Encoding</code> key dropped from output schema (removed) <code>UpdateFunctionStack</code> (internal sub-function) Manual call-stack tracking replaced by logging's built-in caller info <code>logging</code> stdlib <code>VariableStringify</code> (internal sub-function) Python's native <code>str()</code> and <code>None</code> handling cover this Built-in <code>str()</code> / <code>repr()</code>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#cross-reference-output-schema-fields-operation-categories","title":"Cross-Reference: Output Schema Fields \u2192 Operation Categories","text":"<p>This table maps every field in the output schema to the operation category that produces it, confirming full coverage.</p> Schema Field Category Notes <code>_id</code> 3 (Hashing) Selected from <code>Ids</code> based on <code>IdType</code> parameter <code>Ids</code> 3 (Hashing) <code>{MD5, SHA1, SHA256, SHA512}</code> \u2014 expanded from original's MD5+SHA256 only <code>Name</code> 2 (Path Manipulation) <code>Path.name</code> <code>NameHashes</code> 3 (Hashing) Hash of the <code>Name</code> string <code>ContentHashes</code> 3 (Hashing) Hash of file contents; <code>null</code> for directories <code>Extension</code> 2 (Path Manipulation) <code>Path.suffix</code> with validation <code>BaseName</code> 2 (Path Manipulation) <code>Path.stem</code> <code>StorageName</code> 3 (Hashing) + 2 (Path) <code>f\"{_id}{extension}\"</code> for files; <code>_id</code> for directories ~~<code>Encoding</code>~~ ~~(Dropped)~~ Intentionally omitted from port <code>Size</code> 1 (Traversal) <code>Path.stat().st_size</code> for files; sum of children for directories <code>IsDirectory</code> 1 (Traversal) <code>Path.is_dir()</code> <code>IsLink</code> 4 (Symlink) <code>Path.is_symlink()</code> <code>ParentId</code> 3 (Hashing) Directory ID of parent <code>ParentIds</code> 3 (Hashing) Hash IDs of parent directory <code>ParentName</code> 2 (Path Manipulation) <code>Path.parent.name</code> <code>ParentNameHashes</code> 3 (Hashing) Hash of parent directory name <code>UnixTimeAccessed</code> 5 (Timestamps) <code>int(stat.st_atime * 1000)</code> <code>UnixTimeCreated</code> 5 (Timestamps) <code>int(stat.st_birthtime * 1000)</code> or <code>st_ctime</code> fallback <code>UnixTimeModified</code> 5 (Timestamps) <code>int(stat.st_mtime * 1000)</code> <code>TimeAccessed</code> 5 (Timestamps) ISO 8601 formatted string <code>TimeCreated</code> 5 (Timestamps) ISO 8601 formatted string <code>TimeModified</code> 5 (Timestamps) ISO 8601 formatted string <code>Items</code> 1 (Traversal) + 8 (Object Construction) Recursive child entries for directories; <code>null</code> for files <code>Metadata</code> 6 (EXIF) + 7 (Sidecar) Array of metadata entries from exiftool and sidecar files"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#minimum-viable-dependency-set","title":"Minimum Viable Dependency Set","text":"<p>For a Python port that achieves full feature parity (minus the intentionally dropped <code>Encoding</code> key) with the original MakeIndex:</p>"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#required-standard-library-only","title":"Required (Standard Library Only)","text":"Module Categories Served <code>pathlib</code> 1, 2, 4, 7, 9, 10 <code>hashlib</code> 3 <code>datetime</code> 5 <code>json</code> 6, 7, 8, 9 <code>subprocess</code> 6 <code>re</code> 7, 11 <code>logging</code> 12 <code>os</code> 1, 5 <code>sys</code> 9 <code>tempfile</code> 15 (if needed) <code>base64</code> 7 <code>dataclasses</code> 8, 11 <code>typing</code> 8 <code>tomllib</code> 11 (Python 3.11+) <code>uuid</code> 12 <code>time</code> 13"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#required-external","title":"Required (External)","text":"Module Categories Served Notes <code>exiftool</code> (binary) 6 Must be in system PATH; the only external binary dependency"},{"location":"porting-reference/MakeIndex_OperationsCatalog/#recommended-third-party-optional","title":"Recommended (Third-Party, Optional)","text":"Module Categories Served Justification <code>click</code> 14 Cleaner CLI definition than <code>argparse</code>; widely adopted <code>tqdm</code> 13 Progress bars with minimal code <code>orjson</code> 9 5-10x faster JSON serialization for large trees <code>PyExifTool</code> 6 Persistent exiftool process for batch performance <code>rich</code> 12, 13 Colorized logging + progress bars in one package; alternative to <code>tqdm</code> + custom log formatting <code>pydantic</code> 8, 11 Schema validation and JSON schema generation; heavier alternative to <code>dataclasses</code>"},{"location":"porting-reference/MetaFileRead_DependencyCatalog/","title":"MetaFileRead \u2014 Dependency Catalog","text":"<p>Source: <code>main.ps1</code>, line 10233 Purpose: Reads and parses metadata sidecar files, determining their type, associated parent file, and internal data content Audience: AI-first, Human-second  </p>"},{"location":"porting-reference/MetaFileRead_DependencyCatalog/#1-external-pslib-functions-called","title":"1. External PsLib Functions Called","text":"Function Defined At Called From Purpose <code>Lnk2Path</code> main.ps1:7283 <code>MetaFileRead-Data-ReadLink</code> Resolves a <code>.lnk</code> shortcut file to its target path <code>UrlFile2Url</code> main.ps1:15843 <code>MetaFileRead-Data-ReadLink</code> Extracts the URL from a <code>.url</code> internet shortcut file <code>ValidateIsFile</code> main.ps1:16098 Top-level body Validates that the input string references an existing file. Returns a boolean <code>ValidateIsJson</code> main.ps1:16189 <code>MetaFileRead-Data</code> Validates whether a file contains valid JSON. Returns a boolean <code>Vbs</code> main.ps1:16412 Throughout (via <code>VbsFormatter</code> wrapper) Verbose/logging output handler. Called indirectly through the internal <code>VbsFormatter</code> wrapper, which auto-formats messages with progress strings when available"},{"location":"porting-reference/MetaFileRead_DependencyCatalog/#implicit-external-dependency-globalmetadatafileparser","title":"Implicit External Dependency: <code>$global:MetadataFileParser</code>","text":"<p>This function receives the <code>$global:MetadataFileParser</code> configuration object as both a parameter default and a passed-through argument to multiple sub-functions. The <code>MetadataFileParser</code> object (defined at main.ps1:16977) governs all type-detection regex patterns, file-extension classification rules, and indexer include/exclude patterns. Without this object being populated at runtime, the function cannot detect meta file types or validate input files.</p>"},{"location":"porting-reference/MetaFileRead_DependencyCatalog/#2-external-variables-loaded","title":"2. External Variables Loaded","text":"Variable Defined At Type Description <code>$global:MetadataFileParser</code> main.ps1:16977 <code>[ordered]@{}</code> (Hashtable) Large configuration object governing metadata file parsing behavior. Consumed sub-properties include:<code>.Indexer.IncludeString</code> \u2014 Regex string used to validate that the input file qualifies as a metadata file<code>.Identify.&lt;Key&gt;</code> \u2014 Sub-objects mapping metadata file types (Description, GenericMetadata, Hash, JsonMetadata, Link, Screenshot, Subtitles, Thumbnail, Torrent) to their regex detection patterns"},{"location":"porting-reference/MetaFileRead_DependencyCatalog/#3-external-binaries-executables-invoked","title":"3. External Binaries / Executables Invoked","text":"Binary Called From (within MetaFileRead) How Invoked Purpose <code>certutil</code> <code>MetaFileRead-Data-Base64Encode</code> <code>certutil -encode \"$FilePath\" \"$TempFile\" &gt; $null</code> Encodes binary file data to Base64 (used for Screenshot, Thumbnail, Torrent, and binary fallback data) <code>jq</code> <code>MetaFileRead-Data-ReadJson</code> <code>jq -c '.' \"$FilePath\" 2&gt; $null</code> Reads and compacts JSON data from metadata files. Output is piped through <code>ConvertFrom-Json</code>"},{"location":"porting-reference/MetaFileRead_DependencyCatalog/#note-on-binary-resolution","title":"Note on Binary Resolution","text":"<p>Neither <code>certutil</code> nor <code>jq</code> are referenced via absolute paths. <code>certutil</code> is a Windows system utility and is expected to be available in the system PATH. <code>jq</code> must also be available in the system PATH. The <code>jq</code> dependency is shared with the <code>MakeIndex</code> function which also uses <code>jq</code> for JSON processing.</p>"},{"location":"porting-reference/MetaFileRead_DependencyCatalog/#4-parameters","title":"4. Parameters","text":"Parameter Type Alias(es) Default Description <code>File</code> <code>[System.String]</code> <code>inputfile</code> (none) The absolute path to the metadata file to read <code>Format</code> <code>[System.String]</code> (none) <code>'json'</code> Output format. ValidatePattern: <code>^(json|object|text)$</code> <code>ProgressString</code> <code>[System.String]</code> (none) (none) Optional progress prefix string prepended to verbose messages by the <code>VbsFormatter</code> wrapper <code>Verbosity</code> <code>[System.Boolean]</code> <code>v</code> <code>$false</code> Controls whether verbose/log messages are printed to the console <code>$global:MetadataFileParser</code> <code>[System.Object]</code> (none) <code>$global:MetadataFileParser</code> Internal parameter: the metadata parser configuration object passed through from the global scope"},{"location":"porting-reference/MetaFileRead_DependencyCatalog/#5-internal-sub-functions-defined-within-metafileread","title":"5. Internal Sub-Functions (Defined Within MetaFileRead)","text":""},{"location":"porting-reference/MetaFileRead_DependencyCatalog/#top-level-internal-functions","title":"Top-Level Internal Functions","text":"Function Purpose Calls (internal) Calls (external) <code>MetaFileRead-Data</code> Dispatcher: reads the internal data of a meta file based on its detected type. Routes to type-specific reader sub-functions <code>MetaFileRead-Data-Base64Encode</code>, <code>MetaFileRead-Data-IsText</code>, <code>MetaFileRead-Data-ReadBinary</code>, <code>MetaFileRead-Data-ReadJson</code>, <code>MetaFileRead-Data-ReadLink</code>, <code>MetaFileRead-Data-ReadText</code>, <code>MetaFileRead-Data-ReadText-Hash</code>, <code>MetaFileRead-Data-ReadText-Subtitles</code> <code>ValidateIsJson</code>, <code>VbsFormatter</code> <code>MetaFileRead-Detect</code> Iterates through <code>$MetadataFileParser.Identify</code> keys and matches the input file name against regex patterns to determine the meta file type \u2014 \u2014 <code>MetaFileRead-Parent</code> Determines the parent file/directory associated with a given meta file by analyzing sibling files in the same directory <code>MetaFileRead-Parent-Base</code>, <code>MetaFileRead-Parent-Keys-Orphan</code>, <code>MetaFileRead-Parent-Keys-Directory</code>, <code>MetaFileRead-Parent-Keys-File</code>, <code>MetaFileRead-Parent-List-Audio</code>, <code>MetaFileRead-Parent-List-Image</code>, <code>MetaFileRead-Parent-List-Other</code>, <code>MetaFileRead-Parent-List-Video</code> <code>VbsFormatter</code> <code>MetaFileRead-Sha256-File</code> Computes SHA256 hash of a file's contents (used for the <code>_id</code> field) \u2014 <code>VbsFormatter</code> <code>MetaFileRead-Sha256-String</code> Computes SHA256 hash of a string (used for <code>NameHash</code> fields) \u2014 <code>VbsFormatter</code> <code>MetaFileRead-Temp-Close</code> Deletes a temporary file by path \u2014 <code>VbsFormatter</code> <code>MetaFileRead-Temp-Open</code> Creates a temporary file in <code>$D_PSLIB_TEMP</code> and returns its path. Uses UUID+timestamp naming \u2014 \u2014 <code>VbsFormatter</code> Internal wrapper around the external <code>Vbs</code> function. Auto-prepends the <code>$ProgressString</code> to log messages when present \u2014 <code>Vbs</code>"},{"location":"porting-reference/MetaFileRead_DependencyCatalog/#nested-internal-functions-defined-inside-other-internal-functions","title":"Nested Internal Functions (defined inside other internal functions)","text":"Function Parent Function Purpose <code>MetaFileRead-Data-Base64Encode</code> <code>MetaFileRead-Data</code> Encodes file data to Base64 using <code>certutil</code>. Creates and cleans up a temp file <code>MetaFileRead-Data-IsText</code> <code>MetaFileRead-Data</code> Tests whether a file contains valid text by attempting <code>Get-Content -Raw</code> in a try/catch <code>MetaFileRead-Data-ReadBinary</code> <code>MetaFileRead-Data</code> Reads binary file data by delegating to <code>MetaFileRead-Data-Base64Encode</code> <code>MetaFileRead-Data-ReadJson</code> <code>MetaFileRead-Data</code> Reads JSON file data using <code>jq -c '.'</code> piped through <code>ConvertFrom-Json</code> <code>MetaFileRead-Data-ReadLink</code> <code>MetaFileRead-Data</code> Reads <code>.url</code> files via <code>UrlFile2Url</code> or <code>.lnk</code> files via <code>Lnk2Path</code> <code>MetaFileRead-Data-ReadText</code> <code>MetaFileRead-Data</code> Reads file as UTF8 text via <code>[System.IO.File]::ReadAllText()</code> <code>MetaFileRead-Data-ReadText-Hash</code> <code>MetaFileRead-Data</code> Reads hash files as text lines via <code>Get-Content</code>, filtering out empty lines <code>MetaFileRead-Data-ReadText-Subtitles</code> <code>MetaFileRead-Data</code> Reads subtitle files as text lines via <code>Get-Content</code>, filtering out empty lines <code>MetaFileRead-Parent-Base</code> <code>MetaFileRead-Parent</code> Strips the metadata suffix from the meta file name to derive the base parent file name. Uses single-pass or multi-pass regex replacement depending on the meta type <code>MetaFileRead-Parent-Keys-Orphan</code> <code>MetaFileRead-Parent</code> Returns a PSCustomObject with orphan parent properties (Name=null, Type=\"orphan\", Exists=$false) <code>MetaFileRead-Parent-Keys-Directory</code> <code>MetaFileRead-Parent</code> Returns a PSCustomObject with directory parent properties <code>MetaFileRead-Parent-Keys-File</code> <code>MetaFileRead-Parent</code> Returns a PSCustomObject with file parent properties <code>MetaFileRead-Parent-List-Audio</code> <code>MetaFileRead-Parent</code> Filters directory matches to audio file extensions <code>MetaFileRead-Parent-List-Image</code> <code>MetaFileRead-Parent</code> Filters directory matches to image file extensions <code>MetaFileRead-Parent-List-Other</code> <code>MetaFileRead-Parent</code> Filters directory matches to other file extensions <code>MetaFileRead-Parent-List-Video</code> <code>MetaFileRead-Parent</code> Filters directory matches to video file extensions"},{"location":"porting-reference/MetaFileRead_DependencyCatalog/#6-internal-logic-summary","title":"6. Internal Logic Summary","text":"<p>Processing Pipeline:</p> <ol> <li> <p>Input Validation: The input file path is checked for non-empty string and existence via <code>ValidateIsFile</code>. The file is then matched against <code>$global:MetadataFileParser.Indexer.IncludeString</code> to confirm it qualifies as a metadata file.</p> </li> <li> <p>Type Detection: The <code>MetaFileRead-Detect</code> function iterates through all keys in <code>$MetadataFileParser.Identify</code> and matches the file name against each type's regex pattern array. A single match is expected; zero or multiple matches produce an error and an empty output.</p> </li> <li> <p>Parent Resolution: The <code>MetaFileRead-Parent</code> function determines which file or directory the metadata file is associated with. It strips the metadata suffix from the file name to produce a \"base\" string, then scans sibling entries in the same directory for matches. Matches are classified by media type (audio, image, video, other) and the parent is assigned based on the meta file type's prioritization rules (e.g., Description files prioritize video parents; Subtitles prioritize video then audio). Unmatched meta files are classified as orphans.</p> </li> <li> <p>Data Reading: The <code>MetaFileRead-Data</code> function dispatches to a type-specific reader based on the detected meta type. Text-based types are tested with both JSON and text validation; binary types (Screenshot, Thumbnail, Torrent) are Base64-encoded via <code>certutil</code>. Link types are resolved to their target paths.</p> </li> <li> <p>Output Assembly: The final output object is constructed with <code>_id</code> (SHA256 of file contents), <code>Name</code>, <code>NameHash</code>, <code>Path</code>, <code>Type</code>, <code>Parent</code> (sub-object), and <code>Data</code> fields. Output is formatted as JSON, object, or text based on the <code>-Format</code> parameter.</p> </li> </ol> <p>Recognized Meta File Types:</p> Type Data Handling <code>Description</code> JSON \u2192 text \u2192 binary fallback chain <code>GenericMetadata</code> JSON \u2192 text \u2192 binary fallback chain <code>Hash</code> Read as text lines (single-line expected) <code>JsonMetadata</code> Read directly as JSON via <code>jq</code> <code>Link</code> Resolve <code>.url</code> via <code>UrlFile2Url</code> or <code>.lnk</code> via <code>Lnk2Path</code> <code>Screenshot</code> Base64-encode binary data <code>Subtitles</code> JSON \u2192 text \u2192 binary fallback chain <code>Thumbnail</code> Base64-encode binary data <code>Torrent</code> Base64-encode binary data"},{"location":"porting-reference/MetaFileRead_DependencyCatalog/#7-output-object-properties","title":"7. Output Object Properties","text":"<p>The full <code>[PSCustomObject]</code> (returned when <code>-Format \"object\"</code> is specified) contains:</p> Property Type Description <code>_id</code> <code>[String]</code> SHA256 hash of the meta file's contents <code>Name</code> <code>[String]</code> The file name of the meta file <code>NameHash</code> <code>[String]</code> SHA256 hash of the file name string <code>Path</code> <code>[String]</code> Absolute path to the meta file <code>Type</code> <code>[String]</code> The detected meta file type (e.g., <code>Description</code>, <code>JsonMetadata</code>) <code>Parent</code> <code>[PSCustomObject]</code> Sub-object describing the associated parent. Properties: <code>Base</code>, <code>Name</code>, <code>NameHash</code>, <code>Path</code>, <code>Type</code> (\"file\"/\"orphan\"/\"directory\"), <code>Extension</code>, <code>Exists</code>, <code>PossibleMatches</code> <code>Data</code> <code>[Object]</code> The parsed internal data of the meta file. Type varies: string, PSCustomObject (from JSON), array of lines, Base64 string, or <code>$null</code>"},{"location":"porting-reference/MetaFileRead_DependencyCatalog/#8-net-types-and-methods-used","title":"8. .NET Types and Methods Used","text":"Type / Method Usage <code>[System.IO.File]::OpenRead()</code> File content hashing for <code>_id</code> generation <code>[System.IO.File]::ReadAllText()</code> Reading text-based meta file contents (UTF8) <code>[System.IO.Path]::GetDirectoryName()</code> Extracting parent directory path from meta file path <code>[System.IO.Path]::GetFileName()</code> Extracting file name from path <code>[System.Security.Cryptography.SHA256]::Create()</code> SHA256 hash computation (for <code>_id</code> and <code>NameHash</code>) <code>[System.Text.Encoding]::UTF8</code> Encoding constant for string-to-bytes conversion and file reading <code>[BitConverter]::ToString()</code> Byte-array \u2192 hex-string conversion <code>[System.GUID]::NewGuid()</code> UUID generation for temp file names <code>[DateTimeOffset]::Now.ToUnixTimeMilliseconds()</code> Timestamp component in temp file names <code>[Regex]::Escape()</code> Escaping base name strings for regex matching <code>[PSCustomObject]@{}</code> Output object and parent object construction"},{"location":"porting-reference/MetaFileRead_DependencyCatalog/#9-powershell-built-in-cmdlets-used","title":"9. PowerShell Built-in Cmdlets Used","text":"Cmdlet Usage Context <code>Add-Content</code> (Not directly used, but <code>certutil</code> writes to the temp file) <code>ConvertFrom-Json</code> Parsing <code>jq</code> output into PowerShell objects <code>ConvertTo-Json</code> Serializing final output when <code>-Format \"json\"</code> (<code>-Depth 100</code>) <code>Get-ChildItem</code> Listing directory contents to find sibling files for parent resolution (<code>-LiteralPath</code>, <code>-Force</code>) <code>Get-Content</code> Reading text-based meta file data (<code>-LiteralPath</code>, <code>-Encoding \"UTF8\"</code>, <code>-Raw</code>) <code>Get-Item</code> Retrieving file/directory properties (Name, Extension, FullName, PSIsContainer) (<code>-LiteralPath</code>, <code>-Force</code>) <code>New-Item</code> Creating temporary files (<code>-ItemType File</code>, <code>-Force</code>) <code>Remove-Item</code> Deleting temporary files (<code>-LiteralPath</code>, <code>-Force</code>) <code>Resolve-Path</code> Resolving file paths to absolute form (<code>-LiteralPath</code>) <code>Select-Object</code> Skipping certutil header/footer lines (<code>-Skip 1</code>, <code>-SkipLast 1</code>) <code>Set-Content</code> (Not used directly in MetaFileRead but available in the broader pipeline) <code>Test-Path</code> Validating file/directory existence (<code>-LiteralPath</code>, <code>-PathType Leaf/Container</code>) <code>Where-Object</code> Filtering empty lines from file contents; filtering directory matches by name"},{"location":"porting-reference/MetaFileRead_DependencyCatalog/#10-return-value","title":"10. Return Value","text":"<p>With <code>-Format \"json\"</code> (default): Returns a JSON-formatted string of the full output object.</p> <p>With <code>-Format \"object\"</code>: Returns the <code>[PSCustomObject]</code> described in Section 7.</p> <p>With <code>-Format \"text\"</code>: Returns only the <code>Type</code> property as a string.</p> <p>Returns <code>$null</code> if the input file is empty, does not exist, or does not validate as a meta file.</p> <p>Returns an empty object (<code>'{}'</code> for JSON, <code>[PSCustomObject]@{}</code> for object, <code>'null'</code> for text) if type detection fails (zero or multiple type matches).</p>"},{"location":"porting-reference/MetaFileRead_DependencyCatalog/#11-call-graph","title":"11. Call Graph","text":"<pre><code>MetaFileRead\n\u251c\u2500\u2500 [validates File parameter is non-empty]\n\u2502   \u2514\u2500\u2500 VbsFormatter \u2192 Vbs \u25c4\u2500\u2500 external pslib\n\u251c\u2500\u2500 ValidateIsFile \u25c4\u2500\u2500 external pslib\n\u251c\u2500\u2500 [matches against MetadataFileParser.Indexer.IncludeString]\n\u251c\u2500\u2500 MetaFileRead-Detect (type detection via MetadataFileParser.Identify)\n\u251c\u2500\u2500 MetaFileRead-Parent (parent resolution)\n\u2502   \u251c\u2500\u2500 MetaFileRead-Parent-Base (strip suffix)\n\u2502   \u251c\u2500\u2500 Get-ChildItem (list siblings)\n\u2502   \u251c\u2500\u2500 MetaFileRead-Parent-List-Audio/Image/Other/Video (classify matches)\n\u2502   \u2514\u2500\u2500 MetaFileRead-Parent-Keys-File / -Directory / -Orphan (build parent object)\n\u2502       \u2514\u2500\u2500 MetaFileRead-Sha256-String (hash parent name)\n\u251c\u2500\u2500 MetaFileRead-Data (data reading)\n\u2502   \u251c\u2500\u2500 ValidateIsJson \u25c4\u2500\u2500 external pslib\n\u2502   \u251c\u2500\u2500 MetaFileRead-Data-IsText\n\u2502   \u251c\u2500\u2500 MetaFileRead-Data-ReadJson \u2192 jq \u25c4\u2500\u2500 BINARY\n\u2502   \u251c\u2500\u2500 MetaFileRead-Data-ReadText\n\u2502   \u251c\u2500\u2500 MetaFileRead-Data-ReadText-Hash\n\u2502   \u251c\u2500\u2500 MetaFileRead-Data-ReadText-Subtitles\n\u2502   \u251c\u2500\u2500 MetaFileRead-Data-ReadBinary\n\u2502   \u2502   \u2514\u2500\u2500 MetaFileRead-Data-Base64Encode \u2192 certutil \u25c4\u2500\u2500 BINARY\n\u2502   \u2502       \u251c\u2500\u2500 MetaFileRead-Temp-Open\n\u2502   \u2502       \u2514\u2500\u2500 MetaFileRead-Temp-Close\n\u2502   \u2514\u2500\u2500 MetaFileRead-Data-ReadLink\n\u2502       \u251c\u2500\u2500 UrlFile2Url \u25c4\u2500\u2500 external pslib\n\u2502       \u2514\u2500\u2500 Lnk2Path \u25c4\u2500\u2500 external pslib\n\u251c\u2500\u2500 MetaFileRead-Sha256-String (hash file name \u2192 NameHash)\n\u251c\u2500\u2500 MetaFileRead-Sha256-File (hash file contents \u2192 _id)\n\u2514\u2500\u2500 [format output based on -Format parameter]\n</code></pre>"},{"location":"porting-reference/TempClose_DependencyCatalog/","title":"TempClose \u2014 Dependency Catalog","text":"<p>Source: <code>main.ps1</code>, line 15044 Purpose: Deletes a specified temporary file, or optionally purges all temp files from the pslib temp directory Audience: AI-first, Human-second  </p>"},{"location":"porting-reference/TempClose_DependencyCatalog/#1-external-pslib-functions-called","title":"1. External PsLib Functions Called","text":"Function Defined At Called From Purpose <code>Vbs</code> main.ps1:16412 Top-level body Verbose/logging output handler. Called with <code>-Caller</code>, <code>-Status</code> (i/e/w), <code>-Message</code>, <code>-Verbosity</code> for info, error, and warning logging"},{"location":"porting-reference/TempClose_DependencyCatalog/#2-external-variables-loaded","title":"2. External Variables Loaded","text":"Variable Defined At Type Description <code>$D_PSLIB_TEMP</code> main.ps1:17400 <code>[System.String]</code> The absolute path to the pslib temporary file directory (<code>C:\\bin\\pslib\\temp</code>). Used when <code>-ForceAll</code> is <code>$true</code> to enumerate and delete all temp files in the directory"},{"location":"porting-reference/TempClose_DependencyCatalog/#3-external-binaries-executables-invoked","title":"3. External Binaries / Executables Invoked","text":"Binary Notes (none) This function is entirely PowerShell-based and does not invoke any external executables."},{"location":"porting-reference/TempClose_DependencyCatalog/#4-parameters","title":"4. Parameters","text":"Parameter Type Alias(es) Default Description <code>Target</code> <code>[System.String]</code> <code>f</code>, <code>fil</code>, <code>i</code>, <code>in</code>, <code>input</code>, <code>t</code>, <code>tmp</code>, <code>temp</code> <code>$null</code> The absolute path to the temporary file to delete <code>ForceAll</code> <code>[System.Boolean]</code> <code>force</code> <code>$false</code> If <code>$true</code>, ignores the <code>-Target</code> parameter and deletes all files in <code>$D_PSLIB_TEMP</code> recursively <code>Verbosity</code> <code>[System.Boolean]</code> <code>v</code> <code>$false</code> Controls whether verbose/log messages are printed to the console"},{"location":"porting-reference/TempClose_DependencyCatalog/#5-internal-sub-functions","title":"5. Internal Sub-Functions","text":"<p>This function defines no internal sub-functions.</p>"},{"location":"porting-reference/TempClose_DependencyCatalog/#6-internal-logic-summary","title":"6. Internal Logic Summary","text":"<p>The function operates in one of three modes based on the parameter values:</p> <p>Mode 1 \u2014 ForceAll (<code>-ForceAll $true</code>): Ignores the <code>-Target</code> parameter entirely. Enumerates all files in <code>$D_PSLIB_TEMP</code> recursively via <code>Get-ChildItem</code> with <code>-Filter \"*.*\"</code>. If files are found, each is deleted via <code>Remove-Item -Force</code>. If no files exist, an informational message is logged and the function returns.</p> <p>Mode 2 \u2014 Single Target Deletion (default): If <code>-Target</code> is provided and the file exists, it is deleted via <code>Remove-Item -LiteralPath -Force</code>.</p> <p>Mode 3 \u2014 Error States: If <code>-ForceAll</code> is <code>$false</code> and <code>-Target</code> is <code>$null</code>, an error message is logged. If <code>-Target</code> is provided but the file does not exist, a warning message is logged (but the function does not throw an error).</p>"},{"location":"porting-reference/TempClose_DependencyCatalog/#7-net-types-and-methods-used","title":"7. .NET Types and Methods Used","text":"Type / Method Usage (none) This function uses only PowerShell cmdlets; no .NET types are directly invoked."},{"location":"porting-reference/TempClose_DependencyCatalog/#8-powershell-built-in-cmdlets-used","title":"8. PowerShell Built-in Cmdlets Used","text":"Cmdlet Usage Context <code>Get-ChildItem</code> Enumerating temp files when <code>-ForceAll</code> is active (<code>-LiteralPath</code>, <code>-Filter \"*.*\"</code>, <code>-Recurse</code>, <code>-Force</code>) <code>Remove-Item</code> Deleting temp files (<code>-LiteralPath</code>, <code>-Force</code>) <code>Test-Path</code> Validating target file existence before deletion (<code>-LiteralPath</code>, <code>-PathType Leaf</code>)"},{"location":"porting-reference/TempClose_DependencyCatalog/#9-return-value","title":"9. Return Value","text":"<p>This function does not return a value. All code paths terminate with <code>return</code> (no value).</p>"},{"location":"porting-reference/TempClose_DependencyCatalog/#10-companion-function-tempopen","title":"10. Companion Function: TempOpen","text":"<p><code>TempClose</code> is designed to be used in conjunction with <code>TempOpen</code> (main.ps1:15119). The expected usage pattern is:</p> <pre><code>$MyTempFile = (TempOpen -Type json -Name \"myProject\")\n# ... use $MyTempFile ...\nTempClose -Target $MyTempFile\n</code></pre> <p>The <code>TempOpen</code> docstring explicitly warns that failing to call <code>TempClose</code> will leave orphaned temp files in the pslib temp directory. The <code>-ForceAll</code> mode provides a way to clean up all orphaned files at once.</p>"},{"location":"porting-reference/TempClose_DependencyCatalog/#11-call-graph","title":"11. Call Graph","text":"<pre><code>TempClose\n\u251c\u2500\u2500 (ForceAll=$true)\n\u2502   \u251c\u2500\u2500 Get-ChildItem on $D_PSLIB_TEMP\n\u2502   \u251c\u2500\u2500 Vbs \u25c4\u2500\u2500 external pslib (info: count or \"nothing to do\")\n\u2502   \u2514\u2500\u2500 foreach file \u2192 Remove-Item\n\u2502       \u2514\u2500\u2500 Vbs \u25c4\u2500\u2500 external pslib (info: \"Closing temp file\")\n\u251c\u2500\u2500 (ForceAll=$false, Target=$null)\n\u2502   \u2514\u2500\u2500 Vbs \u25c4\u2500\u2500 external pslib (error: \"No input detected\")\n\u251c\u2500\u2500 (ForceAll=$false, Target does not exist)\n\u2502   \u2514\u2500\u2500 Vbs \u25c4\u2500\u2500 external pslib (warning: \"File not found\")\n\u2514\u2500\u2500 (ForceAll=$false, Target exists)\n    \u251c\u2500\u2500 Vbs \u25c4\u2500\u2500 external pslib (info: \"Closing referenced temp file\")\n    \u2514\u2500\u2500 Remove-Item\n</code></pre>"},{"location":"porting-reference/TempOpen_DependencyCatalog/","title":"TempOpen \u2014 Dependency Catalog","text":"<p>Source: <code>main.ps1</code>, line 15119 Purpose: Creates a new temporary file in the pslib temp directory with a UUID-based name and returns the absolute path to it Audience: AI-first, Human-second  </p>"},{"location":"porting-reference/TempOpen_DependencyCatalog/#1-external-pslib-functions-called","title":"1. External PsLib Functions Called","text":"Function Defined At Called From Purpose <code>Vbs</code> main.ps1:16412 Top-level body Verbose/logging output handler. Called with <code>-Caller</code>, <code>-Status</code> (i), <code>-Message</code>, <code>-Verbosity</code> to log the creation of the temp file"},{"location":"porting-reference/TempOpen_DependencyCatalog/#2-external-variables-loaded","title":"2. External Variables Loaded","text":"Variable Defined At Type Description <code>$D_PSLIB_TEMP</code> main.ps1:17400 <code>[System.String]</code> The absolute path to the pslib temporary file directory (<code>C:\\bin\\pslib\\temp</code>). Used as the base directory for all temp file creation <code>$Sep</code> main.ps1:17383 <code>[System.Char]</code> Directory separator character (<code>[System.IO.Path]::DirectorySeparatorChar</code>). Used to construct the full temp file path"},{"location":"porting-reference/TempOpen_DependencyCatalog/#3-external-binaries-executables-invoked","title":"3. External Binaries / Executables Invoked","text":"Binary Notes (none) This function is entirely PowerShell/.NET-based and does not invoke any external executables."},{"location":"porting-reference/TempOpen_DependencyCatalog/#4-parameters","title":"4. Parameters","text":"Parameter Type Alias(es) Default Description <code>Type</code> <code>[System.String]</code> <code>t</code>, <code>TempType</code> <code>'tmp'</code> The file extension for the new temp file. Leading dots are stripped automatically <code>Name</code> <code>[System.String]</code> <code>n</code>, <code>TempName</code> <code>'x'</code> A descriptive prefix substring embedded in the temp file name for identification <code>PathOnly</code> <code>[System.Boolean]</code> <code>p</code> <code>$false</code> If <code>$true</code>, returns the computed file path without actually creating the file <code>Verbosity</code> <code>[System.Boolean]</code> <code>v</code> <code>$false</code> Controls whether verbose/log messages are printed to the console"},{"location":"porting-reference/TempOpen_DependencyCatalog/#5-internal-sub-functions","title":"5. Internal Sub-Functions","text":"<p>This function defines no internal sub-functions.</p>"},{"location":"porting-reference/TempOpen_DependencyCatalog/#6-internal-logic-summary","title":"6. Internal Logic Summary","text":"<p>File Name Generation:</p> <p>The temp file name is constructed using the following template:</p> <pre><code>.{UUID}-{Name}-{UnixTimeMs}.{Type}\n</code></pre> <p>Where: - Leading dot (<code>.</code>) makes the file hidden on Unix-like systems - <code>{UUID}</code> is a GUID with hyphens removed (<code>[System.GUID]::NewGuid().ToString().Replace('-','')</code>) - <code>{Name}</code> is the user-specified descriptive prefix (default: <code>\"x\"</code>) - <code>{UnixTimeMs}</code> is the current Unix time in milliseconds - <code>{Type}</code> is the file extension (default: <code>\"tmp\"</code>)</p> <p>Historical Note: The function was updated on 2024-10-27 to use UUIDs instead of Unix timestamps as the primary uniqueness component, due to an actual name collision that occurred during concurrent script executions.</p> <p>Path Construction:</p> <p>The full path is: <code>$D_PSLIB_TEMP</code> + <code>$Sep</code> + file name</p> <p>File Creation:</p> <p>Unless <code>-PathOnly</code> is <code>$true</code>, the file is created via <code>New-Item -ItemType File -Force</code>. The output of <code>New-Item</code> is suppressed via <code>| Out-Null</code>.</p>"},{"location":"porting-reference/TempOpen_DependencyCatalog/#7-net-types-and-methods-used","title":"7. .NET Types and Methods Used","text":"Type / Method Usage <code>[System.GUID]::NewGuid()</code> Generating UUID for temp file name uniqueness <code>[DateTimeOffset]::Now.ToUnixTimeMilliseconds()</code> Generating timestamp component for temp file name"},{"location":"porting-reference/TempOpen_DependencyCatalog/#8-powershell-built-in-cmdlets-used","title":"8. PowerShell Built-in Cmdlets Used","text":"Cmdlet Usage Context <code>New-Item</code> Creating the temp file (<code>-ItemType File</code>, <code>-Force</code>, <code>-Path</code>) <code>Select-Object</code> Extracting <code>$PWD</code> path (<code>-Expand Path</code>) \u2014 though <code>$HereNow</code> is computed but unused in this function"},{"location":"porting-reference/TempOpen_DependencyCatalog/#9-return-value","title":"9. Return Value","text":"<p>Returns a <code>[System.String]</code> containing the absolute path to the newly created (or hypothetical, if <code>-PathOnly</code>) temporary file.</p>"},{"location":"porting-reference/TempOpen_DependencyCatalog/#10-companion-function-tempclose","title":"10. Companion Function: TempClose","text":"<p><code>TempOpen</code> is designed to be used in conjunction with <code>TempClose</code> (main.ps1:15044). The expected usage pattern is:</p> <pre><code>$MyTempFile = (TempOpen -Type json -Name \"myProject\")\n# ... use $MyTempFile ...\nTempClose -Target $MyTempFile\n</code></pre> <p>The docstring explicitly warns that failing to call <code>TempClose</code> will leave orphaned temp files in the pslib temp directory.</p>"},{"location":"porting-reference/TempOpen_DependencyCatalog/#11-call-graph","title":"11. Call Graph","text":"<pre><code>TempOpen\n\u251c\u2500\u2500 [validates and normalizes Type parameter]\n\u251c\u2500\u2500 [validates and normalizes Name parameter]\n\u251c\u2500\u2500 [generates UUID and timestamp]\n\u251c\u2500\u2500 [constructs file name and full path]\n\u251c\u2500\u2500 (PathOnly=$false) \u2192 New-Item (create file)\n\u2502   \u2514\u2500\u2500 Vbs \u25c4\u2500\u2500 external pslib (info: \"Creating new temp file\")\n\u2514\u2500\u2500 return file path string\n</code></pre>"},{"location":"porting-reference/Vbs_DependencyCatalog/","title":"Vbs \u2014 Dependency Catalog","text":"<p>Source: <code>main.ps1</code>, line 16412 Purpose: Structured logging and colorized verbosity output handler used throughout the pslib library as the centralized logging facility Audience: AI-first, Human-second  </p>"},{"location":"porting-reference/Vbs_DependencyCatalog/#1-external-pslib-functions-called","title":"1. External PsLib Functions Called","text":"Function Defined At Called From Purpose (none) \u2014 \u2014 <code>Vbs</code> is a leaf-level function in the pslib dependency graph. It does not call any other pslib functions. It is the terminal logging endpoint that virtually every other pslib function routes its verbose and log output through."},{"location":"porting-reference/Vbs_DependencyCatalog/#role-in-the-library","title":"Role in the Library","text":"<p><code>Vbs</code> is the most widely-called function in the pslib library. It serves as the universal logging handler and is invoked by every function cataloged in this project (Base64DecodeString, Date2UnixTime, DirectoryId, FileId, MetaFileRead, TempOpen, TempClose) as well as by MakeIndex and its sub-functions. It has zero upstream pslib dependencies, making it the foundational infrastructure function of the library.</p>"},{"location":"porting-reference/Vbs_DependencyCatalog/#2-external-variables-loaded","title":"2. External Variables Loaded","text":"Variable Defined At Type Description <code>$D_PSLIB_LOGS</code> main.ps1:17399 <code>[System.String]</code> The absolute path to the pslib log directory (<code>C:\\bin\\pslib\\logs</code>). Used as the default value for the <code>-LogDir</code> parameter. Log files are written to this directory <code>$LibSessionID</code> main.ps1:17387 <code>[System.String]</code> A GUID (hyphens removed) generated once at script load time. Used as the default value for the <code>-VbsSessionID</code> parameter. Embedded in every log entry to identify the session"},{"location":"porting-reference/Vbs_DependencyCatalog/#3-external-binaries-executables-invoked","title":"3. External Binaries / Executables Invoked","text":"Binary Notes (none) This function is entirely PowerShell/.NET-based and does not invoke any external executables."},{"location":"porting-reference/Vbs_DependencyCatalog/#4-parameters","title":"4. Parameters","text":"Parameter Type Alias(es) Default Description <code>Message</code> <code>[System.String]</code> (none) (none) The log message body. Defaults to <code>'...'</code> if empty <code>Caller</code> <code>[System.String]</code> (none) (none) The name of the calling function or colon-delimited call stack (e.g., <code>\"MakeIndex:MakeObject:GetFileExif\"</code>) <code>Status</code> <code>[System.String]</code> (none) (none) The severity level of the message. Accepted values (case-insensitive): <code>i</code>/<code>inf</code>/<code>info</code>, <code>e</code>/<code>err</code>/<code>error</code>, <code>c</code>/<code>crit</code>/<code>critical</code>, <code>w</code>/<code>warn</code>/<code>warning</code>, <code>d</code>/<code>deb</code>/<code>debug</code>, <code>s</code>/<code>success</code>/<code>ok</code>/<code>done</code>/<code>complete</code>/<code>g</code>/<code>good</code>, <code>x</code>/<code>u</code>/<code>unknown</code> <code>LogDir</code> <code>[System.String]</code> <code>LogDirectory</code> <code>$D_PSLIB_LOGS</code> Directory where log files are written <code>LibName</code> <code>[System.String]</code> <code>LibraryName</code> <code>\"pslib\"</code> Library name prefix used in log entry formatting <code>VbsSessionID</code> <code>[System.String]</code> (none) <code>$LibSessionID</code> Session identifier embedded in each log entry <code>Verbosity</code> <code>[System.Boolean]</code> <code>v</code> (none) If <code>$true</code>, the message is both written to the log file AND printed to the console. If <code>$false</code>, the message is only written to the log file"},{"location":"porting-reference/Vbs_DependencyCatalog/#5-internal-sub-functions-defined-within-vbs","title":"5. Internal Sub-Functions (Defined Within Vbs)","text":"Function Line Purpose Nesting <code>VbsFunctionStackTotalDepth</code> main.ps1:16491 Calculates the total depth of the function call stack string. Each non-numbered function counts as 1; numbered functions (e.g., <code>MakeObject(3)</code>) count as the numeric suffix value. Returns an <code>[int]</code> Top-level internal <code>VbsLogPath</code> main.ps1:16517 Derives the path to the current monthly log file based on the current date. Format: <code>YYYY_MM.log</code> in the log directory Top-level internal <code>VbsLogRealityCheck</code> main.ps1:16529 Ensures the log directory and log file exist, creating them if necessary via <code>New-Item</code> Top-level internal <code>VbsLogWrite</code> main.ps1:16545 Writes a string to the log file via <code>Add-Content</code> Top-level internal <code>VbsUpdateFunctionStack</code> main.ps1:16558 Compresses and updates a colon-delimited function call stack by collapsing consecutive duplicate function names into counted entries (e.g., <code>A:A:A</code> \u2192 <code>A(3)</code>). Used to produce readable stack traces in log entries Top-level internal <code>VbsUpdateFunctionStackExtractNumber</code> main.ps1:16567 Extracts the numeric suffix from a function name string (e.g., <code>\"MakeObject(3)\"</code> \u2192 <code>2</code>). Returns <code>[int]0</code> if no suffix or suffix is less than 2 Nested inside <code>VbsUpdateFunctionStack</code>"},{"location":"porting-reference/Vbs_DependencyCatalog/#6-internal-logic-summary","title":"6. Internal Logic Summary","text":"<p>Log Entry Construction:</p> <p>Each log entry is assembled from four fields:</p> <ol> <li> <p>Timestamp (<code>$t</code>): Dual-format Unix milliseconds and human-readable ISO datetime with timezone offset. Format: <code>{UnixMs}|{yyyy-MM-dd HH:mm:ss.fffzzz}|</code></p> </li> <li> <p>Session ID (<code>$x</code>): The <code>VbsSessionID</code> GUID followed by a pipe delimiter.</p> </li> <li> <p>Status (<code>$s</code>): Normalized from shorthand input to a bracketed tag. The verbose version (<code>$sV</code>) uses a fixed-width padded format for console alignment. Each status level has an associated console color:</p> </li> </ol> Input Log Tag Console Color <code>i</code>, <code>inf</code>, <code>info</code> <code>[INFO]</code> Gray <code>e</code>, <code>err</code>, <code>error</code> <code>[ERROR]</code> DarkRed <code>c</code>, <code>crit</code>, <code>critical</code> <code>[ERROR][CRITICAL]</code> Magenta <code>w</code>, <code>warn</code>, <code>warning</code> <code>[WARN]</code> DarkYellow <code>d</code>, <code>deb</code>, <code>debug</code> <code>[DEBUG]</code> DarkCyan <code>s</code>, <code>success</code>, <code>ok</code>, <code>done</code>, <code>g</code>, <code>good</code> <code>[INFO][SUCCESS]</code> DarkGreen <code>x</code>, <code>u</code>, <code>unknown</code> (or missing) <code>[INFO][UNKNOWN]</code> DarkGray <ol> <li> <p>Caller (<code>$c</code>): Processed through <code>VbsUpdateFunctionStack</code> to compress the call stack. The final log-format wraps the stack in <code>pslib(...):</code>; the verbose-format uses <code>pslib({depth}):</code> where <code>{depth}</code> is the total stack depth.</p> </li> <li> <p>Message (<code>$m</code>): The raw message string. Defaults to <code>'...'</code> if empty.</p> </li> </ol> <p>Output Channels:</p> <p>Two output strings are produced: <code>$o</code> (machine-readable, written to log file) and <code>$oV</code> (human-readable, colorized, printed to console). When <code>$Verbosity</code> is <code>$false</code>, only the log file is written. When <code>$true</code>, both outputs are produced.</p> <p>Log File Management:</p> <p>Log files are named by month (<code>YYYY_MM.log</code>) and stored in <code>$D_PSLIB_LOGS</code>. The <code>VbsLogRealityCheck</code> sub-function ensures both the directory and file exist before writing, creating them via <code>New-Item</code> if missing.</p> <p>Call Stack Compression:</p> <p>The <code>VbsUpdateFunctionStack</code> function is a key feature that transforms raw colon-delimited call stacks into compact representations. For example: <code>MakeIndex:MakeObject:MakeObject:MakeObject</code> \u2192 <code>MakeIndex:MakeObject(3)</code>. This prevents log lines from becoming excessively long during deeply recursive operations like <code>MakeDirectoryIndexRecursiveLogic</code>.</p>"},{"location":"porting-reference/Vbs_DependencyCatalog/#7-net-types-and-methods-used","title":"7. .NET Types and Methods Used","text":"Type / Method Usage <code>[DateTimeOffset]::Now.ToUnixTimeMilliseconds()</code> Generating Unix epoch milliseconds for the timestamp field <code>[System.TimeSpan]::FromMilliseconds()</code> Converting Unix ms back to a TimeSpan for human-readable date formatting <code>Get-Date 01.01.1970</code> Establishing the Unix epoch base date for timestamp calculation"},{"location":"porting-reference/Vbs_DependencyCatalog/#8-powershell-built-in-cmdlets-used","title":"8. PowerShell Built-in Cmdlets Used","text":"Cmdlet Usage Context <code>Add-Content</code> Writing log entries to the monthly log file (<code>-Path</code>, <code>-Value</code>) <code>Get-Date</code> Establishing the epoch base date; formatting the human-readable timestamp (<code>-UFormat \"%Y_%m\"</code> for log file naming) <code>New-Item</code> Creating log directory and log file if they don't exist (<code>-ItemType Directory/File</code>, <code>-Path</code>, <code>-Force</code>) <code>Test-Path</code> Checking existence of log directory and log file (<code>-LiteralPath</code>, <code>-PathType Container/Leaf</code>) <code>Write-Host</code> Printing colorized verbose output to the console (<code>-ForegroundColor</code>)"},{"location":"porting-reference/Vbs_DependencyCatalog/#9-return-value","title":"9. Return Value","text":"<p>This function does not return a value. All code paths terminate with <code>return</code> (no value). The function's purpose is side-effect-driven: writing to log files and optionally printing to the console.</p>"},{"location":"porting-reference/Vbs_DependencyCatalog/#10-log-file-format","title":"10. Log File Format","text":"<p>File naming: <code>YYYY_MM.log</code> (one file per month)</p> <p>Entry format (machine-readable):</p> <pre><code>{UnixMs}|{yyyy-MM-dd HH:mm:ss.fffzzz}|{SessionGUID}|{StatusTags}{LibName}({CompressedStack}): {Message}\n</code></pre> <p>Entry format (console/verbose):</p> <pre><code>{yyyy-MM-dd HH:mm:ss.fffzzz} {SessionGUID} {PaddedStatus} {LibName}({StackDepth}): {Message}\n</code></pre>"},{"location":"porting-reference/Vbs_DependencyCatalog/#11-call-graph","title":"11. Call Graph","text":"<pre><code>Vbs\n\u251c\u2500\u2500 [construct timestamp field]\n\u2502   \u251c\u2500\u2500 [DateTimeOffset]::Now.ToUnixTimeMilliseconds()\n\u2502   \u2514\u2500\u2500 [System.TimeSpan]::FromMilliseconds()\n\u251c\u2500\u2500 [construct session ID field]\n\u251c\u2500\u2500 [normalize Status to tag and color]\n\u251c\u2500\u2500 [process Caller field]\n\u2502   \u251c\u2500\u2500 [split on ':' to detect sub-function stacks]\n\u2502   \u2514\u2500\u2500 VbsUpdateFunctionStack (compress stack)\n\u2502       \u2514\u2500\u2500 VbsUpdateFunctionStackExtractNumber (extract numeric suffixes)\n\u251c\u2500\u2500 VbsFunctionStackTotalDepth (compute depth for verbose format)\n\u251c\u2500\u2500 [construct message field]\n\u251c\u2500\u2500 VbsLogPath (derive log file path from current date)\n\u251c\u2500\u2500 VbsLogRealityCheck (ensure log dir and file exist)\n\u2502   \u2514\u2500\u2500 New-Item (create if missing)\n\u251c\u2500\u2500 (Verbosity=$false) \u2192 VbsLogWrite only\n\u2502   \u2514\u2500\u2500 Add-Content (write to log file)\n\u2514\u2500\u2500 (Verbosity=$true) \u2192 VbsLogWrite + Write-Host\n    \u251c\u2500\u2500 Add-Content (write to log file)\n    \u2514\u2500\u2500 Write-Host (colorized console output)\n</code></pre>"},{"location":"schema/","title":"Schema Reference","text":"<p>The v2 output schema defines the structure of index entries produced by <code>shruggie-indexer</code>. It is a ground-up restructuring of the original MakeIndex v1 output format \u2014 consolidating related fields into logical sub-objects, eliminating redundancies, and adding a <code>schema_version</code> discriminator for forward compatibility.</p>"},{"location":"schema/#canonical-schema","title":"Canonical Schema","text":"<p>The authoritative schema definition is hosted at:</p> <ul> <li>Canonical URL: schemas.shruggie.tech/data/shruggie-indexer-v2.schema.json</li> <li>Local copy: shruggie-indexer-v2.schema.json</li> </ul> <p>The local copy is committed to the repository and kept in sync with the canonical hosted version.</p>"},{"location":"schema/#schema-types","title":"Schema Types","text":"<p>The v2 schema defines the following reusable type definitions:</p> Type Description <code>IndexEntry</code> Top-level object representing a single indexed file or directory. <code>NameObject</code> Original and storage name fields for a filesystem item. <code>HashSet</code> MD5, SHA1, SHA256, and SHA512 hashes computed from a single source. <code>SizeObject</code> File size in bytes and human-readable form. <code>TimestampPair</code> Unix timestamp (milliseconds) paired with an ISO 8601 string. <code>TimestampsObject</code> Accessed, created, and modified timestamp pairs. <code>ParentObject</code> Identity and name of the parent directory. <code>MetadataEntry</code> A single sidecar metadata file's parsed content and attributes."},{"location":"schema/#validation-examples","title":"Validation Examples","text":"<p>The examples/ directory contains real-world v2-compliant output files that demonstrate the schema in practice:</p> <ul> <li>flashplayer.exe_meta2.json</li> </ul>"},{"location":"user/","title":"User Guide","text":"<p>Welcome to the <code>shruggie-indexer</code> user guide.</p> <p>!!! note \"Work in Progress\"     User-facing documentation is being authored incrementally as the CLI interface and configuration system stabilize. For current usage information, see the README at the repository root.</p>"},{"location":"user/#contents","title":"Contents","text":"<ul> <li>Installation \u2014 System requirements, installation methods, and verification.</li> <li>Quick Start \u2014 Index your first file or directory in minutes.</li> <li>Configuration \u2014 Configuration file format, default values, and override behavior.</li> <li>Testing Troubleshooting \u2014 Steps for test/lint freezes and release-blocking diagnostics.</li> <li>Changelog \u2014 Version history and release notes.</li> </ul>"},{"location":"user/changelog/","title":"Changelog","text":"<p>All notable changes to <code>shruggie-indexer</code> will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"user/changelog/#unreleased","title":"[Unreleased]","text":"<ul> <li>Initial development in progress.</li> </ul>"},{"location":"user/configuration/","title":"Configuration","text":"<p>!!! note \"Work in Progress\"     This page will be populated as the configuration system stabilizes. For the full configuration specification, see \u00a77 of the technical specification.</p>"},{"location":"user/configuration/#configuration-file","title":"Configuration File","text":"<p><code>shruggie-indexer</code> reads configuration from a TOML file. The configuration file is optional \u2014 sensible defaults are built into the tool.</p>"},{"location":"user/configuration/#configuration-hierarchy","title":"Configuration Hierarchy","text":"<p>Configuration values are resolved in the following order (highest priority first):</p> <ol> <li>CLI flags / API arguments</li> <li>User configuration file</li> <li>Built-in defaults</li> </ol>"},{"location":"user/configuration/#topics","title":"Topics","text":"<p>Detailed configuration documentation will cover:</p> <ul> <li>File format and location</li> <li>Default values for all settings</li> <li>Metadata file parser patterns</li> <li>Exiftool exclusion lists</li> <li>Sidecar suffix patterns and type identification</li> <li>Override and merging behavior</li> </ul>"},{"location":"user/installation/","title":"Installation","text":"<p>!!! note \"Work in Progress\"     This page will be populated as the project reaches a stable release. For current installation guidance, see the README.</p>"},{"location":"user/installation/#system-requirements","title":"System Requirements","text":"<ul> <li>Python 3.12 or later</li> <li><code>exiftool</code> (optional, for EXIF metadata extraction)</li> </ul>"},{"location":"user/installation/#installation-methods","title":"Installation Methods","text":""},{"location":"user/installation/#from-pypi","title":"From PyPI","text":"<pre><code>pip install shruggie-indexer\n</code></pre>"},{"location":"user/installation/#from-source","title":"From Source","text":"<pre><code>git clone https://github.com/shruggietech/shruggie-indexer.git\ncd shruggie-indexer\npip install -e \".[dev,gui]\"\n</code></pre>"},{"location":"user/installation/#standalone-executable","title":"Standalone Executable","text":"<p>Pre-built executables for Windows, macOS, and Linux are available on the Releases page.</p>"},{"location":"user/installation/#verification","title":"Verification","text":"<pre><code>shruggie-indexer --version\n</code></pre>"},{"location":"user/quickstart/","title":"Quick Start","text":"<p>!!! note \"Work in Progress\"     This page will be populated as the CLI interface stabilizes. For current usage information, see the README.</p>"},{"location":"user/quickstart/#index-a-single-file","title":"Index a Single File","text":"<pre><code>shruggie-indexer file path/to/file.txt\n</code></pre>"},{"location":"user/quickstart/#index-a-directory","title":"Index a Directory","text":"<pre><code>shruggie-indexer dir path/to/directory/\n</code></pre>"},{"location":"user/quickstart/#index-a-directory-recursively","title":"Index a Directory Recursively","text":"<pre><code>shruggie-indexer tree path/to/directory/\n</code></pre>"},{"location":"user/quickstart/#output-modes","title":"Output Modes","text":"<p>By default, index output is written to stdout as JSON. See the Configuration page for output mode options including file output and in-place sidecar writes.</p>"},{"location":"user/testing-troubleshooting/","title":"Testing &amp; Lint Troubleshooting","text":"<p>This page documents practical recovery steps for contributor environments where testing appears to hang or where the editor becomes unresponsive during linting.</p>"},{"location":"user/testing-troubleshooting/#symptom-vs-code-freezes-during-ruff","title":"Symptom: VS Code freezes during <code>ruff</code>","text":"<p>If your session freezes specifically when linting starts, the most common trigger in this project is running Ruff against the full repository (<code>ruff check .</code>) from an IDE-integrated terminal with heavy output rendering.</p> <p>In this repository, Ruff is configured with <code>src = [\"src\"]</code> in <code>pyproject.toml</code>, and the delivery plan calls out <code>ruff check src/</code> as the expected lint command.</p>"},{"location":"user/testing-troubleshooting/#why-this-matters","title":"Why this matters","text":"<p><code>ruff check .</code> includes test and docs trees, which can produce a large number of findings in one run. That is unnecessary for release readiness, because release automation currently runs pytest and build steps (not Ruff) on tag push.</p>"},{"location":"user/testing-troubleshooting/#recommended-command-sequence-safe-baseline","title":"Recommended command sequence (safe baseline)","text":"<p>Run these from a standalone terminal (PowerShell, CMD, or external bash), not from a busy VS Code integrated terminal:</p> <pre><code>python -m pytest tests/ -m \"not requires_exiftool\"\nruff check src/\n</code></pre> <p>Optional: if you need test linting too, run it separately:</p> <pre><code>ruff check tests/\n</code></pre> <p>Splitting lint scope makes failures easier to read and avoids terminal flood in a single command.</p>"},{"location":"user/testing-troubleshooting/#if-vs-code-still-freezes","title":"If VS Code still freezes","text":"<ol> <li>Disable Ruff's editor integration temporarily and run Ruff only from the terminal.</li> <li>Run lint with narrower scope (<code>ruff check src/</code> first).</li> <li>Redirect lint output to a file for inspection:</li> </ol> <p><code>bash    ruff check src/ &gt; ruff.log</code></p> <ol> <li>Re-open VS Code with all extensions disabled once (<code>code --disable-extensions</code>) to isolate extension conflicts.</li> <li>Re-enable extensions one by one, starting with Python and Ruff.</li> </ol>"},{"location":"user/testing-troubleshooting/#release-blocking-triage-checklist","title":"Release-blocking triage checklist","text":"<p>Use this order before cutting the first release tag:</p> <ol> <li><code>pytest tests/ -m \"not requires_exiftool\"</code></li> <li><code>ruff check src/</code></li> <li>Optional: <code>ruff check tests/</code></li> <li>Build script (<code>scripts/build.sh</code> or <code>scripts/build.ps1</code>)</li> </ol> <p>If step 1 and step 4 pass, you can still validate release packaging behavior even if test linting cleanup is deferred.</p>"}]}